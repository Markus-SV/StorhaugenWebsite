@page "/not-found"
@using StorhaugenWebsite.Shared
@layout MainLayout

<h3>Not Found</h3>
<p>Sorry, the content you are looking for does not exist.</p>

@* Yes, absolutely! That is the cleanest and most robust architectural solution.

Transforming a recipe into a GlobalRecipe upon "publishing" solves the referencing problem entirely. It unifies your data structure so that "Browsing" only ever looks at one table (global_recipes), and "Adding" always works the same way (linking to a global ID).

Why this is the best approach
Solves the "Conundrum": Since the recipe now lives in the global_recipes table, other households can link to it using the existing global_recipe_id column.

Unified "Browse" Logic: You no longer need separate API calls for "HelloFresh" vs. "Community". You just query global_recipes and filter by is_hellofresh.

Shared Ratings: If 10 families add your lasagna, they are all rating the same GlobalRecipe row. The average rating becomes real and valuable.

"Master" Version: As the creator, if you update the Global Recipe, everyone who linked to it (added as reference) sees the improvement. (THIS IS WRONG):
EDIT: i dont want the user to be able to edit the global recipe after publishing, so the user needs to get a warning about that before publishing.
Additionally, publishing a recipe should not convert the household recipe into a global recipe, but rather create a new global recipe and link the household recipe to it. 
This way, the household recipe remains editable locally, but any changes won't affect the global version. here is a prompt for further details:


START PROMPT-------
This is a solid foundation. You have a clean Clean Architecture setup with Blazor WASM and a PostgreSQL backend. The separation of concerns (API, Client, Shared DTOs) is professional.

However, you have hit a classic architectural wall: The "Multi-Tenant vs. Social Network" conflict.

Currently, your app treats a Household like a corporate tenant (isolated). You want it to act like Instagram (social), while keeping the utility of a family meal planner.

Here is my breakdown of how to solve the "Forking/Rating" problem and how to pivot the UX to be more social.

1. Solving the "Forking vs. Reference" Rating Problem
You are worried that if a user changes a recipe locally, their rating shouldn't count toward the Global average.

The Solution: The "Soft Link" Model Don't try to programmatically calculate "how much changed." It is too complex. Instead, rely on intent.

The Default State (Reference): When a user adds a Global Recipe to their household, it is a Reference.

Your household_recipes table has a global_recipe_id.

Logic: Any rating the user gives here automatically counts towards the global_recipes average.

Why? If I add extra garlic to a "HelloFresh Pasta" and rate it 5 stars, I am still effectively rating the HelloFresh Pasta.

The "Detach" Action (Hard Fork):

Add a button in the UI: "Save as my own recipe" (or "Detach").

If clicked, you clear the global_recipe_id in the database and treat it as a brand new household_recipe.

Logic: Ratings here do not count toward the original Global recipe. They count toward this new unique recipe.

Visual Indication:

In the UI, if a recipe is linked, show a small link icon or "Based on [Original Title]".

If the user edits the Title or Main Ingredients drastically, prompt them: "You've changed this a lot. Do you want to save this as a new custom recipe?"
END PROMPT-------

Additionally i want the user to be able to create their own list without joining a household first. This would also include a big refactor of how the app and backend/sql tables work. Here is a prompt for that:

START PROMPT 2
2. Pivoting from "Household Utility" to "Social App"
Your concern is valid: The app feels like a utility because the User is hidden behind the Household. In social apps, the User is the star; the Group (Household) is just a context.

Architectural Pivot: "User First, Household Context"

Currently, your Index.razor blocks everything if !HouseholdState.HasHousehold. This is the friction point.

Suggested Changes:

The "Personal Cookbook" (No Household Required):

Allow users to function without a household.

Create a "Personal" context. When they add a recipe, it goes to their personal list.

When they join a household later, they can "Move" or "Copy" their personal recipes to the household.

The "Feed" Concept (Social Layer):

Change the Home Page (/) from a list of My Dinner to a Dashboard.

Tab 1: Kitchen (Utility): This is your current view. "What's for dinner?" (Household specific).

Tab 2: Feed (Social): "What are my friends eating?"

Show cards: "User X rated 'Spicy Tacos' 9.5" or "The Hansen Household just planned 'Pizza'".

This encourages discovery.

Global vs. Local Comments:

Currently, comments are in the ratings table.

UI Change: When viewing a Global Recipe, show two tabs for reviews:

"From your Household" (Private chatter: "Kids didn't like this").

"Community" (Public ratings).
END PROMPT 2

I need some way to show in the list of recipes what recipes are local, and which are published(global). Maybe a small icon or label next to the recipe title indicating its status.

How to Implement "Publishing"
You need to create a specific endpoint that "promotes" a local household recipe to the global table.

1. Backend Controller (HouseholdRecipesController.cs)
Add a new PublishRecipe endpoint. This logic takes your local data, creates a global entry, and then links your local copy to it.

C#

[HttpPost("{id}/publish")]
public async Task<ActionResult<HouseholdRecipeDto>> PublishRecipe(Guid id)
{
    var userId = await _currentUserService.GetOrCreateUserIdAsync();
    var user = await _context.Users.FindAsync(userId);

    if (user?.CurrentHouseholdId == null)
        return BadRequest(new { message = "You must select a household first" });

    // 1. Fetch the local recipe
    var localRecipe = await _context.HouseholdRecipes
        .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

    if (localRecipe == null) return NotFound();
    if (localRecipe.GlobalRecipeId != null) 
        return BadRequest(new { message = "This recipe is already linked to a global recipe." });

    // 2. Create the Global Recipe
    var globalRecipe = new GlobalRecipe
    {
        Id = Guid.NewGuid(),
        Title = localRecipe.LocalTitle ?? "Untitled",
        Description = localRecipe.LocalDescription,
        ImageUrl = localRecipe.LocalImageUrl, // Assume single image or primary
        ImageUrls = localRecipe.LocalImageUrl ?? "[]", // Simplified mapping
        CreatedByUserId = userId,
        IsPublic = true,
        IsHellofresh = false, // Crucial distinction
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow,
        TotalTimesAdded = 1, // You are the first one adding it
        Ingredients = localRecipe.LocalIngredients ?? "[]", // Map your ingredients
        Tags = "[]"
    };

    _context.GlobalRecipes.Add(globalRecipe);

    // 3. Link the Local Recipe to the new Global one
    // We clear local overrides so it "syncs" with the published version
    localRecipe.GlobalRecipeId = globalRecipe.Id;
    localRecipe.IsPublic = true; // Flag for UI
    localRecipe.LocalTitle = null; 
    localRecipe.LocalDescription = null;
    localRecipe.LocalImageUrl = null; 

    await _context.SaveChangesAsync();

    return Ok(MapToDto(localRecipe));
}
2. Refactoring the "Browse" Logic
Now that community recipes are GlobalRecipes, you can simplify your Browse page significantly. You no longer need to search household_recipes.

Updated GlobalRecipesController.cs logic:

Your existing BrowseGlobalRecipes endpoint works almost as-is! You just need to tweak how you interpret the filters.

HelloFresh Tab: Filter IsHelloFresh == true.

Community Tab: Filter IsHelloFresh == false.

C#

// Inside GlobalRecipesController.BrowseRecipes

if (query.HellofreshOnly)
{
    queryable = queryable.Where(gr => gr.IsHellofresh);
}
else if (query.CommunityOnly) // Add this flag to your query DTO
{
    // Community recipes are just global recipes made by users
    queryable = queryable.Where(gr => !gr.IsHellofresh);
}
3. Frontend Changes (BrowseDetail.razor)
With this change, the "Add Reference" button now works for everyone, because everything in the Browse tab has a GlobalRecipeId.

Browse.razor: You can delete BrowsePublicRecipesQuery and PublicRecipeDto. Just use BrowseGlobalRecipesQuery for everything, toggling a boolean for the tabs.

BrowseDetail.razor: The "Add as Reference" button now works for Community recipes because they are global recipes.

The New User Flow
User A creates "Spicy Tacos" in their household (Local only).

User A clicks "Make Public" (new button in food/{id}).

System creates a GlobalRecipe for "Spicy Tacos" and links User A's copy to it.

User B goes to "Browse" -> "Community". They see "Spicy Tacos".

User B clicks "Add as Reference". They get a link to User A's "Spicy Tacos".

User B rates it 5 stars. The global rating updates. User A sees their recipe has 5 stars.

This aligns your app with standard "Social Recipe App" architecture and solves your data isolation issues. *@