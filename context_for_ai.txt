================================================================================
PROJECT CONTEXT FILE
Generated on: 12/19/2025 21:13:35
================================================================================
PROJECT STRUCTURE:
==================
\database\migrate_to_collections.sql
\database\schema.sql
\StorhaugenEats.API\Controllers\CollectionsController.cs
\StorhaugenEats.API\Controllers\FeedController.cs
\StorhaugenEats.API\Controllers\FriendshipsController.cs
\StorhaugenEats.API\Controllers\GlobalRecipesController.cs
\StorhaugenEats.API\Controllers\HelloFreshController.cs
\StorhaugenEats.API\Controllers\RatingsController.cs
\StorhaugenEats.API\Controllers\StorageController.cs
\StorhaugenEats.API\Controllers\TagsController.cs
\StorhaugenEats.API\Controllers\UserRecipesController.cs
\StorhaugenEats.API\Controllers\UsersController.cs
\StorhaugenEats.API\Data\AppDbContext.cs
\StorhaugenEats.API\Helpers\JsonHelper.cs
\StorhaugenEats.API\Models\ActivityFeedItem.cs
\StorhaugenEats.API\Models\Collection.cs
\StorhaugenEats.API\Models\CollectionMember.cs
\StorhaugenEats.API\Models\EtlSyncLog.cs
\StorhaugenEats.API\Models\GlobalRecipe.cs
\StorhaugenEats.API\Models\Rating.cs
\StorhaugenEats.API\Models\RecipeTag.cs
\StorhaugenEats.API\Models\User.cs
\StorhaugenEats.API\Models\UserFriendship.cs
\StorhaugenEats.API\Models\UserRecipe.cs
\StorhaugenEats.API\Models\UserRecipeCollection.cs
\StorhaugenEats.API\Services\ActivityFeedService.cs
\StorhaugenEats.API\Services\CollectionService.cs
\StorhaugenEats.API\Services\CurrentUserService.cs
\StorhaugenEats.API\Services\GlobalRecipeService.cs
\StorhaugenEats.API\Services\HelloFreshScraperService.cs
\StorhaugenEats.API\Services\IActivityFeedService.cs
\StorhaugenEats.API\Services\ICollectionService.cs
\StorhaugenEats.API\Services\ICurrentUserService.cs
\StorhaugenEats.API\Services\IGlobalRecipeService.cs
\StorhaugenEats.API\Services\IHelloFreshScraperService.cs
\StorhaugenEats.API\Services\IRatingService.cs
\StorhaugenEats.API\Services\IStorageService.cs
\StorhaugenEats.API\Services\ITagService.cs
\StorhaugenEats.API\Services\IUserFriendshipService.cs
\StorhaugenEats.API\Services\IUserRecipeService.cs
\StorhaugenEats.API\Services\IUserService.cs
\StorhaugenEats.API\Services\RatingService.cs
\StorhaugenEats.API\Services\SupabaseStorageService.cs
\StorhaugenEats.API\Services\TagService.cs
\StorhaugenEats.API\Services\UserFriendshipService.cs
\StorhaugenEats.API\Services\UserRecipeService.cs
\StorhaugenEats.API\Services\UserService.cs
\StorhaugenEats.API\appsettings.json
\StorhaugenEats.API\Program.cs
\StorhaugenEats.API\StorhaugenEats.API.csproj
\StorhaugenWebsite\ApiClient\ApiClient.cs
\StorhaugenWebsite\ApiClient\IApiClient.cs
\StorhaugenWebsite\Components\ActivityFeed.razor
\StorhaugenWebsite\Components\AddMemberToCollectionDialog.razor
\StorhaugenWebsite\Components\AddToCollectionDialog.razor
\StorhaugenWebsite\Components\CollectionRecipesList.razor
\StorhaugenWebsite\Components\EditRecipeDialog.razor
\StorhaugenWebsite\Components\HelloFreshRecipeDetails.razor
\StorhaugenWebsite\Components\InviteMemberDialog.razor
\StorhaugenWebsite\Components\PublishRecipeDialog.razor
\StorhaugenWebsite\Components\RecipeSkeleton.razor
\StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
\StorhaugenWebsite\Components\XFade.razor
\StorhaugenWebsite\Models\AppConfig.cs
\StorhaugenWebsite\Models\DeviceSettings.cs
\StorhaugenWebsite\Models\FoodItem.cs
\StorhaugenWebsite\Models\ThemeColors.cs
\StorhaugenWebsite\Pages\AddFood.razor
\StorhaugenWebsite\Pages\Archived.razor
\StorhaugenWebsite\Pages\Browse.razor
\StorhaugenWebsite\Pages\BrowseDetails.razor
\StorhaugenWebsite\Pages\CollectionDetails.razor
\StorhaugenWebsite\Pages\CollectionRecipes.razor
\StorhaugenWebsite\Pages\Collections.razor
\StorhaugenWebsite\Pages\CookBook.razor
\StorhaugenWebsite\Pages\FoodDetails.razor
\StorhaugenWebsite\Pages\FriendRatings.razor
\StorhaugenWebsite\Pages\Friends.razor
\StorhaugenWebsite\Pages\HelloTest.razor
\StorhaugenWebsite\Pages\Home.razor
\StorhaugenWebsite\Pages\Login.razor
\StorhaugenWebsite\Pages\NotFound.razor
\StorhaugenWebsite\Pages\Settings.razor
\StorhaugenWebsite\Pages\SharedCollectionView.razor
\StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
\StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
\StorhaugenWebsite\Services\Authentication\IAuthService.cs
\StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
\StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
\StorhaugenWebsite\Services\Collection\CollectionStateService.cs
\StorhaugenWebsite\Services\Collection\ICollectionStateService.cs
\StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
\StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
\StorhaugenWebsite\Services\Food\FoodService.cs
\StorhaugenWebsite\Services\Food\IFoodService.cs
\StorhaugenWebsite\Services\Ocr\IOcrService.cs
\StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
\StorhaugenWebsite\Services\Theme\IThemeService.cs
\StorhaugenWebsite\Services\Theme\ThemeService.cs
\StorhaugenWebsite\Services\User\IUserFriendshipService.cs
\StorhaugenWebsite\Services\User\IUserRecipeService.cs
\StorhaugenWebsite\Services\User\UserColorService.cs
\StorhaugenWebsite\Services\User\UserFriendshipService.cs
\StorhaugenWebsite\Services\User\UserRecipeService.cs
\StorhaugenWebsite\Services\HelloFreshSyncService.cs
\StorhaugenWebsite\Shared\Extensions\RatingColorExtensions.cs
\StorhaugenWebsite\Shared\Authorization.razor
\StorhaugenWebsite\Shared\Authorization.razor.css
\StorhaugenWebsite\Shared\MainLayout.razor
\StorhaugenWebsite\Shared\MainLayout.razor.css
\StorhaugenWebsite\wwwroot\css\app.css
\StorhaugenWebsite\wwwroot\css\Food.css
\StorhaugenWebsite\wwwroot\css\Layout.css
\StorhaugenWebsite\wwwroot\css\Login.css
\StorhaugenWebsite\wwwroot\js\deviceState.js
\StorhaugenWebsite\wwwroot\js\ocrInterop.js
\StorhaugenWebsite\wwwroot\appsettings.json
\StorhaugenWebsite\wwwroot\index.html
\StorhaugenWebsite\wwwroot\manifest.json
\StorhaugenWebsite\App.razor
\StorhaugenWebsite\Program.cs
\StorhaugenWebsite\StorhaugenWebsite.csproj
\StorhaugenWebsite\_Imports.razor
\StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
\StorhaugenWebsite.Shared\DTOs\CollectionDTOs.cs
\StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
\StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
\StorhaugenWebsite.Shared\DTOs\HelloFreshDTOs.cs
\StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
\StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj




================================================================================
FILE START: \database\migrate_to_collections.sql
================================================================================
-- ============================================================
-- MIGRATION: Household-centric to Collection-centric model
-- This script drops all household tables and creates collection tables
-- NOTE: This is destructive - run only on test databases
-- ============================================================

BEGIN;

-- ============================================================
-- STEP 1: DROP RLS POLICIES REFERENCING HOUSEHOLDS
-- ============================================================

-- Drop policies on household tables (if they exist)
DROP POLICY IF EXISTS "Users can view households they belong to" ON households;
DROP POLICY IF EXISTS "Household leaders can update their household" ON households;
DROP POLICY IF EXISTS "Members can view household members" ON household_members;
DROP POLICY IF EXISTS "Leaders can manage household members" ON household_members;
DROP POLICY IF EXISTS "Members can view household recipes" ON household_recipes;
DROP POLICY IF EXISTS "Members can manage household recipes" ON household_recipes;
DROP POLICY IF EXISTS "Household invites are viewable by invitee" ON household_invites;
DROP POLICY IF EXISTS "Household friendships viewable by members" ON household_friendships;

-- Drop any policies on users table that reference current_household_id
DROP POLICY IF EXISTS "Users can view users in same household" ON users;

-- ============================================================
-- STEP 2: DROP FOREIGN KEY ON USERS TABLE
-- ============================================================

-- Drop the FK constraint on users.current_household_id
ALTER TABLE users DROP CONSTRAINT IF EXISTS fk_users_households_current_household_id;
ALTER TABLE users DROP CONSTRAINT IF EXISTS users_current_household_id_fkey;

-- Drop index on current_household_id
DROP INDEX IF EXISTS ix_users_current_household_id;

-- Drop the column
ALTER TABLE users DROP COLUMN IF EXISTS current_household_id;

-- ============================================================
-- STEP 3: DROP HOUSEHOLD-RELATED TABLES (CASCADE)
-- Order matters due to FK dependencies
-- ============================================================

DROP TABLE IF EXISTS household_friendships CASCADE;
DROP TABLE IF EXISTS household_invites CASCADE;
DROP TABLE IF EXISTS household_recipes CASCADE;
DROP TABLE IF EXISTS household_members CASCADE;
DROP TABLE IF EXISTS households CASCADE;

-- ============================================================
-- STEP 4: UPDATE user_recipes visibility values
-- Replace 'household' with 'private' (or 'friends')
-- ============================================================

UPDATE user_recipes SET visibility = 'private' WHERE visibility = 'household';

-- ============================================================
-- STEP 5: CREATE COLLECTIONS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS ix_collections_owner_id ON collections(owner_id);

-- ============================================================
-- STEP 6: CREATE COLLECTION_MEMBERS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS collection_members (
    collection_id UUID NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    is_owner BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (collection_id, user_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS ix_collection_members_user_id ON collection_members(user_id);
CREATE INDEX IF NOT EXISTS ix_collection_members_collection_id ON collection_members(collection_id);

-- ============================================================
-- STEP 7: CREATE USER_RECIPE_COLLECTIONS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS user_recipe_collections (
    user_recipe_id UUID NOT NULL REFERENCES user_recipes(id) ON DELETE CASCADE,
    collection_id UUID NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (user_recipe_id, collection_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS ix_user_recipe_collections_collection_id ON user_recipe_collections(collection_id);
CREATE INDEX IF NOT EXISTS ix_user_recipe_collections_user_recipe_id ON user_recipe_collections(user_recipe_id);

-- ============================================================
-- STEP 8: RLS POLICIES FOR COLLECTIONS
-- ============================================================

-- Enable RLS
ALTER TABLE collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE collection_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_recipe_collections ENABLE ROW LEVEL SECURITY;

-- Collections policies
-- Members can SELECT collections they belong to
CREATE POLICY "Members can view collections they belong to"
ON collections FOR SELECT
USING (
    owner_id = auth.uid()
    OR EXISTS (
        SELECT 1 FROM collection_members cm
        WHERE cm.collection_id = id AND cm.user_id = auth.uid()
    )
);

-- Owners can INSERT collections (they own)
CREATE POLICY "Users can create collections"
ON collections FOR INSERT
WITH CHECK (owner_id = auth.uid());

-- Owners can UPDATE their collections
CREATE POLICY "Owners can update their collections"
ON collections FOR UPDATE
USING (owner_id = auth.uid())
WITH CHECK (owner_id = auth.uid());

-- Owners can DELETE their collections
CREATE POLICY "Owners can delete their collections"
ON collections FOR DELETE
USING (owner_id = auth.uid());

-- Collection members policies
-- Members can SELECT member rows for collections they belong to
CREATE POLICY "Members can view collection membership"
ON collection_members FOR SELECT
USING (
    user_id = auth.uid()
    OR EXISTS (
        SELECT 1 FROM collection_members cm
        WHERE cm.collection_id = collection_id AND cm.user_id = auth.uid()
    )
);

-- Owners can INSERT members
CREATE POLICY "Owners can add members"
ON collection_members FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM collections c
        WHERE c.id = collection_id AND c.owner_id = auth.uid()
    )
    OR (user_id = auth.uid() AND is_owner = TRUE) -- Owner adding themselves
);

-- Owners can DELETE members
CREATE POLICY "Owners can remove members"
ON collection_members FOR DELETE
USING (
    EXISTS (
        SELECT 1 FROM collections c
        WHERE c.id = collection_id AND c.owner_id = auth.uid()
    )
    OR user_id = auth.uid() -- Members can leave
);

-- User recipe collections policies
-- Members can SELECT links for collections they belong to
CREATE POLICY "Members can view collection recipes"
ON user_recipe_collections FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM collection_members cm
        WHERE cm.collection_id = collection_id AND cm.user_id = auth.uid()
    )
);

-- Members can INSERT links (add recipes to collections they're members of)
CREATE POLICY "Members can add recipes to collections"
ON user_recipe_collections FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM collection_members cm
        WHERE cm.collection_id = collection_id AND cm.user_id = auth.uid()
    )
);

-- Members can DELETE links (remove recipes from collections they're members of)
CREATE POLICY "Members can remove recipes from collections"
ON user_recipe_collections FOR DELETE
USING (
    EXISTS (
        SELECT 1 FROM collection_members cm
        WHERE cm.collection_id = collection_id AND cm.user_id = auth.uid()
    )
);

-- ============================================================
-- STEP 9: UPDATE TRIGGER FOR updated_at
-- ============================================================

-- Create or replace trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers
DROP TRIGGER IF EXISTS update_collections_updated_at ON collections;
CREATE TRIGGER update_collections_updated_at
    BEFORE UPDATE ON collections
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_collection_members_updated_at ON collection_members;
CREATE TRIGGER update_collection_members_updated_at
    BEFORE UPDATE ON collection_members
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_user_recipe_collections_updated_at ON user_recipe_collections;
CREATE TRIGGER update_user_recipe_collections_updated_at
    BEFORE UPDATE ON user_recipe_collections
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

COMMIT;

-- ============================================================
-- POST-MIGRATION VERIFICATION QUERIES (run manually)
-- ============================================================
-- SELECT COUNT(*) FROM collections;
-- SELECT COUNT(*) FROM collection_members;
-- SELECT COUNT(*) FROM user_recipe_collections;
-- SELECT COUNT(*) FROM user_recipes WHERE visibility = 'household'; -- Should be 0


================================================================================
FILE END: \database\migrate_to_collections.sql
================================================================================


================================================================================
FILE START: \database\schema.sql
================================================================================
-- ============================================
-- Storhaugen Eats - Multi-Tenant Database Schema
-- Database: PostgreSQL (Supabase)
-- ============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLE: households
-- Represents a group/family sharing a meal list
-- ============================================
CREATE TABLE households (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    leader_id UUID, -- Foreign key to users (set after users table created)
    settings JSONB DEFAULT '{}', -- Theme, preferences, etc.
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- TABLE: users
-- Individual user accounts (integrated with Supabase Auth)
-- ============================================
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, -- Links to Supabase Auth
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    avatar_url TEXT,
    unique_share_id VARCHAR(12) UNIQUE NOT NULL, -- For household invites (e.g., "ABC123XYZ")
    current_household_id UUID REFERENCES households(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add foreign key constraint to households.leader_id now that users exists
ALTER TABLE households ADD CONSTRAINT fk_household_leader
    FOREIGN KEY (leader_id) REFERENCES users(id) ON DELETE SET NULL;

-- ============================================
-- TABLE: global_recipes
-- Source of truth for all HelloFresh items and public user-created recipes
-- ============================================
CREATE TABLE global_recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    image_url TEXT, -- Hosted on Supabase Storage
    ingredients JSONB NOT NULL DEFAULT '[]', -- [{ name, amount, unit, image }]
    nutrition_data JSONB, -- { calories, protein, carbs, fat, etc. }
    cook_time_minutes INTEGER,
    difficulty VARCHAR(50), -- "Easy", "Medium", "Hard"

    -- Source tracking
    is_hellofresh BOOLEAN DEFAULT FALSE,
    hellofresh_uuid VARCHAR(255) UNIQUE, -- Original HelloFresh ID
    hellofresh_slug VARCHAR(255), -- URL slug from HelloFresh
    hellofresh_week VARCHAR(20), -- Week the recipe was available (e.g., "2026-W02")
    created_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL, -- NULL if HelloFresh

    -- Additional metadata
    tags JSONB DEFAULT '[]', -- Tags like "Barnevennlig", "Rask", etc.
    cuisine VARCHAR(100), -- e.g., "Fusion", "Asiatiske"
    servings INTEGER,
    prep_time_minutes INTEGER,
    total_time_minutes INTEGER,

    -- Visibility
    is_public BOOLEAN DEFAULT FALSE, -- Only relevant for user-created items

    -- Aggregated ratings (denormalized for performance)
    average_rating DECIMAL(3,2) DEFAULT 0.00, -- Calculated from ratings table
    rating_count INTEGER DEFAULT 0,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for common queries
CREATE INDEX idx_global_recipes_hellofresh ON global_recipes(is_hellofresh) WHERE is_hellofresh = TRUE;
CREATE INDEX idx_global_recipes_public ON global_recipes(is_public) WHERE is_public = TRUE;
CREATE INDEX idx_global_recipes_rating ON global_recipes(average_rating DESC);
CREATE INDEX idx_global_recipes_hellofresh_uuid ON global_recipes(hellofresh_uuid);
CREATE INDEX idx_global_recipes_hellofresh_week ON global_recipes(hellofresh_week) WHERE hellofresh_week IS NOT NULL;

-- ============================================
-- TABLE: household_recipes
-- Local instances of recipes in a household's list
-- Implements "Reference vs Fork" logic via global_recipe_id
-- ============================================
CREATE TABLE household_recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,

    -- Reference/Fork Logic
    global_recipe_id UUID REFERENCES global_recipes(id) ON DELETE SET NULL,
    -- If global_recipe_id IS NOT NULL → "Linked Mode" (display global data + personal notes)
    -- If global_recipe_id IS NULL → "Forked Mode" (completely local data)

    -- Local data (used when forked, or as personal notes when linked)
    local_title VARCHAR(255), -- Only used if forked
    local_description TEXT,
    local_ingredients JSONB, -- Only used if forked
    local_image_url TEXT, -- Only used if forked
    personal_notes TEXT, -- ALWAYS displayed (even in linked mode)

    -- Metadata
    added_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    is_archived BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Ensure household can't have duplicate global recipes (unless forked)
    UNIQUE NULLS NOT DISTINCT (household_id, global_recipe_id)
);

-- Indexes
CREATE INDEX idx_household_recipes_household ON household_recipes(household_id);
CREATE INDEX idx_household_recipes_global ON household_recipes(global_recipe_id);
CREATE INDEX idx_household_recipes_archived ON household_recipes(is_archived);

-- ============================================
-- TABLE: ratings
-- User ratings for global recipes
-- ============================================
CREATE TABLE ratings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    global_recipe_id UUID NOT NULL REFERENCES global_recipes(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    score INTEGER NOT NULL CHECK (score >= 0 AND score <= 10),
    comment TEXT,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- One rating per user per recipe
    UNIQUE(global_recipe_id, user_id)
);

-- Indexes
CREATE INDEX idx_ratings_global_recipe ON ratings(global_recipe_id);
CREATE INDEX idx_ratings_user ON ratings(user_id);

-- ============================================
-- TABLE: household_invites
-- Pending invitations to join households
-- ============================================
CREATE TABLE household_invites (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,
    invited_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    invited_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'

    -- For merge requests (when invited user already has a household)
    merge_requested BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(household_id, invited_user_id)
);

-- ============================================
-- TABLE: etl_sync_log
-- Tracks HelloFresh ETL scraper runs
-- ============================================
CREATE TABLE etl_sync_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sync_type VARCHAR(50) DEFAULT 'hellofresh', -- Future: other sources
    status VARCHAR(20), -- 'success', 'failed', 'partial'
    recipes_added INTEGER DEFAULT 0,
    recipes_updated INTEGER DEFAULT 0,
    error_message TEXT,
    build_id VARCHAR(255), -- HelloFresh build ID used
    weeks_synced VARCHAR(255), -- e.g., "2025-W51,2025-W52"

    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Index for checking last sync
CREATE INDEX idx_etl_sync_log_started ON etl_sync_log(started_at DESC);

-- ============================================
-- FUNCTIONS & TRIGGERS
-- ============================================

-- Function: Update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to all tables with updated_at
CREATE TRIGGER update_households_updated_at BEFORE UPDATE ON households
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_global_recipes_updated_at BEFORE UPDATE ON global_recipes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_household_recipes_updated_at BEFORE UPDATE ON household_recipes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ratings_updated_at BEFORE UPDATE ON ratings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function: Recalculate global recipe ratings
CREATE OR REPLACE FUNCTION recalculate_global_recipe_rating(recipe_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE global_recipes
    SET
        average_rating = COALESCE((
            SELECT AVG(score)::DECIMAL(3,2)
            FROM ratings
            WHERE global_recipe_id = recipe_id
        ), 0.00),
        rating_count = (
            SELECT COUNT(*)
            FROM ratings
            WHERE global_recipe_id = recipe_id
        )
    WHERE id = recipe_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-update ratings when rating is inserted/updated/deleted
CREATE OR REPLACE FUNCTION update_recipe_rating_on_change()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM recalculate_global_recipe_rating(OLD.global_recipe_id);
    ELSE
        PERFORM recalculate_global_recipe_rating(NEW.global_recipe_id);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ratings_update_recipe_stats
AFTER INSERT OR UPDATE OR DELETE ON ratings
FOR EACH ROW EXECUTE FUNCTION update_recipe_rating_on_change();

-- ============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- Enable RLS for multi-tenancy security
-- ============================================

-- Enable RLS on all tables
ALTER TABLE households ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE global_recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE household_recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE household_invites ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own data
CREATE POLICY users_select_own ON users
    FOR SELECT USING (auth.uid() = id);

-- Policy: Users can update their own data
CREATE POLICY users_update_own ON users
    FOR UPDATE USING (auth.uid() = id);

-- Policy: Users can read their household
CREATE POLICY households_select_member ON households
    FOR SELECT USING (
        id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Household leaders can update household
CREATE POLICY households_update_leader ON households
    FOR UPDATE USING (leader_id = auth.uid());

-- Policy: Anyone can read public global recipes
CREATE POLICY global_recipes_select_public ON global_recipes
    FOR SELECT USING (is_hellofresh = TRUE OR is_public = TRUE);

-- Policy: Users can read their household's recipes
CREATE POLICY household_recipes_select_own ON household_recipes
    FOR SELECT USING (
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Users can insert/update/delete recipes in their household
CREATE POLICY household_recipes_modify_own ON household_recipes
    FOR ALL USING (
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Users can read all ratings for public recipes
CREATE POLICY ratings_select_all ON ratings
    FOR SELECT USING (TRUE);

-- Policy: Users can insert/update their own ratings
CREATE POLICY ratings_modify_own ON ratings
    FOR ALL USING (user_id = auth.uid());

-- Policy: Users can see invites to their household or invites they sent
CREATE POLICY invites_select_relevant ON household_invites
    FOR SELECT USING (
        invited_user_id = auth.uid() OR
        invited_by_user_id = auth.uid() OR
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- ============================================
-- INITIAL DATA & HELPER FUNCTIONS
-- ============================================

-- Function: Generate unique share ID (12 chars, alphanumeric)
CREATE OR REPLACE FUNCTION generate_unique_share_id()
RETURNS VARCHAR(12) AS $$
DECLARE
    chars VARCHAR := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- Exclude confusing chars
    result VARCHAR := '';
    i INTEGER;
    random_index INTEGER;
BEGIN
    FOR i IN 1..12 LOOP
        random_index := floor(random() * length(chars) + 1)::INTEGER;
        result := result || substr(chars, random_index, 1);
    END LOOP;
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function: Create household and set user as leader
CREATE OR REPLACE FUNCTION create_household_for_user(
    user_id UUID,
    household_name VARCHAR(255)
)
RETURNS UUID AS $$
DECLARE
    new_household_id UUID;
BEGIN
    -- Create household
    INSERT INTO households (name, leader_id)
    VALUES (household_name, user_id)
    RETURNING id INTO new_household_id;

    -- Assign user to household
    UPDATE users
    SET current_household_id = new_household_id
    WHERE id = user_id;

    RETURN new_household_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VIEWS FOR COMMON QUERIES
-- ============================================

-- View: Household recipes with global data joined
CREATE OR REPLACE VIEW household_recipes_full AS
SELECT
    hr.id,
    hr.household_id,
    hr.global_recipe_id,
    hr.personal_notes,
    hr.is_archived,
    hr.added_by_user_id,
    hr.created_at,
    hr.updated_at,

    -- Display logic: Use global data if linked, local data if forked
    COALESCE(hr.local_title, gr.title) AS title,
    COALESCE(hr.local_description, gr.description) AS description,
    COALESCE(hr.local_image_url, gr.image_url) AS image_url,
    COALESCE(hr.local_ingredients, gr.ingredients) AS ingredients,

    -- Global recipe metadata (NULL if forked)
    gr.is_hellofresh,
    gr.average_rating,
    gr.rating_count,
    gr.nutrition_data,
    gr.cook_time_minutes,
    gr.difficulty,

    -- Linked/Forked indicator
    CASE
        WHEN hr.global_recipe_id IS NOT NULL THEN 'linked'
        ELSE 'forked'
    END AS recipe_mode

FROM household_recipes hr
LEFT JOIN global_recipes gr ON hr.global_recipe_id = gr.id;

COMMENT ON VIEW household_recipes_full IS 'Combines household recipes with global recipe data, handling linked vs forked logic';

-- ============================================
-- INDEXES FOR PERFORMANCE
-- ============================================

-- Additional indexes for joins
CREATE INDEX idx_users_household ON users(current_household_id);
CREATE INDEX idx_users_share_id ON users(unique_share_id);

-- ============================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================

COMMENT ON TABLE households IS 'Groups/families sharing a meal list';
COMMENT ON TABLE users IS 'Individual user accounts linked to Supabase Auth';
COMMENT ON TABLE global_recipes IS 'Source of truth for HelloFresh and public recipes';
COMMENT ON TABLE household_recipes IS 'Local instances of recipes in household lists (linked or forked)';
COMMENT ON TABLE ratings IS 'User ratings for global recipes (1-10 scale)';
COMMENT ON TABLE household_invites IS 'Pending household invitations and merge requests';
COMMENT ON TABLE etl_sync_log IS 'Tracks HelloFresh scraper sync runs';

COMMENT ON COLUMN household_recipes.global_recipe_id IS 'NULL = forked/local recipe, NOT NULL = linked to global recipe';
COMMENT ON COLUMN household_recipes.personal_notes IS 'Always displayed, even for linked recipes';


================================================================================
FILE END: \database\schema.sql
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\CollectionsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/collections")]
[Authorize]
public class CollectionsController : ControllerBase
{
    private readonly ICollectionService _collectionService;
    private readonly ICurrentUserService _currentUserService;

    public CollectionsController(
        ICollectionService collectionService,
        ICurrentUserService currentUserService)
    {
        _collectionService = collectionService;
        _currentUserService = currentUserService;
    }

    // ==========================================
    // COLLECTION CRUD
    // ==========================================

    /// <summary>
    /// Get all collections for the current user (owned and member of).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<List<CollectionDto>>> GetCollections()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var collections = await _collectionService.GetUserCollectionsAsync(userId);
        return Ok(collections);
    }

    /// <summary>
    /// Get a specific collection by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<CollectionDto>> GetCollection(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var collection = await _collectionService.GetCollectionAsync(id, userId);

        if (collection == null)
            return NotFound(new { message = "Collection not found or you don't have access" });

        return Ok(collection);
    }

    /// <summary>
    /// Get a collection by its share code (for public/friends collections).
    /// </summary>
    [HttpGet("shared/{shareCode}")]
    [AllowAnonymous]
    public async Task<ActionResult<CollectionDto>> GetCollectionByShareCode(string shareCode)
    {
        Guid? userId = null;
        try
        {
            userId = await _currentUserService.GetOrCreateUserIdAsync();
        }
        catch
        {
            // Anonymous access is allowed for public collections
        }

        var collection = await _collectionService.GetCollectionByShareCodeAsync(shareCode, userId);

        if (collection == null)
            return NotFound(new { message = "Collection not found or you don't have access" });

        return Ok(collection);
    }

    /// <summary>
    /// Create a new collection.
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<CollectionDto>> CreateCollection([FromBody] CreateCollectionDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var collection = await _collectionService.CreateCollectionAsync(userId, dto);
            return CreatedAtAction(nameof(GetCollection), new { id = collection.Id }, collection);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Update a collection.
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<CollectionDto>> UpdateCollection(Guid id, [FromBody] UpdateCollectionDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var collection = await _collectionService.UpdateCollectionAsync(id, userId, dto);
            return Ok(collection);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Delete a collection (recipes are not deleted, just unlinked).
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> DeleteCollection(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.DeleteCollectionAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    // ==========================================
    // RECIPE-COLLECTION MANAGEMENT
    // ==========================================

    /// <summary>
    /// Get all recipes in a collection.
    /// </summary>
    [HttpGet("{id}/recipes")]
    public async Task<ActionResult<CollectionRecipesResult>> GetCollectionRecipes(
        Guid id,
        [FromQuery] GetCollectionRecipesQuery? query)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _collectionService.GetCollectionRecipesAsync(id, userId, query);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Add a recipe to a collection.
    /// </summary>
    [HttpPost("{id}/recipes")]
    public async Task<ActionResult> AddRecipeToCollection(Guid id, [FromBody] AddRecipeToCollectionDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.AddRecipeToCollectionAsync(id, userId, dto);
            return Ok(new { message = "Recipe added to collection" });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a recipe from a collection.
    /// </summary>
    [HttpDelete("{id}/recipes/{recipeId}")]
    public async Task<ActionResult> RemoveRecipeFromCollection(Guid id, Guid recipeId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.RemoveRecipeFromCollectionAsync(id, recipeId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    // ==========================================
    // COLLECTION MEMBERSHIP
    // ==========================================

    /// <summary>
    /// Get all members of a collection.
    /// </summary>
    [HttpGet("{id}/members")]
    public async Task<ActionResult<List<CollectionMemberDto>>> GetCollectionMembers(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var members = await _collectionService.GetCollectionMembersAsync(id, userId);
            return Ok(members);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Add a member to a collection.
    /// </summary>
    [HttpPost("{id}/members")]
    public async Task<ActionResult> AddMember(Guid id, [FromBody] AddCollectionMemberDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.AddMemberAsync(id, userId, dto);
            return Ok(new { message = "Member added to collection" });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a member from a collection.
    /// </summary>
    [HttpDelete("{id}/members/{memberId}")]
    public async Task<ActionResult> RemoveMember(Guid id, Guid memberId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.RemoveMemberAsync(id, memberId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Leave a collection (cannot be used by owner).
    /// </summary>
    [HttpPost("{id}/leave")]
    public async Task<ActionResult> LeaveCollection(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _collectionService.LeaveCollectionAsync(id, userId);
            return Ok(new { message = "Left collection" });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Get collections shared by a friend that are visible to the current user.
    /// </summary>
    [HttpGet("friend/{friendUserId}")]
    public async Task<ActionResult<List<CollectionDto>>> GetFriendCollections(Guid friendUserId)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var collections = await _collectionService.GetFriendSharedCollectionsAsync(friendUserId, userId);
        return Ok(collections);
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\CollectionsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\FeedController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/feed")]
[Authorize]
public class FeedController : ControllerBase
{
    private readonly IActivityFeedService _activityFeedService;
    private readonly ICurrentUserService _currentUserService;

    public FeedController(
        IActivityFeedService activityFeedService,
        ICurrentUserService currentUserService)
    {
        _activityFeedService = activityFeedService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get the activity feed (friend activities).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<ActivityFeedPagedResult>> GetFeed([FromQuery] ActivityFeedQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _activityFeedService.GetFeedAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get the current user's activity history.
    /// </summary>
    [HttpGet("my-activity")]
    public async Task<ActionResult<ActivityFeedPagedResult>> GetMyActivity([FromQuery] int page = 1, [FromQuery] int pageSize = 20)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _activityFeedService.GetUserActivityAsync(userId, page, pageSize);
        return Ok(result);
    }

    /// <summary>
    /// Get a summary of the current user's activity.
    /// </summary>
    [HttpGet("summary")]
    public async Task<ActionResult<ActivitySummaryDto>> GetActivitySummary()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var summary = await _activityFeedService.GetActivitySummaryAsync(userId);
        return Ok(summary);
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\FeedController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\FriendshipsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/friendships")]
[Authorize]
public class FriendshipsController : ControllerBase
{
    private readonly IUserFriendshipService _friendshipService;
    private readonly ICurrentUserService _currentUserService;

    public FriendshipsController(
        IUserFriendshipService friendshipService,
        ICurrentUserService currentUserService)
    {
        _friendshipService = friendshipService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all friendships (accepted, pending sent, pending received).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<FriendshipListDto>> GetFriendships()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _friendshipService.GetFriendshipsAsync(userId);
        return Ok(result);
    }

    /// <summary>
    /// Get list of accepted friends only.
    /// </summary>
    [HttpGet("friends")]
    public async Task<ActionResult<List<FriendProfileDto>>> GetFriends()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var friends = await _friendshipService.GetFriendsAsync(userId);
        return Ok(friends);
    }

    /// <summary>
    /// Get a specific friendship by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserFriendshipDto>> GetFriendship(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var friendship = await _friendshipService.GetFriendshipAsync(id, userId);

        if (friendship == null)
            return NotFound(new { message = "Friendship not found" });

        return Ok(friendship);
    }

    /// <summary>
    /// Send a friend request.
    /// </summary>
    [HttpPost("request")]
    public async Task<ActionResult<UserFriendshipDto>> SendFriendRequest([FromBody] SendFriendRequestDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var friendship = await _friendshipService.SendFriendRequestAsync(userId, dto);
            return CreatedAtAction(nameof(GetFriendship), new { id = friendship.Id }, friendship);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Respond to a friend request (accept or reject).
    /// </summary>
    [HttpPost("{id}/respond")]
    public async Task<ActionResult<UserFriendshipDto>> RespondToRequest(Guid id, [FromBody] RespondFriendRequestDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var friendship = await _friendshipService.RespondToRequestAsync(id, userId, dto.Action);
            return Ok(friendship);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a friendship or cancel a pending request.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> RemoveFriendship(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _friendshipService.RemoveFriendshipAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Search for users to add as friends.
    /// </summary>
    [HttpGet("search")]
    public async Task<ActionResult<List<UserSearchResultDto>>> SearchUsers([FromQuery] string query, [FromQuery] int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(query) || query.Length < 2)
            return Ok(new List<UserSearchResultDto>());

        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var results = await _friendshipService.SearchUsersAsync(userId, query, limit);
        return Ok(results);
    }

    /// <summary>
    /// Get a user's public profile.
    /// </summary>
    [HttpGet("profile/{profileUserId}")]
    public async Task<ActionResult<FriendProfileDto>> GetUserProfile(Guid profileUserId)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var profile = await _friendshipService.GetUserProfileAsync(profileUserId, userId);

        if (profile == null)
            return NotFound(new { message = "User not found or profile is private" });

        return Ok(profile);
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\FriendshipsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\GlobalRecipesController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using StorhaugenEats.API.Services;
using StorhaugenEats.API.Helpers;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/global-recipes")]
public class GlobalRecipesController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public GlobalRecipesController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Browse global recipes with filters, search, and pagination
    /// </summary>
    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipePagedResult>> BrowseRecipes([FromQuery] BrowseGlobalRecipesQuery query)
    {
        var queryable = _context.GlobalRecipes.AsQueryable();

        // Filter: HelloFresh only
        if (query.HellofreshOnly)
        {
            queryable = queryable.Where(gr => gr.IsHellofresh);
        }

        // Filter: HelloFresh week
        if (!string.IsNullOrWhiteSpace(query.HellofreshWeek))
        {
            queryable = queryable.Where(gr => gr.HellofreshWeek == query.HellofreshWeek);
        }

        // Filter: Search by name or description
        if (!string.IsNullOrWhiteSpace(query.Search))
        {
            var searchLower = query.Search.ToLower();
            queryable = queryable.Where(gr =>
                gr.Title.ToLower().Contains(searchLower) ||
                (gr.Description != null && gr.Description.ToLower().Contains(searchLower))
            );
        }

        // Filter: Cuisine
        if (!string.IsNullOrWhiteSpace(query.Cuisine))
        {
            queryable = queryable.Where(gr => gr.Cuisine == query.Cuisine);
        }

        // Filter: Difficulty
        if (!string.IsNullOrWhiteSpace(query.Difficulty))
        {
            queryable = queryable.Where(gr => gr.Difficulty == query.Difficulty);
        }

        // Filter: Max prep time
        if (query.MaxPrepTime.HasValue)
        {
            queryable = queryable.Where(gr =>
                gr.PrepTimeMinutes.HasValue && gr.PrepTimeMinutes.Value <= query.MaxPrepTime.Value
            );
        }

        // Filter: Tags (if any tag matches)
        // Note: Tags are stored as JSON strings, so we need to filter in memory after fetching
        // TODO: Implement PostgreSQL JSONB queries for better performance
        var filterTags = query.Tags != null && query.Tags.Count > 0 ? query.Tags : null;

        // Get total count before pagination
        var totalCount = await queryable.CountAsync();

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "newest" => queryable.OrderByDescending(gr => gr.CreatedAt),
            "rating" => queryable.OrderByDescending(gr => gr.AverageRating).ThenByDescending(gr => gr.TotalRatings),
            "popular" => queryable.OrderByDescending(gr => gr.TotalTimesAdded),
            "name" => queryable.OrderBy(gr => gr.Title),
            _ => queryable.OrderByDescending(gr => gr.TotalTimesAdded) // Default: popular
        };

        // Pagination
        var recipes = await queryable
            .Include(gr => gr.CreatedByUser)
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        // Apply tag filtering in memory if needed
        if (filterTags != null)
        {
            recipes = recipes.Where(gr =>
            {
                var recipeTags = JsonHelper.JsonToList(gr.Tags);
                return filterTags.Any(tag => recipeTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)));
            }).ToList();
        }

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(new GlobalRecipePagedResult
        {
            Recipes = recipeDtos,
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        });
    }

    /// <summary>
    /// Get a specific global recipe by ID
    /// </summary>
    [HttpGet("{id}")]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipeDto>> GetRecipe(Guid id)
    {
        var recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstOrDefaultAsync(gr => gr.Id == id);

        if (recipe == null)
            return NotFound();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Search global recipes by name/description
    /// </summary>
    [HttpGet("search")]
    [AllowAnonymous]
    public async Task<ActionResult<List<GlobalRecipeDto>>> SearchRecipes(
        [FromQuery] string q,
        [FromQuery] int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(q))
            return BadRequest(new { message = "Search query is required" });

        if (limit > 100) limit = 100;

        var searchLower = q.ToLower();
        var recipes = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .Where(gr =>
                gr.Title.ToLower().Contains(searchLower) ||
                (gr.Description != null && gr.Description.ToLower().Contains(searchLower))
            )
            .OrderByDescending(gr => gr.TotalTimesAdded)
            .Take(limit)
            .ToListAsync();

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(recipeDtos);
    }

    /// <summary>
    /// Get only HelloFresh recipes
    /// </summary>
    [HttpGet("hellofresh")]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipePagedResult>> GetHelloFreshRecipes(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20,
        [FromQuery] string sortBy = "newest")
    {
        if (pageSize > 100) pageSize = 100;

        var query = _context.GlobalRecipes.Where(gr => gr.IsHellofresh);

        var totalCount = await query.CountAsync();

        // Sorting
        query = sortBy.ToLower() switch
        {
            "newest" => query.OrderByDescending(gr => gr.CreatedAt),
            "rating" => query.OrderByDescending(gr => gr.AverageRating),
            "name" => query.OrderBy(gr => gr.Title),
            _ => query.OrderByDescending(gr => gr.CreatedAt)
        };

        var recipes = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(new GlobalRecipePagedResult
        {
            Recipes = recipeDtos,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        });
    }

    /// <summary>
    /// Create a user-contributed global recipe
    /// </summary>
    [HttpPost]
    [Authorize]
    public async Task<ActionResult<GlobalRecipeDto>> CreateRecipe([FromBody] CreateGlobalRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = new GlobalRecipe
        {
            Title = dto.Name,
            Description = dto.Description,
            ImageUrl = dto.ImageUrl,
            ImageUrls = JsonHelper.ListToJson(dto.ImageUrls),
            Ingredients = JsonHelper.ObjectToJson(dto.Ingredients) ?? "[]",
            NutritionData = JsonHelper.ObjectToJson(dto.NutritionData),
            PrepTimeMinutes = dto.PrepTimeMinutes,
            CookTimeMinutes = dto.CookTimeMinutes,
            TotalTimeMinutes = (dto.PrepTimeMinutes ?? 0) + (dto.CookTimeMinutes ?? 0),
            Servings = dto.Servings,
            Difficulty = dto.Difficulty,
            Tags = JsonHelper.ListToJson(dto.Tags),
            Cuisine = dto.Cuisine,
            IsHellofresh = false,
            CreatedByUserId = userId,
            AverageRating = 0,
            TotalRatings = 0,
            TotalTimesAdded = 0,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.GlobalRecipes.Add(recipe);
        await _context.SaveChangesAsync();

        // Reload with user info
        recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstAsync(gr => gr.Id == recipe.Id);

        return CreatedAtAction(nameof(GetRecipe), new { id = recipe.Id }, MapToDto(recipe));
    }

    /// <summary>
    /// Update a user-contributed recipe (only creator can update)
    /// </summary>
    [HttpPut("{id}")]
    [Authorize]
    public async Task<ActionResult<GlobalRecipeDto>> UpdateRecipe(Guid id, [FromBody] CreateGlobalRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstOrDefaultAsync(gr => gr.Id == id);

        if (recipe == null)
            return NotFound();

        // Only creator can update
        if (recipe.CreatedByUserId != userId)
            return Forbid();

        // Can't update HelloFresh recipes
        if (recipe.IsHellofresh)
            return BadRequest(new { message = "Cannot update HelloFresh recipes" });

        recipe.Title = dto.Name;
        recipe.Description = dto.Description;
        recipe.ImageUrl = dto.ImageUrl;
        recipe.ImageUrls = JsonHelper.ListToJson(dto.ImageUrls);
        recipe.Ingredients = JsonHelper.ObjectToJson(dto.Ingredients) ?? "[]";
        recipe.NutritionData = JsonHelper.ObjectToJson(dto.NutritionData);
        recipe.PrepTimeMinutes = dto.PrepTimeMinutes;
        recipe.CookTimeMinutes = dto.CookTimeMinutes;
        recipe.TotalTimeMinutes = (dto.PrepTimeMinutes ?? 0) + (dto.CookTimeMinutes ?? 0);
        recipe.Servings = dto.Servings;
        recipe.Difficulty = dto.Difficulty;
        recipe.Tags = JsonHelper.ListToJson(dto.Tags);
        recipe.Cuisine = dto.Cuisine;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Delete a user-contributed recipe (only creator can delete)
    /// </summary>
    [HttpDelete("{id}")]
    [Authorize]
    public async Task<IActionResult> DeleteRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = await _context.GlobalRecipes.FindAsync(id);

        if (recipe == null)
            return NotFound();

        // Only creator can delete
        if (recipe.CreatedByUserId != userId)
            return Forbid();

        // Can't delete HelloFresh recipes
        if (recipe.IsHellofresh)
            return BadRequest(new { message = "Cannot delete HelloFresh recipes" });

        // Check if any users are using this recipe
        var usageCount = await _context.UserRecipes.CountAsync(ur => ur.GlobalRecipeId == id);
        if (usageCount > 0)
            return BadRequest(new { message = $"Cannot delete recipe that is used by {usageCount} user(s). They would need to detach it first." });

        _context.GlobalRecipes.Remove(recipe);
        await _context.SaveChangesAsync();

        return Ok(new { message = "Recipe deleted" });
    }

    /// <summary>
    /// Get available filter options (cuisines, difficulties, tags)
    /// </summary>
    [HttpGet("filters")]
    [AllowAnonymous]
    public async Task<IActionResult> GetFilterOptions()
    {
        var cuisines = await _context.GlobalRecipes
            .Where(gr => gr.Cuisine != null)
            .Select(gr => gr.Cuisine!)
            .Distinct()
            .OrderBy(c => c)
            .ToListAsync();

        var difficulties = await _context.GlobalRecipes
            .Where(gr => gr.Difficulty != null)
            .Select(gr => gr.Difficulty!)
            .Distinct()
            .OrderBy(d => d)
            .ToListAsync();

        // Extract tags from JSON strings (done in memory)
        var allRecipes = await _context.GlobalRecipes
            .Where(gr => gr.Tags != null && gr.Tags != "[]")
            .Select(gr => gr.Tags)
            .ToListAsync();

        var allTags = allRecipes
            .SelectMany(jsonTags => JsonHelper.JsonToList(jsonTags))
            .Distinct()
            .OrderBy(t => t)
            .ToList();

        return Ok(new
        {
            cuisines,
            difficulties,
            tags = allTags
        });
    }

    private static GlobalRecipeDto MapToDto(GlobalRecipe recipe)
    {
        return new GlobalRecipeDto
        {
            Id = recipe.Id,
            Name = recipe.Title,
            Description = recipe.Description,
            ImageUrl = recipe.ImageUrl,
            ImageUrls = JsonHelper.JsonToList(recipe.ImageUrls),
            Ingredients = JsonHelper.JsonToObject(recipe.Ingredients),
            NutritionData = JsonHelper.JsonToObject(recipe.NutritionData),
            PrepTimeMinutes = recipe.PrepTimeMinutes,
            CookTimeMinutes = recipe.CookTimeMinutes,
            TotalTimeMinutes = recipe.TotalTimeMinutes,
            Servings = recipe.Servings,
            Difficulty = recipe.Difficulty,
            Tags = JsonHelper.JsonToList(recipe.Tags),
            Cuisine = recipe.Cuisine,
            IsHellofresh = recipe.IsHellofresh,
            HellofreshUuid = recipe.HellofreshUuid,
            HellofreshSlug = recipe.HellofreshSlug,
            HellofreshWeek = recipe.HellofreshWeek,
            CreatedByUserId = recipe.CreatedByUserId,
            CreatedByUserName = recipe.CreatedByUser?.DisplayName,
            AverageRating = (double)recipe.AverageRating,
            TotalRatings = recipe.TotalRatings,
            TotalTimesAdded = recipe.TotalTimesAdded,
            CreatedAt = recipe.CreatedAt
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\GlobalRecipesController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\HelloFreshController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class HelloFreshController : ControllerBase
{
    private readonly IHelloFreshScraperService _scraperService;
    private readonly AppDbContext _context;

    public HelloFreshController(IHelloFreshScraperService scraperService, AppDbContext context)
    {
        _scraperService = scraperService;
        _context = context;
    }

    [HttpPost("sync")]
    [AllowAnonymous] // Allow unauthenticated access for testing
    public async Task<IActionResult> TriggerSync([FromQuery] bool force = false)
    {
        try
        {
            if (!force)
            {
                var shouldRun = await _scraperService.ShouldRunSyncAsync();
                if (!shouldRun)
                {
                    return Ok(new { message = "Sync not needed yet. Use ?force=true to force sync." });
                }
            }

            var (added, updated) = await _scraperService.SyncRecipesAsync();

            return Ok(new
            {
                message = "Sync completed successfully",
                recipesAdded = added,
                recipesUpdated = updated
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Sync failed", error = ex.Message });
        }
    }

    [HttpGet("test-proxy")]
    [AllowAnonymous]
    public async Task<IActionResult> TestProxy()
    {
        // The specific URL you found (Note: The ID '7.98.24323' changes when HelloFresh updates their site)
        var url = "https://www.hellofresh.no/_next/data/7.98.24323/menus/2026-W01.json?week=2026-W01";

        using var client = new HttpClient();

        // Mimic a real browser to avoid getting blocked
        client.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");

        try
        {
            var json = await client.GetStringAsync(url);
            // We return the raw JSON string to the frontend to let it handle deserialization
            return Content(json, "application/json");
        }
        catch (Exception ex)
        {
            return BadRequest(new { message = "Failed to fetch from HelloFresh", error = ex.Message });
        }
    }

    [HttpGet("sync-status")]
    [AllowAnonymous]
    public async Task<IActionResult> GetSyncStatus()
    {
        var lastSync = await _context.EtlSyncLogs
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        if (lastSync == null)
        {
            return Ok(new { message = "No sync has been performed yet" });
        }

        return Ok(new
        {
            lastSync = lastSync.StartedAt,
            status = lastSync.Status,
            recipesAdded = lastSync.RecipesAdded,
            recipesUpdated = lastSync.RecipesUpdated,
            buildId = lastSync.BuildId,
            weeksSynced = lastSync.WeeksSynced,
            errorMessage = lastSync.ErrorMessage
        });
    }

    [HttpGet("build-id")]
    [AllowAnonymous]
    public async Task<IActionResult> GetBuildId()
    {
        try
        {
            var buildId = await _scraperService.GetBuildIdAsync();
            return Ok(new { buildId });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to get build ID", error = ex.Message });
        }
    }

    [HttpGet("weeks")]
    [AllowAnonymous]
    public async Task<IActionResult> GetAvailableWeeks()
    {
        // Get distinct weeks from HelloFresh recipes, ordered descending (newest first)
        var weeks = await _context.GlobalRecipes
            .Where(gr => gr.IsHellofresh && gr.HellofreshWeek != null)
            .Select(gr => gr.HellofreshWeek!)
            .Distinct()
            .OrderByDescending(w => w)
            .ToListAsync();

        return Ok(weeks);
    }

    [HttpGet("available-weeks")]
    [AllowAnonymous]
    public IActionResult GetAvailableWeeksToFetch()
    {
        // Get weeks that can be fetched (current and upcoming weeks)
        var weeks = _scraperService.GenerateAvailableWeeks(10);
        return Ok(weeks);
    }

    [HttpPost("sync-week")]
    [AllowAnonymous]
    public async Task<IActionResult> SyncSpecificWeek([FromQuery] string week)
    {
        if (string.IsNullOrWhiteSpace(week))
        {
            return BadRequest(new { message = "Week parameter is required (e.g., 2025-W01)" });
        }

        try
        {
            var (added, updated) = await _scraperService.SyncWeekAsync(week);

            return Ok(new
            {
                message = $"Sync for week {week} completed successfully",
                week,
                recipesAdded = added,
                recipesUpdated = updated
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = $"Sync for week {week} failed", error = ex.Message });
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\HelloFreshController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\RatingsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;
using StorhaugenWebsite.Shared.DTOs;
using System.Security.Claims;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/[controller]")]
[Authorize]
public class RatingsController : ControllerBase
{
    private readonly IRatingService _ratingService;
    private readonly IUserFriendshipService _friendshipService;
    private readonly ICurrentUserService _currentUserService; // <--- 1. Add Service
    private readonly AppDbContext _context;

    public RatingsController(
        IRatingService ratingService,
        IUserFriendshipService friendshipService,
        ICurrentUserService currentUserService, // <--- 2. Inject here
        AppDbContext context)
    {
        _ratingService = ratingService;
        _friendshipService = friendshipService;
        _currentUserService = currentUserService; // <--- 3. Assign here
        _context = context;
    }

    // REMOVE THIS METHOD COMPLETELY
    // private Guid GetCurrentUserId() { ... } 

    // Public: ratings for a recipe
    [HttpGet("recipe/{globalRecipeId:guid}")]
    [AllowAnonymous]
    public async Task<IActionResult> GetRatingsForRecipe(Guid globalRecipeId)
    {
        var ratings = await _ratingService.GetRatingsForRecipeAsync(globalRecipeId);
        return Ok(ratings);
    }

    // Private: my rating for a recipe
    [HttpGet("recipe/{globalRecipeId:guid}/my-rating")]
    public async Task<IActionResult> GetMyRating(Guid globalRecipeId)
    {
        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var rating = await _ratingService.GetUserRatingForRecipeAsync(userId, globalRecipeId);
        if (rating == null)
            return NotFound();

        return Ok(rating);
    }

    // Private: upsert my rating
    [HttpPost]
    public async Task<IActionResult> UpsertRating([FromBody] UpsertRatingRequest request)
    {
        if (request.Score < 0 || request.Score > 10)
            return BadRequest(new { message = "Score must be between 0 and 10." });

        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var rating = await _ratingService.UpsertRatingAsync(
            userId,
            request.GlobalRecipeId,
            request.Score,
            request.Comment
        );

        return Ok(rating);
    }

    // Private: delete my rating
    [HttpDelete("recipe/{globalRecipeId:guid}")]
    public async Task<IActionResult> DeleteRating(Guid globalRecipeId)
    {
        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var success = await _ratingService.DeleteRatingAsync(userId, globalRecipeId);

        if (!success)
            return NotFound();

        return NoContent();
    }


    [HttpGet("user/{profileUserId:guid}")]
    public async Task<ActionResult<List<UserRatingDto>>> GetUserRatings(
    Guid profileUserId,
    [FromQuery] int skip = 0,
    [FromQuery] int take = 50)
    {
        var requestingUserId = await _currentUserService.GetOrCreateUserIdAsync();
        bool areFriends = false;

        if (requestingUserId != profileUserId)
        {
            areFriends = await _friendshipService.AreFriendsAsync(requestingUserId, profileUserId);
            if (!areFriends) return Forbid();
        }

        if (skip < 0) skip = 0;
        if (take < 1) take = 50;

        // Fetch ratings with includes
        var ratings = await _context.Ratings
            .AsNoTracking()
            .Include(r => r.GlobalRecipe)
            .Include(r => r.UserRecipe)
            .Where(r => r.UserId == profileUserId)
            .OrderByDescending(r => r.UpdatedAt)
            .Skip(skip)
            .Take(take)
            .ToListAsync();

        var result = new List<UserRatingDto>();

        foreach (var r in ratings)
        {
            // 1. Global Recipe Logic (Always visible)
            if (r.GlobalRecipe != null)
            {
                result.Add(new UserRatingDto
                {
                    GlobalRecipeId = r.GlobalRecipeId,
                    RecipeTitle = r.GlobalRecipe.Title,
                    ImageUrl = r.GlobalRecipe.ImageUrl, // Or verify ImageUrls logic
                    Score = r.Score,
                    Comment = r.Comment,
                    RatedAt = r.UpdatedAt
                });
            }
            // 2. User Recipe Logic (Check Visibility)
            else if (r.UserRecipe != null)
            {
                bool isVisible = r.UserRecipe.Visibility == "public" ||
                                 (r.UserRecipe.Visibility == "friends" && areFriends) ||
                                 requestingUserId == profileUserId; // Own profile

                if (isVisible)
                {
                    result.Add(new UserRatingDto
                    {
                        UserRecipeId = r.UserRecipeId,
                        RecipeTitle = r.UserRecipe.DisplayTitle, // Use display helper
                        ImageUrl = r.UserRecipe.DisplayImageUrls != "[]"
                            ? StorhaugenEats.API.Helpers.JsonHelper.JsonToList(r.UserRecipe.DisplayImageUrls).FirstOrDefault()
                            : null,
                        Score = r.Score,
                        Comment = r.Comment,
                        RatedAt = r.UpdatedAt
                    });
                }
            }
        }

        return Ok(result);
    }

}

public record UpsertRatingRequest(Guid GlobalRecipeId, decimal Score, string? Comment);


================================================================================
FILE END: \StorhaugenEats.API\Controllers\RatingsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\StorageController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/storage")]
[Authorize]
public class StorageController : ControllerBase
{
    private readonly IStorageService _storageService;
    private readonly ICurrentUserService _currentUserService;

    public StorageController(IStorageService storageService, ICurrentUserService currentUserService)
    {
        _storageService = storageService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Upload an image to Supabase Storage
    /// </summary>
    [HttpPost("upload")]
    public async Task<ActionResult<UploadImageResultDto>> UploadImage([FromBody] UploadImageDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Base64Data))
            return BadRequest(new { message = "Image data is required" });

        if (string.IsNullOrWhiteSpace(dto.FileName))
            return BadRequest(new { message = "File name is required" });

        // Validate file extension
        var extension = Path.GetExtension(dto.FileName).ToLowerInvariant();
        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".webp", ".gif" };

        if (!allowedExtensions.Contains(extension))
            return BadRequest(new { message = $"Invalid file type. Allowed: {string.Join(", ", allowedExtensions)}" });

        try
        {
            // Convert base64 to bytes
            var imageBytes = Convert.FromBase64String(dto.Base64Data);

            // Check file size (5MB max)
            const int maxSizeBytes = 5 * 1024 * 1024; // 5MB
            if (imageBytes.Length > maxSizeBytes)
                return BadRequest(new { message = "Image size must be less than 5MB" });

            // Generate unique filename
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var uniqueFileName = $"{userId}_{Guid.NewGuid()}{extension}";

            // Upload to storage
            using var imageStream = new MemoryStream(imageBytes);
            var url = await _storageService.UploadImageAsync(imageStream, uniqueFileName, dto.Bucket ?? "recipe-images");

            return Ok(new UploadImageResultDto
            {
                Url = url,
                FileName = uniqueFileName
            });
        }
        catch (FormatException)
        {
            return BadRequest(new { message = "Invalid base64 image data" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to upload image", error = ex.Message });
        }
    }

    /// <summary>
    /// Delete an image from Supabase Storage
    /// </summary>
    [HttpDelete("{fileName}")]
    public async Task<IActionResult> DeleteImage(string fileName, [FromQuery] string bucket = "recipe-images")
    {
        if (string.IsNullOrWhiteSpace(fileName))
            return BadRequest(new { message = "File name is required" });

        try
        {
            // Extract user ID from filename (format: {userId}_{guid}.ext)
            var parts = fileName.Split('_');
            if (parts.Length < 2 || !Guid.TryParse(parts[0], out var fileUserId))
                return BadRequest(new { message = "Invalid file name format" });

            // Verify user owns the file
            var currentUserId = await _currentUserService.GetOrCreateUserIdAsync();
            if (fileUserId != currentUserId)
                return Forbid();

            // DeleteImageAsync expects a URL, so we need to construct it
            // For now, just pass the fileName as the URL (storage service will handle it)
            await _storageService.DeleteImageAsync(fileName);

            return Ok(new { message = "Image deleted successfully" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to delete image", error = ex.Message });
        }
    }

    /// <summary>
    /// Get a signed URL for uploading directly to storage (for large files)
    /// </summary>
    [HttpPost("upload-url")]
    public async Task<IActionResult> GetUploadUrl([FromBody] GetUploadUrlDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var uniqueFileName = $"{userId}_{Guid.NewGuid()}{Path.GetExtension(dto.FileName)}";

        // In a full implementation, you'd generate a signed URL from Supabase Storage
        // For now, return the file name that should be used
        return Ok(new
        {
            fileName = uniqueFileName,
            message = "Use POST /api/storage/upload endpoint for file upload"
        });
    }
}

public record GetUploadUrlDto(string FileName);


================================================================================
FILE END: \StorhaugenEats.API\Controllers\StorageController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\TagsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

/// <summary>
/// Controller for managing personal recipe tags/categories.
/// Tags are used for personal organization and are private to each user.
/// </summary>
[ApiController]
[Route("api/tags")]
[Authorize]
public class TagsController : ControllerBase
{
    private readonly ITagService _tagService;
    private readonly ICurrentUserService _currentUserService;

    public TagsController(ITagService tagService, ICurrentUserService currentUserService)
    {
        _tagService = tagService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all tags for the current user.
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<List<TagDto>>> GetMyTags()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var tags = await _tagService.GetUserTagsAsync(userId);
        return Ok(tags);
    }

    /// <summary>
    /// Get a specific tag by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<TagDto>> GetTag(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var tag = await _tagService.GetTagAsync(id, userId);

        if (tag == null)
            return NotFound(new { message = "Tag not found" });

        return Ok(tag);
    }

    /// <summary>
    /// Create a new tag.
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<TagDto>> CreateTag([FromBody] CreateTagDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tag = await _tagService.CreateTagAsync(userId, dto);
            return CreatedAtAction(nameof(GetTag), new { id = tag.Id }, tag);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Update a tag.
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<TagDto>> UpdateTag(Guid id, [FromBody] UpdateTagDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tag = await _tagService.UpdateTagAsync(id, userId, dto);
            return Ok(tag);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Delete a tag.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> DeleteTag(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.DeleteTagAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    // ==========================================
    // RECIPE-TAG MANAGEMENT
    // ==========================================

    /// <summary>
    /// Get tags for a specific recipe.
    /// </summary>
    [HttpGet("recipe/{recipeId}")]
    public async Task<ActionResult<List<TagReferenceDto>>> GetRecipeTags(Guid recipeId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tags = await _tagService.GetRecipeTagsAsync(recipeId, userId);
            return Ok(tags);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Set tags for a recipe (replaces existing tags).
    /// </summary>
    [HttpPut("recipe/{recipeId}")]
    public async Task<ActionResult> SetRecipeTags(Guid recipeId, [FromBody] UpdateRecipeTagsDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.SetRecipeTagsAsync(recipeId, userId, dto.TagIds);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Add a tag to a recipe.
    /// </summary>
    [HttpPost("recipe/{recipeId}/tag/{tagId}")]
    public async Task<ActionResult> AddTagToRecipe(Guid recipeId, Guid tagId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.AddTagToRecipeAsync(recipeId, tagId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a tag from a recipe.
    /// </summary>
    [HttpDelete("recipe/{recipeId}/tag/{tagId}")]
    public async Task<ActionResult> RemoveTagFromRecipe(Guid recipeId, Guid tagId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.RemoveTagFromRecipeAsync(recipeId, tagId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\TagsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\UserRecipesController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/user-recipes")]
[Authorize]
public class UserRecipesController : ControllerBase
{
    private readonly IUserRecipeService _userRecipeService;
    private readonly ICurrentUserService _currentUserService;

    public UserRecipesController(
        IUserRecipeService userRecipeService,
        ICurrentUserService currentUserService)
    {
        _userRecipeService = userRecipeService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all recipes for the current user.
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<UserRecipePagedResult>> GetMyRecipes([FromQuery] GetUserRecipesQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _userRecipeService.GetUserRecipesAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get recipes from friends that are visible to the current user.
    /// </summary>
    [HttpGet("friends")]
    public async Task<ActionResult<UserRecipePagedResult>> GetFriendsRecipes([FromQuery] GetUserRecipesQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _userRecipeService.GetFriendsRecipesAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get a specific recipe by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserRecipeDto>> GetRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var recipe = await _userRecipeService.GetRecipeAsync(id, userId);

        if (recipe == null)
            return NotFound(new { message = "Recipe not found or you don't have permission to view it" });

        return Ok(recipe);
    }

    /// <summary>
    /// Create a new recipe.
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<UserRecipeDto>> CreateRecipe([FromBody] CreateUserRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.CreateRecipeAsync(userId, dto);
            return CreatedAtAction(nameof(GetRecipe), new { id = recipe.Id }, recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Update a recipe.
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<UserRecipeDto>> UpdateRecipe(Guid id, [FromBody] UpdateUserRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.UpdateRecipeAsync(id, userId, dto);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Delete a recipe.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> DeleteRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _userRecipeService.DeleteRecipeAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Publish a local recipe to the global recipe catalog.
    /// </summary>
    [HttpPost("{id}/publish")]
    public async Task<ActionResult<PublishRecipeResultDto>> PublishRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.PublishRecipeAsync(id, userId);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Detach a recipe from its linked global recipe (hard fork).
    /// </summary>
    [HttpPost("{id}/detach")]
    public async Task<ActionResult<UserRecipeDto>> DetachRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.DetachRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Rate a recipe.
    /// </summary>
    [HttpPost("{id}/rate")]
    public async Task<ActionResult<UserRecipeDto>> RateRecipe(Guid id, [FromBody] RateRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.RateRecipeAsync(id, userId, dto.Rating, dto.Comment);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove rating from a recipe.
    /// </summary>
    [HttpDelete("{id}/rate")]
    public async Task<ActionResult> RemoveRating(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _userRecipeService.RemoveRatingAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Archive a recipe.
    /// </summary>
    [HttpPost("{id}/archive")]
    public async Task<ActionResult<UserRecipeDto>> ArchiveRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.ArchiveRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Restore an archived recipe.
    /// </summary>
    [HttpPost("{id}/restore")]
    public async Task<ActionResult<UserRecipeDto>> RestoreRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.RestoreRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

}

/// <summary>
/// DTO for rating a recipe.
/// </summary>
public class RateRecipeDto
{
    public decimal Rating { get; set; }
    public string? Comment { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\UserRecipesController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\UsersController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/users")]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public UsersController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get current user's profile
    /// </summary>
    [HttpGet("me")]
    public async Task<ActionResult<UserDto>> GetMyProfile()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user == null)
            return NotFound();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Update current user's profile
    /// </summary>
    [HttpPut("me")]
    public async Task<ActionResult<UserDto>> UpdateMyProfile([FromBody] UpdateUserDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user == null)
            return NotFound();

        if (dto.DisplayName != null)
            user.DisplayName = dto.DisplayName;

        if (dto.AvatarUrl != null)
            user.AvatarUrl = dto.AvatarUrl;

        user.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Get a user's public profile (for collection members or friends)
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserDto>> GetUserProfile(Guid id)
    {
        var currentUserId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(id);

        if (user == null)
            return NotFound();

        // Allow if same user
        if (currentUserId == id)
        {
            return Ok(new UserDto
            {
                Id = user.Id,
                Email = user.Email,
                DisplayName = user.DisplayName,
                AvatarUrl = user.AvatarUrl,
                UniqueShareId = user.UniqueShareId,
                CreatedAt = user.CreatedAt
            });
        }

        // Check if current user shares a collection with this user
        var sharedCollection = await _context.CollectionMembers
            .Where(cm => cm.UserId == currentUserId)
            .Select(cm => cm.CollectionId)
            .Intersect(
                _context.CollectionMembers
                    .Where(cm => cm.UserId == id)
                    .Select(cm => cm.CollectionId)
            )
            .AnyAsync();

        if (!sharedCollection)
            return Forbid();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Trigger HelloFresh ETL sync (checks 24-hour limit)
    /// </summary>
    [HttpPost("trigger-hellofresh-sync")]
    [AllowAnonymous] // Called on login, before auth
    public async Task<IActionResult> TriggerHelloFreshSync()
    {
        // Check last sync time from etl_sync_log
        var lastSync = await _context.EtlSyncLogs
            .Where(log => log.Status == "success")
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        var shouldSync = lastSync == null || (DateTime.UtcNow - lastSync.StartedAt).TotalHours > 24;

        if (!shouldSync)
        {
            return Ok(new
            {
                message = "HelloFresh sync not needed yet",
                lastSync = lastSync?.StartedAt,
                nextSync = lastSync?.StartedAt.AddHours(24)
            });
        }

        // Return a message to trigger sync via the HelloFresh controller
        return Ok(new
        {
            message = "HelloFresh sync is due",
            shouldSync = true,
            lastSync = lastSync?.StartedAt
        });

        // Note: Actual sync should be triggered via POST /api/HelloFresh/sync
        // This endpoint just checks if sync is needed
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\UsersController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Data\AppDbContext.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Data;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
    {
    }

    // Core entities
    public DbSet<User> Users { get; set; }
    public DbSet<GlobalRecipe> GlobalRecipes { get; set; }
    public DbSet<Rating> Ratings { get; set; }
    public DbSet<EtlSyncLog> EtlSyncLogs { get; set; }

    // User-centric entities
    public DbSet<UserRecipe> UserRecipes { get; set; }
    public DbSet<UserFriendship> UserFriendships { get; set; }
    public DbSet<ActivityFeedItem> ActivityFeedItems { get; set; }

    // Tags for personal recipe organization
    public DbSet<RecipeTag> RecipeTags { get; set; }
    public DbSet<UserRecipeTag> UserRecipeTags { get; set; }

    // Collections for recipe sharing
    public DbSet<Collection> Collections { get; set; }
    public DbSet<CollectionMember> CollectionMembers { get; set; }
    public DbSet<UserRecipeCollection> UserRecipeCollections { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure table names
        modelBuilder.Entity<User>().ToTable("users");
        modelBuilder.Entity<GlobalRecipe>().ToTable("global_recipes");
        modelBuilder.Entity<Rating>().ToTable("ratings");
        modelBuilder.Entity<EtlSyncLog>().ToTable("etl_sync_log");
        modelBuilder.Entity<UserRecipe>().ToTable("user_recipes");
        modelBuilder.Entity<UserFriendship>().ToTable("user_friendships");
        modelBuilder.Entity<ActivityFeedItem>().ToTable("activity_feed");
        modelBuilder.Entity<RecipeTag>().ToTable("recipe_tags");
        modelBuilder.Entity<UserRecipeTag>().ToTable("user_recipe_tags");
        modelBuilder.Entity<Collection>().ToTable("collections");
        modelBuilder.Entity<CollectionMember>().ToTable("collection_members");
        modelBuilder.Entity<UserRecipeCollection>().ToTable("user_recipe_collections");

        // ==========================================
        // USER CONFIGURATION
        // ==========================================
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.DisplayName).IsRequired().HasMaxLength(255);
            entity.Property(e => e.UniqueShareId).IsRequired().HasMaxLength(12);
            entity.Property(e => e.IsProfilePublic).HasDefaultValue(true);
            entity.Property(e => e.Bio).HasMaxLength(500);
            entity.Property(e => e.FavoriteCuisines).HasColumnType("jsonb").HasDefaultValue("[]");

            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.UniqueShareId).IsUnique();
        });

        // ==========================================
        // GLOBAL RECIPE CONFIGURATION
        // ==========================================
        modelBuilder.Entity<GlobalRecipe>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).IsRequired().HasMaxLength(255);
            entity.Property(e => e.Ingredients).HasColumnType("jsonb").IsRequired().HasDefaultValue("[]");
            entity.Property(e => e.NutritionData).HasColumnType("jsonb");
            entity.Property(e => e.AverageRating).HasColumnType("decimal(3,2)").HasDefaultValue(0.00m);
            entity.Property(e => e.RatingCount).HasDefaultValue(0);
            entity.Property(e => e.HellofreshUuid).HasMaxLength(255);
            entity.Property(e => e.IsEditable).HasDefaultValue(true);

            entity.HasIndex(e => e.IsHellofresh).HasFilter("is_hellofresh = true");
            entity.HasIndex(e => e.IsPublic).HasFilter("is_public = true");
            entity.HasIndex(e => e.AverageRating);
            entity.HasIndex(e => e.HellofreshUuid).IsUnique();

            entity.HasOne(e => e.CreatedByUser)
                .WithMany()
                .HasForeignKey(e => e.CreatedByUserId)
                .OnDelete(DeleteBehavior.SetNull);

            entity.HasOne(e => e.PublishedFromUserRecipe)
                .WithMany()
                .HasForeignKey(e => e.PublishedFromUserRecipeId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // ==========================================
        // RATING CONFIGURATION
        // ==========================================
        modelBuilder.Entity<Rating>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Score).IsRequired();
            entity.ToTable(t => t.HasCheckConstraint("CK_Rating_Score", "score >= 0 AND score <= 10"));

            // Unique constraint: one rating per user per recipe
            entity.HasIndex(e => new { e.GlobalRecipeId, e.UserId }).IsUnique();

            entity.HasOne(e => e.GlobalRecipe)
                .WithMany(r => r.Ratings)
                .HasForeignKey(e => e.GlobalRecipeId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.UserRecipe)
                .WithMany(r => r.Ratings)
                .HasForeignKey(e => e.UserRecipeId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // ==========================================
        // ETL SYNC LOG CONFIGURATION
        // ==========================================
        modelBuilder.Entity<EtlSyncLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.SyncType).HasMaxLength(50).HasDefaultValue("hellofresh");
            entity.Property(e => e.Status).HasMaxLength(20);
            entity.Property(e => e.RecipesAdded).HasDefaultValue(0);
            entity.Property(e => e.RecipesUpdated).HasDefaultValue(0);
            entity.Property(e => e.BuildId).HasMaxLength(255);
            entity.Property(e => e.WeeksSynced).HasMaxLength(255);

            entity.HasIndex(e => e.StartedAt);
        });

        // ==========================================
        // USER RECIPE CONFIGURATION
        // ==========================================
        modelBuilder.Entity<UserRecipe>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.LocalTitle).HasMaxLength(255);
            entity.Property(e => e.LocalIngredients).HasColumnType("jsonb");
            entity.Property(e => e.LocalImageUrls).HasColumnType("jsonb").HasDefaultValue("[]");
            entity.Property(e => e.Visibility).IsRequired().HasMaxLength(20).HasDefaultValue("private");
            entity.Property(e => e.IsArchived).HasDefaultValue(false);

            entity.HasIndex(e => e.UserId);
            entity.HasIndex(e => e.GlobalRecipeId);
            entity.HasIndex(e => e.Visibility);
            entity.HasIndex(e => e.CreatedAt);

            entity.HasOne(e => e.User)
                .WithMany(u => u.UserRecipes)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.GlobalRecipe)
                .WithMany()
                .HasForeignKey(e => e.GlobalRecipeId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // ==========================================
        // USER FRIENDSHIP CONFIGURATION
        // ==========================================
        modelBuilder.Entity<UserFriendship>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(20).HasDefaultValue("pending");
            entity.Property(e => e.Message).HasMaxLength(255);

            entity.HasIndex(e => new { e.RequesterUserId, e.TargetUserId }).IsUnique();
            entity.HasIndex(e => e.RequesterUserId);
            entity.HasIndex(e => e.TargetUserId);
            entity.HasIndex(e => e.Status);

            entity.ToTable(t => t.HasCheckConstraint("CK_UserFriendship_NoSelf", "requester_user_id != target_user_id"));

            entity.HasOne(e => e.RequesterUser)
                .WithMany(u => u.SentFriendRequests)
                .HasForeignKey(e => e.RequesterUserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.TargetUser)
                .WithMany(u => u.ReceivedFriendRequests)
                .HasForeignKey(e => e.TargetUserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // ==========================================
        // ACTIVITY FEED CONFIGURATION
        // ==========================================
        modelBuilder.Entity<ActivityFeedItem>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.ActivityType).IsRequired().HasMaxLength(50);
            entity.Property(e => e.TargetType).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Metadata).HasColumnType("jsonb").HasDefaultValue("{}");

            entity.HasIndex(e => e.UserId);
            entity.HasIndex(e => e.CreatedAt).IsDescending();
            entity.HasIndex(e => e.ActivityType);
            entity.HasIndex(e => new { e.UserId, e.CreatedAt });

            entity.HasOne(e => e.User)
                .WithMany(u => u.Activities)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // ==========================================
        // RECIPE TAGS CONFIGURATION
        // ==========================================
        modelBuilder.Entity<RecipeTag>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Color).HasMaxLength(7);
            entity.Property(e => e.Icon).HasMaxLength(50);

            entity.HasIndex(e => new { e.UserId, e.Name }).IsUnique();
            entity.HasIndex(e => e.UserId);

            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        modelBuilder.Entity<UserRecipeTag>(entity =>
        {
            entity.HasKey(e => e.Id);

            entity.HasIndex(e => new { e.UserRecipeId, e.TagId }).IsUnique();

            entity.HasOne(e => e.UserRecipe)
                .WithMany(r => r.UserRecipeTags)
                .HasForeignKey(e => e.UserRecipeId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.Tag)
                .WithMany(t => t.UserRecipeTags)
                .HasForeignKey(e => e.TagId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // ==========================================
        // COLLECTIONS CONFIGURATION
        // ==========================================
        modelBuilder.Entity<Collection>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(100);
            entity.Property(e => e.Description).HasMaxLength(500);
            entity.Property(e => e.Color).HasMaxLength(7);
            entity.Property(e => e.Icon).HasMaxLength(50);
            entity.Property(e => e.UniqueShareId).HasMaxLength(12);
            entity.Property(e => e.IsDefault).HasDefaultValue(false);
            entity.Property(e => e.IsShared).HasDefaultValue(false);
            entity.Property(e => e.SortOrder).HasDefaultValue(0);

            entity.HasIndex(e => e.OwnerUserId);
            entity.HasIndex(e => e.UniqueShareId).IsUnique();

            entity.HasOne(e => e.Owner)
                .WithMany(u => u.OwnedCollections)
                .HasForeignKey(e => e.OwnerUserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // CollectionMember with id primary key
        modelBuilder.Entity<CollectionMember>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Role).IsRequired().HasMaxLength(20).HasDefaultValue("member");

            entity.HasIndex(e => e.UserId);
            entity.HasIndex(e => e.CollectionId);
            entity.HasIndex(e => new { e.CollectionId, e.UserId }).IsUnique();

            entity.HasOne(e => e.Collection)
                .WithMany(c => c.Members)
                .HasForeignKey(e => e.CollectionId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany(u => u.CollectionMemberships)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.InvitedByUser)
                .WithMany()
                .HasForeignKey(e => e.InvitedByUserId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // UserRecipeCollection with id primary key
        modelBuilder.Entity<UserRecipeCollection>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Notes).HasMaxLength(500);
            entity.Property(e => e.SortOrder).HasDefaultValue(0);

            entity.HasIndex(e => e.CollectionId);
            entity.HasIndex(e => e.UserRecipeId);
            entity.HasIndex(e => new { e.UserRecipeId, e.CollectionId }).IsUnique();
            entity.HasIndex(e => new { e.CollectionId, e.SortOrder });

            // Deleting a collection deletes only the link rows, not the recipes
            entity.HasOne(e => e.Collection)
                .WithMany(c => c.UserRecipeCollections)
                .HasForeignKey(e => e.CollectionId)
                .OnDelete(DeleteBehavior.Cascade);

            // Deleting a recipe deletes only the link rows
            entity.HasOne(e => e.UserRecipe)
                .WithMany(r => r.UserRecipeCollections)
                .HasForeignKey(e => e.UserRecipeId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.AddedByUser)
                .WithMany()
                .HasForeignKey(e => e.AddedByUserId)
                .OnDelete(DeleteBehavior.Restrict);
        });
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Data\AppDbContext.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Helpers\JsonHelper.cs
================================================================================
using System.Text.Json;

namespace StorhaugenEats.API.Helpers;

public static class JsonHelper
{
    /// <summary>
    /// Converts a JSON string to a List of strings
    /// </summary>
    public static List<string> JsonToList(string? json)
    {
        if (string.IsNullOrWhiteSpace(json) || json == "[]")
        {
            return new List<string>();
        }

        try
        {
            return JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>();
        }
        catch
        {
            return new List<string>();
        }
    }

    /// <summary>
    /// Converts a List of strings to a JSON string
    /// </summary>
    public static string ListToJson(List<string>? list)
    {
        if (list == null || list.Count == 0)
        {
            return "[]";
        }

        return JsonSerializer.Serialize(list);
    }

    /// <summary>
    /// Safely gets a string from a nullable value, returns empty string if null
    /// </summary>
    public static string SafeString(string? value)
    {
        return value ?? string.Empty;
    }

    /// <summary>
    /// Converts an object to a JSON string, returns null if object is null
    /// </summary>
    public static string? ObjectToJson(object? obj)
    {
        if (obj == null)
        {
            return null;
        }

        try
        {
            return JsonSerializer.Serialize(obj);
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Converts a JSON string to an object, returns null if string is null or invalid
    /// </summary>
    public static object? JsonToObject(string? json)
    {
        if (string.IsNullOrWhiteSpace(json))
        {
            return null;
        }

        try
        {
            return JsonSerializer.Deserialize<object>(json);
        }
        catch
        {
            return null;
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Helpers\JsonHelper.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\ActivityFeedItem.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents an activity item in the social feed.
/// Activities are denormalized for fast query performance.
/// </summary>
[Table("activity_feed")]
public class ActivityFeedItem
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who performed the activity.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Type of activity: 'rated', 'added', 'published'
    /// </summary>
    [Required]
    [Column("activity_type")]
    [MaxLength(50)]
    public string ActivityType { get; set; } = string.Empty;

    /// <summary>
    /// Type of target entity: 'user_recipe', 'global_recipe'
    /// </summary>
    [Required]
    [Column("target_type")]
    [MaxLength(50)]
    public string TargetType { get; set; } = string.Empty;

    /// <summary>
    /// ID of the target entity.
    /// </summary>
    [Required]
    [Column("target_id")]
    public Guid TargetId { get; set; }

    /// <summary>
    /// Additional metadata as JSON (recipe name, rating score, etc.)
    /// Example: { "recipeName": "Spaghetti", "rating": 8, "imageUrl": "..." }
    /// </summary>
    [Column("metadata", TypeName = "jsonb")]
    public string Metadata { get; set; } = "{}";

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;

    // Static factory methods for creating activities
    public static ActivityFeedItem CreateRatingActivity(Guid userId, Guid recipeId, string recipeName, decimal rating, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["rating"] = rating,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "rated",
            TargetType = "user_recipe",
            TargetId = recipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }

    public static ActivityFeedItem CreateAddedRecipeActivity(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "added",
            TargetType = "user_recipe",
            TargetId = recipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }

    public static ActivityFeedItem CreatePublishedActivity(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "published",
            TargetType = "global_recipe",
            TargetId = globalRecipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\ActivityFeedItem.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\Collection.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// A collection of recipes that can be shared with other users.
/// Replaces the household-centric model.
/// </summary>
[Table("collections")]
public class Collection
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who owns this collection.
    /// </summary>
    [Required]
    [Column("owner_user_id")]
    public Guid OwnerUserId { get; set; }

    [Required]
    [Column("name")]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Optional description of the collection.
    /// </summary>
    [Column("description")]
    [MaxLength(500)]
    public string? Description { get; set; }

    [Column("image_url")]
    public string? ImageUrl { get; set; }

    [Column("color")]
    [MaxLength(7)]
    public string? Color { get; set; }

    [Column("icon")]
    [MaxLength(50)]
    public string? Icon { get; set; }

    [Column("is_default")]
    public bool IsDefault { get; set; } = false;

    [Column("is_shared")]
    public bool IsShared { get; set; } = false;

    /// <summary>
    /// Visibility: "private", "friends", or "public"
    /// </summary>
    [Column("visibility")]
    [MaxLength(20)]
    public string Visibility { get; set; } = "private";

    /// <summary>
    /// Unique share code for shared collections
    /// </summary>
    [Column("unique_share_id")]
    [MaxLength(12)]
    public string? UniqueShareId { get; set; }

    [Column("sort_order")]
    public int SortOrder { get; set; } = 0;

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User Owner { get; set; } = null!;
    public ICollection<CollectionMember> Members { get; set; } = new List<CollectionMember>();
    public ICollection<UserRecipeCollection> UserRecipeCollections { get; set; } = new List<UserRecipeCollection>();
}


================================================================================
FILE END: \StorhaugenEats.API\Models\Collection.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\CollectionMember.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a member of a collection. The owner is always a member with Role="owner".
/// </summary>
[Table("collection_members")]
public class CollectionMember
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("collection_id")]
    public Guid CollectionId { get; set; }

    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Role of the member: "owner" or "member"
    /// </summary>
    [Required]
    [Column("role")]
    [MaxLength(20)]
    public string Role { get; set; } = "member";

    [Column("joined_at")]
    public DateTime JoinedAt { get; set; } = DateTime.UtcNow;

    [Column("invited_by_user_id")]
    public Guid? InvitedByUserId { get; set; }

    // Navigation properties
    public Collection Collection { get; set; } = null!;
    public User User { get; set; } = null!;
    public User? InvitedByUser { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\CollectionMember.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\EtlSyncLog.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("etl_sync_log")]
public class EtlSyncLog
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Column("sync_type")]
    [MaxLength(50)]
    public string SyncType { get; set; } = "hellofresh";

    [Column("status")]
    [MaxLength(20)]
    public string? Status { get; set; } // "success", "failed", "partial"

    [Column("recipes_added")]
    public int RecipesAdded { get; set; } = 0;

    [Column("recipes_updated")]
    public int RecipesUpdated { get; set; } = 0;

    [Column("error_message")]
    public string? ErrorMessage { get; set; }

    [Column("build_id")]
    [MaxLength(255)]
    public string? BuildId { get; set; }

    [Column("weeks_synced")]
    [MaxLength(255)]
    public string? WeeksSynced { get; set; }

    [Column("started_at")]
    public DateTime StartedAt { get; set; } = DateTime.UtcNow;

    [Column("completed_at")]
    public DateTime? CompletedAt { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\EtlSyncLog.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\GlobalRecipe.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("global_recipes")]
public class GlobalRecipe
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("title")]
    [MaxLength(255)]
    public string Title { get; set; } = string.Empty;

    [Column("description")]
    public string? Description { get; set; }

    [Column("image_url")]
    public string? ImageUrl { get; set; }

    [Required]
    [Column("ingredients", TypeName = "jsonb")]
    public string Ingredients { get; set; } = "[]";

    [Column("nutrition_data", TypeName = "jsonb")]
    public string? NutritionData { get; set; }

    [Column("cook_time_minutes")]
    public int? CookTimeMinutes { get; set; }

    [Column("difficulty")]
    [MaxLength(50)]
    public string? Difficulty { get; set; }

    // Source tracking
    [Column("is_hellofresh")]
    public bool IsHellofresh { get; set; } = false;

    [Column("hellofresh_uuid")]
    [MaxLength(255)]
    public string? HellofreshUuid { get; set; }

    [Column("created_by_user_id")]
    public Guid? CreatedByUserId { get; set; }

    // Visibility
    [Column("is_public")]
    public bool IsPublic { get; set; } = false;

    // Aggregated ratings
    [Column("average_rating")]
    public decimal AverageRating { get; set; } = 0.00m;

    [Column("rating_count")]
    public int RatingCount { get; set; } = 0;

    [Column("tags", TypeName = "jsonb")]
    public string Tags { get; set; } = "[]";

    [Column("cuisine")]
    [MaxLength(100)]
    public string? Cuisine { get; set; }

    [Column("servings")]
    public int? Servings { get; set; }

    [Column("prep_time_minutes")]
    public int? PrepTimeMinutes { get; set; }

    [Column("total_time_minutes")]
    public int? TotalTimeMinutes { get; set; }

    [Column("hellofresh_slug")]
    [MaxLength(255)]
    public string? HellofreshSlug { get; set; }

    /// <summary>
    /// The week this HelloFresh recipe was available (e.g., "2026-W02")
    /// </summary>
    [Column("hellofresh_week")]
    [MaxLength(20)]
    public string? HellofreshWeek { get; set; }

    [Column("total_ratings")]
    public int TotalRatings { get; set; } = 0;

    [Column("total_times_added")]
    public int TotalTimesAdded { get; set; } = 0;

    [Column("image_urls", TypeName = "jsonb")]
    public string ImageUrls { get; set; } = "[]";

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Publishing-related fields
    /// <summary>
    /// Reference to the original UserRecipe this was published from (if any).
    /// </summary>
    [Column("published_from_user_recipe_id")]
    public Guid? PublishedFromUserRecipeId { get; set; }

    /// <summary>
    /// Whether this recipe can be edited. HelloFresh recipes are not editable.
    /// </summary>
    [Column("is_editable")]
    public bool IsEditable { get; set; } = true;

    // Navigation properties
    public User? CreatedByUser { get; set; }
    public UserRecipe? PublishedFromUserRecipe { get; set; }
    public ICollection<Rating> Ratings { get; set; } = new List<Rating>();

    // Backward compatibility properties
    [NotMapped]
    public string Name
    {
        get => Title;
        set => Title = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\GlobalRecipe.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\Rating.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("ratings")]
public class Rating
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Column("global_recipe_id")]
    public Guid? GlobalRecipeId { get; set; }

    /// <summary>
    /// Reference to the user recipe being rated (new user-centric model).
    /// </summary>
    [Column("user_recipe_id")]
    public Guid? UserRecipeId { get; set; }

    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    [Required]
    [Column("score")]
    [Range(0, 10)]
    public decimal Score { get; set; }

    [Column("comment")]
    public string? Comment { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public GlobalRecipe? GlobalRecipe { get; set; }
    public UserRecipe? UserRecipe { get; set; }
    public User User { get; set; } = null!;

    // Backward compatibility properties
    [NotMapped]
    public decimal RatingValue
    {
        get => Score;
        set => Score = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\Rating.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\RecipeTag.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a personal tag/category for organizing recipes.
/// Tags are user-owned and only visible to the owner.
/// Examples: "Kylling", "Rask middag", "Grill", "Søndag"
/// </summary>
[Table("recipe_tags")]
public class RecipeTag
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who owns this tag.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// The tag name (e.g., "Kylling", "Rask")
    /// </summary>
    [Required]
    [Column("name")]
    [MaxLength(50)]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Optional color for visual distinction (hex code).
    /// </summary>
    [Column("color")]
    [MaxLength(7)]
    public string? Color { get; set; }

    /// <summary>
    /// Optional icon name (Material Icons).
    /// </summary>
    [Column("icon")]
    [MaxLength(50)]
    public string? Icon { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public ICollection<UserRecipeTag> UserRecipeTags { get; set; } = new List<UserRecipeTag>();
}

/// <summary>
/// Join table linking UserRecipes to RecipeTags.
/// Allows a recipe to have multiple tags and a tag to be applied to multiple recipes.
/// </summary>
[Table("user_recipe_tags")]
public class UserRecipeTag
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("user_recipe_id")]
    public Guid UserRecipeId { get; set; }

    [Required]
    [Column("tag_id")]
    public Guid TagId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public UserRecipe UserRecipe { get; set; } = null!;
    public RecipeTag Tag { get; set; } = null!;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\RecipeTag.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\User.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("users")]
public class User
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("email")]
    [MaxLength(255)]
    public string Email { get; set; } = string.Empty;

    [Required]
    [Column("display_name")]
    [MaxLength(255)]
    public string DisplayName { get; set; } = string.Empty;

    [Column("avatar_url")]
    public string? AvatarUrl { get; set; }

    [Required]
    [Column("unique_share_id")]
    [MaxLength(12)]
    public string UniqueShareId { get; set; } = string.Empty;

    [Column("supabase_user_id")]
    [MaxLength(255)]
    public string? SupabaseUserId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // User-centric social features
    [Column("is_profile_public")]
    public bool IsProfilePublic { get; set; } = true;

    [Column("bio")]
    [MaxLength(500)]
    public string? Bio { get; set; }

    [Column("favorite_cuisines", TypeName = "jsonb")]
    public string FavoriteCuisines { get; set; } = "[]";

    // Navigation properties
    public ICollection<UserRecipe> UserRecipes { get; set; } = new List<UserRecipe>();
    public ICollection<UserFriendship> SentFriendRequests { get; set; } = new List<UserFriendship>();
    public ICollection<UserFriendship> ReceivedFriendRequests { get; set; } = new List<UserFriendship>();
    public ICollection<ActivityFeedItem> Activities { get; set; } = new List<ActivityFeedItem>();
    public ICollection<Collection> OwnedCollections { get; set; } = new List<Collection>();
    public ICollection<CollectionMember> CollectionMemberships { get; set; } = new List<CollectionMember>();

    // Backward compatibility properties
    [NotMapped]
    public Guid UserId => Id;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\User.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\UserFriendship.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a friendship connection between two users.
/// This enables the social features of the app - users can see what their friends
/// are cooking and rating.
/// </summary>
[Table("user_friendships")]
public class UserFriendship
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who initiated the friend request.
    /// </summary>
    [Required]
    [Column("requester_user_id")]
    public Guid RequesterUserId { get; set; }

    /// <summary>
    /// The user who received the friend request.
    /// </summary>
    [Required]
    [Column("target_user_id")]
    public Guid TargetUserId { get; set; }

    /// <summary>
    /// Status of the friendship: 'pending', 'accepted', 'rejected', 'blocked'
    /// </summary>
    [Required]
    [Column("status")]
    [MaxLength(20)]
    public string Status { get; set; } = "pending";

    /// <summary>
    /// Optional message sent with the friend request.
    /// </summary>
    [Column("message")]
    [MaxLength(255)]
    public string? Message { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("responded_at")]
    public DateTime? RespondedAt { get; set; }

    // Navigation properties
    public User RequesterUser { get; set; } = null!;
    public User TargetUser { get; set; } = null!;

    // Helper properties
    [NotMapped]
    public bool IsPending => Status == "pending";

    [NotMapped]
    public bool IsAccepted => Status == "accepted";

    /// <summary>
    /// Gets the "other" user from the perspective of the given user ID.
    /// </summary>
    public User? GetOtherUser(Guid currentUserId)
    {
        if (currentUserId == RequesterUserId)
            return TargetUser;
        if (currentUserId == TargetUserId)
            return RequesterUser;
        return null;
    }

    /// <summary>
    /// Gets the ID of the "other" user from the perspective of the given user ID.
    /// </summary>
    public Guid GetOtherUserId(Guid currentUserId)
    {
        return currentUserId == RequesterUserId ? TargetUserId : RequesterUserId;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\UserFriendship.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\UserRecipe.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a recipe owned by a user. This is the new user-centric model that replaces
/// the household-centric HouseholdRecipe. Users own their recipes directly, and households
/// see an aggregated view of their members' recipes.
/// </summary>
[Table("user_recipes")]
public class UserRecipe
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who owns this recipe.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Optional link to a global recipe. When set, this recipe references the global recipe.
    /// When null, the recipe uses local data only.
    /// </summary>
    [Column("global_recipe_id")]
    public Guid? GlobalRecipeId { get; set; }

    // Local recipe data (used when not linked or when user has customizations)
    [Column("local_title")]
    [MaxLength(255)]
    public string? LocalTitle { get; set; }

    [Column("local_description")]
    public string? LocalDescription { get; set; }

    [Column("local_ingredients", TypeName = "jsonb")]
    public string? LocalIngredients { get; set; }

    [Column("local_image_url")]
    public string? LocalImageUrl { get; set; }

    [Column("local_image_urls", TypeName = "jsonb")]
    public string LocalImageUrls { get; set; } = "[]";

    /// <summary>
    /// Personal notes visible only to the owner.
    /// </summary>
    [Column("personal_notes")]
    public string? PersonalNotes { get; set; }

    // Local metadata fields (used for non-HelloFresh recipes)
    [Column("local_prep_time_minutes")]
    public int? LocalPrepTimeMinutes { get; set; }

    [Column("local_cook_time_minutes")]
    public int? LocalCookTimeMinutes { get; set; }

    [Column("local_servings")]
    public int? LocalServings { get; set; }

    [Column("local_difficulty")]
    [MaxLength(50)]
    public string? LocalDifficulty { get; set; }

    [Column("local_cuisine")]
    [MaxLength(100)]
    public string? LocalCuisine { get; set; }

    /// <summary>
    /// Visibility level: 'private', 'friends', 'public'
    /// - private: Only the owner can see (unless shared via a collection)
    /// - friends: User's friends can see
    /// - public: Everyone can see (and it appears in browse)
    /// Note: Private recipes shared via a collection are visible to collection members.
    /// </summary>
    [Required]
    [Column("visibility")]
    [MaxLength(20)]
    public string Visibility { get; set; } = "private";

    [Column("is_archived")]
    public bool IsArchived { get; set; } = false;

    [Column("archived_date")]
    public DateTime? ArchivedDate { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public GlobalRecipe? GlobalRecipe { get; set; }
    public ICollection<Rating> Ratings { get; set; } = new List<Rating>();
    public ICollection<UserRecipeTag> UserRecipeTags { get; set; } = new List<UserRecipeTag>();
    public ICollection<UserRecipeCollection> UserRecipeCollections { get; set; } = new List<UserRecipeCollection>();

    // Helper properties
    [NotMapped]
    public bool IsLinkedToGlobal => GlobalRecipeId.HasValue;

    [NotMapped]
    public string DisplayTitle => LocalTitle ?? GlobalRecipe?.Title ?? "Untitled Recipe";

    [NotMapped]
    public string? DisplayDescription => LocalDescription ?? GlobalRecipe?.Description;

    [NotMapped]
    public string DisplayImageUrls => !string.IsNullOrEmpty(LocalImageUrl)
        ? $"[\"{LocalImageUrl}\"]"
        : (!string.IsNullOrEmpty(LocalImageUrls) && LocalImageUrls != "[]"
            ? LocalImageUrls
            : GlobalRecipe?.ImageUrls ?? "[]");

    // Backward compatibility
    [NotMapped]
    public string? Name
    {
        get => LocalTitle ?? GlobalRecipe?.Title;
        set => LocalTitle = value;
    }

    [NotMapped]
    public string? Description
    {
        get => LocalDescription ?? GlobalRecipe?.Description;
        set => LocalDescription = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\UserRecipe.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\UserRecipeCollection.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Join table connecting UserRecipes to Collections.
/// A recipe can belong to multiple collections, a collection can contain multiple recipes.
/// </summary>
[Table("user_recipe_collections")]
public class UserRecipeCollection
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("user_recipe_id")]
    public Guid UserRecipeId { get; set; }

    [Required]
    [Column("collection_id")]
    public Guid CollectionId { get; set; }

    [Column("added_at")]
    public DateTime AddedAt { get; set; } = DateTime.UtcNow;

    [Column("added_by_user_id")]
    public Guid AddedByUserId { get; set; }

    [Column("notes")]
    [MaxLength(500)]
    public string? Notes { get; set; }

    [Column("sort_order")]
    public int SortOrder { get; set; } = 0;

    // Navigation properties
    public UserRecipe UserRecipe { get; set; } = null!;
    public Collection Collection { get; set; } = null!;
    public User AddedByUser { get; set; } = null!;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\UserRecipeCollection.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ActivityFeedService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using System.Text.Json;

namespace StorhaugenEats.API.Services;

public class ActivityFeedService : IActivityFeedService
{
    private readonly AppDbContext _context;
    private readonly IUserFriendshipService _friendshipService;

    public ActivityFeedService(AppDbContext context, IUserFriendshipService friendshipService)
    {
        _context = context;
        _friendshipService = friendshipService;
    }

    public async Task<ActivityFeedPagedResult> GetFeedAsync(Guid userId, ActivityFeedQuery query)
    {
        // Get friend IDs
        var friendIds = await _friendshipService.GetFriendIdsAsync(userId);

        // If no friends, return empty feed
        if (!friendIds.Any())
        {
            return new ActivityFeedPagedResult
            {
                Items = new List<ActivityFeedItemDto>(),
                TotalCount = 0,
                Page = query.Page,
                PageSize = query.PageSize
            };
        }

        // Filter by specific users if provided, otherwise show all friends
        var targetUserIds = query.UserIds?.Any() == true
            ? query.UserIds.Intersect(friendIds).ToList()
            : friendIds;

        var queryable = _context.ActivityFeedItems
            .Include(a => a.User)
            .Where(a => targetUserIds.Contains(a.UserId));

        // Filter by activity types
        if (query.Types?.Any() == true)
        {
            queryable = queryable.Where(a => query.Types.Contains(a.ActivityType));
        }

        queryable = queryable.OrderByDescending(a => a.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var items = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new ActivityFeedPagedResult
        {
            Items = items.Select(MapToDto).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<ActivityFeedPagedResult> GetUserActivityAsync(Guid userId, int page = 1, int pageSize = 20)
    {
        var queryable = _context.ActivityFeedItems
            .Include(a => a.User)
            .Where(a => a.UserId == userId)
            .OrderByDescending(a => a.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var items = await queryable
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return new ActivityFeedPagedResult
        {
            Items = items.Select(MapToDto).ToList(),
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        };
    }

    public async Task<ActivitySummaryDto> GetActivitySummaryAsync(Guid userId)
    {
        var activities = await _context.ActivityFeedItems
            .Where(a => a.UserId == userId)
            .ToListAsync();

        return new ActivitySummaryDto
        {
            TotalActivities = activities.Count,
            RecipesAdded = activities.Count(a => a.ActivityType == "added"),
            RecipesRated = activities.Count(a => a.ActivityType == "rated"),
            RecipesPublished = activities.Count(a => a.ActivityType == "published"),
            LastActivityDate = activities.OrderByDescending(a => a.CreatedAt).FirstOrDefault()?.CreatedAt
        };
    }

    public async Task RecordRatingActivityAsync(Guid userId, Guid recipeId, string recipeName, decimal rating, string? imageUrl = null)
    {
        // Check if there's already a rating activity for this user+recipe combo
        // If so, update it instead of creating a new one (prevents duplicate activities)
        var existingActivity = await _context.ActivityFeedItems
            .FirstOrDefaultAsync(a =>
                a.UserId == userId &&
                a.TargetId == recipeId &&
                a.ActivityType == "rated");

        if (existingActivity != null)
        {
            // Update existing activity with new rating
            existingActivity.Metadata = System.Text.Json.JsonSerializer.Serialize(new
            {
                recipeName = recipeName,
                rating = rating,
                imageUrl = imageUrl
            });
            existingActivity.CreatedAt = DateTime.UtcNow; // Move to top of feed
        }
        else
        {
            // Create new activity
            var activity = ActivityFeedItem.CreateRatingActivity(userId, recipeId, recipeName, rating, imageUrl);
            _context.ActivityFeedItems.Add(activity);
        }

        await _context.SaveChangesAsync();
    }

    public async Task RecordAddedRecipeActivityAsync(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null)
    {
        var activity = ActivityFeedItem.CreateAddedRecipeActivity(userId, recipeId, recipeName, imageUrl);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task RecordPublishedActivityAsync(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null)
    {
        var activity = ActivityFeedItem.CreatePublishedActivity(userId, globalRecipeId, recipeName, imageUrl);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task CleanupOldActivitiesAsync(int daysToKeep = 90)
    {
        var cutoffDate = DateTime.UtcNow.AddDays(-daysToKeep);

        var oldActivities = await _context.ActivityFeedItems
            .Where(a => a.CreatedAt < cutoffDate)
            .ToListAsync();

        if (oldActivities.Any())
        {
            _context.ActivityFeedItems.RemoveRange(oldActivities);
            await _context.SaveChangesAsync();
        }
    }

    private ActivityFeedItemDto MapToDto(ActivityFeedItem activity)
    {
        var metadata = ParseMetadata(activity.Metadata);

        return new ActivityFeedItemDto
        {
            Id = activity.Id,
            UserId = activity.UserId,
            UserDisplayName = activity.User?.DisplayName ?? "Unknown",
            UserAvatarUrl = activity.User?.AvatarUrl,
            ActivityType = activity.ActivityType,
            TargetType = activity.TargetType,
            TargetId = activity.TargetId,
            RecipeName = metadata.GetValueOrDefault("recipeName")?.ToString(),
            RecipeImageUrl = metadata.GetValueOrDefault("imageUrl")?.ToString(),
            RatingScore = metadata.TryGetValue("rating", out var ratingObj) && ratingObj is JsonElement elem
                ? elem.TryGetDecimal(out var rating) ? rating : null
                : null,
            CreatedAt = activity.CreatedAt
        };
    }

    private static Dictionary<string, object?> ParseMetadata(string json)
    {
        try
        {
            return JsonSerializer.Deserialize<Dictionary<string, object?>>(json) ?? new();
        }
        catch
        {
            return new Dictionary<string, object?>();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\CollectionService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;
using System.Text.Json;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing recipe collections.
/// </summary>
public class CollectionService : ICollectionService
{
    private readonly AppDbContext _context;
    private readonly IUserFriendshipService _friendshipService;

    public CollectionService(AppDbContext context, IUserFriendshipService friendshipService)
    {
        _context = context;
        _friendshipService = friendshipService;
    }

    #region Collection CRUD

    public async Task<List<CollectionDto>> GetUserCollectionsAsync(Guid userId)
    {
        // Get collections user owns or is a member of
        var collections = await _context.Collections
            .Include(c => c.Owner)
            .Include(c => c.Members)
                .ThenInclude(m => m.User)
            .Include(c => c.UserRecipeCollections)
            .Where(c => c.OwnerUserId == userId || c.Members.Any(m => m.UserId == userId))
            .OrderBy(c => c.Name)
            .ToListAsync();

        return collections.Select(c => MapToDto(c, userId)).ToList();
    }

    public async Task<CollectionDto?> GetCollectionAsync(Guid collectionId, Guid userId)
    {
        var collection = await _context.Collections
            .Include(c => c.Owner)
            .Include(c => c.Members)
                .ThenInclude(m => m.User)
            .Include(c => c.UserRecipeCollections)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            return null;

        // Check access - members, friends (for friend visibility), or public
        if (!await CanUserViewCollectionAsync(collection, userId))
            return null;

        return MapToDto(collection, userId);
    }

    public async Task<CollectionDto?> GetCollectionByShareCodeAsync(string shareCode, Guid? userId)
    {
        if (string.IsNullOrWhiteSpace(shareCode))
            return null;

        var collection = await _context.Collections
            .Include(c => c.Owner)
            .Include(c => c.Members)
                .ThenInclude(m => m.User)
            .Include(c => c.UserRecipeCollections)
            .FirstOrDefaultAsync(c => c.UniqueShareId == shareCode.ToUpper());

        if (collection == null)
            return null;

        // Only shared collections can be accessed via share code
        if (!collection.IsShared)
            return null;

        return MapToDto(collection, userId ?? Guid.Empty);
    }

    public async Task<CollectionDto> CreateCollectionAsync(Guid userId, CreateCollectionDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new InvalidOperationException("Collection name is required");

        var visibility = dto.Visibility ?? "private";
        var isShared = visibility != "private";

        var collection = new Collection
        {
            Id = Guid.NewGuid(),
            OwnerUserId = userId,
            Name = dto.Name.Trim(),
            Description = dto.Description?.Trim(),
            IsShared = isShared,
            Visibility = visibility,
            UniqueShareId = isShared ? GenerateShareCode() : null,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Collections.Add(collection);

        // Add owner as member with role=owner
        _context.CollectionMembers.Add(new CollectionMember
        {
            Id = Guid.NewGuid(),
            CollectionId = collection.Id,
            UserId = userId,
            Role = "owner",
            JoinedAt = DateTime.UtcNow
        });

        await _context.SaveChangesAsync();

        return (await GetCollectionAsync(collection.Id, userId))!;
    }

    public async Task<CollectionDto> UpdateCollectionAsync(Guid collectionId, Guid userId, UpdateCollectionDto dto)
    {
        var collection = await _context.Collections
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (collection.OwnerUserId != userId)
            throw new InvalidOperationException("Only the owner can update this collection");

        if (!string.IsNullOrWhiteSpace(dto.Name))
            collection.Name = dto.Name.Trim();

        if (dto.Description != null)
            collection.Description = string.IsNullOrWhiteSpace(dto.Description) ? null : dto.Description.Trim();

        if (!string.IsNullOrWhiteSpace(dto.Visibility))
        {
            var newVisibility = dto.Visibility;
            var newIsShared = newVisibility != "private";
            var wasPrivate = !collection.IsShared;
            var isNowPrivate = !newIsShared;

            collection.IsShared = newIsShared;
            collection.Visibility = newVisibility;

            // Generate share code when becoming shared, clear when becoming private
            if (wasPrivate && !isNowPrivate && string.IsNullOrEmpty(collection.UniqueShareId))
            {
                collection.UniqueShareId = GenerateShareCode();
            }
            else if (isNowPrivate)
            {
                collection.UniqueShareId = null;
            }
        }

        collection.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return (await GetCollectionAsync(collectionId, userId))!;
    }

    public async Task DeleteCollectionAsync(Guid collectionId, Guid userId)
    {
        var collection = await _context.Collections
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (collection.OwnerUserId != userId)
            throw new InvalidOperationException("Only the owner can delete this collection");

        // Recipes are not deleted, just the collection and links (cascade)
        _context.Collections.Remove(collection);
        await _context.SaveChangesAsync();
    }

    #endregion

    #region Recipe-Collection Management

    public async Task<CollectionRecipesResult> GetCollectionRecipesAsync(Guid collectionId, Guid userId, GetCollectionRecipesQuery? query = null)
    {
        query ??= new GetCollectionRecipesQuery();

        var collection = await _context.Collections
            .Include(c => c.Owner)
            .Include(c => c.Members)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (!await CanUserViewCollectionAsync(collection, userId))
            throw new InvalidOperationException("You don't have access to this collection");

        var recipesQuery = _context.UserRecipeCollections
            .Where(urc => urc.CollectionId == collectionId)
            .Include(urc => urc.UserRecipe)
                .ThenInclude(ur => ur.User)
            .Include(urc => urc.UserRecipe)
                .ThenInclude(ur => ur.GlobalRecipe)
            .Include(urc => urc.UserRecipe)
                .ThenInclude(ur => ur.Ratings)
                    .ThenInclude(r => r.User)
            .AsQueryable();

        // Search filter
        if (!string.IsNullOrWhiteSpace(query.Search))
        {
            var searchLower = query.Search.ToLower();
            recipesQuery = recipesQuery.Where(urc =>
                (urc.UserRecipe.LocalTitle != null && urc.UserRecipe.LocalTitle.ToLower().Contains(searchLower)) ||
                (urc.UserRecipe.GlobalRecipe != null && urc.UserRecipe.GlobalRecipe.Title.ToLower().Contains(searchLower)));
        }

        // Count before pagination
        var totalCount = await recipesQuery.CountAsync();

        // Sorting
        recipesQuery = query.SortBy.ToLower() switch
        {
            "name" => query.SortDescending
                ? recipesQuery.OrderByDescending(urc => urc.UserRecipe.LocalTitle ?? urc.UserRecipe.GlobalRecipe!.Title)
                : recipesQuery.OrderBy(urc => urc.UserRecipe.LocalTitle ?? urc.UserRecipe.GlobalRecipe!.Title),
            "rating" => query.SortDescending
                ? recipesQuery.OrderByDescending(urc => urc.UserRecipe.Ratings.Any() ? urc.UserRecipe.Ratings.Average(r => r.Score) : 0)
                : recipesQuery.OrderBy(urc => urc.UserRecipe.Ratings.Any() ? urc.UserRecipe.Ratings.Average(r => r.Score) : 0),
            "date" => query.SortDescending
                ? recipesQuery.OrderByDescending(urc => urc.UserRecipe.CreatedAt)
                : recipesQuery.OrderBy(urc => urc.UserRecipe.CreatedAt),
            _ => query.SortDescending
                ? recipesQuery.OrderByDescending(urc => urc.AddedAt)
                : recipesQuery.OrderBy(urc => urc.AddedAt)
        };

        // Pagination
        var recipes = await recipesQuery
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .Select(urc => urc.UserRecipe)
            .ToListAsync();

        var recipeDtos = recipes.Select(r => MapUserRecipeToDto(r, userId)).ToList();

        return new CollectionRecipesResult
        {
            Collection = MapToDto(collection, userId),
            Recipes = recipeDtos,
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task AddRecipeToCollectionAsync(Guid collectionId, Guid userId, AddRecipeToCollectionDto dto)
    {
        var collection = await _context.Collections
            .Include(c => c.Members)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (!IsMember(collection, userId))
            throw new InvalidOperationException("You must be a member to add recipes to this collection");

        // Verify recipe exists
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == dto.UserRecipeId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        // Check if already in collection
        var exists = await _context.UserRecipeCollections
            .AnyAsync(urc => urc.CollectionId == collectionId && urc.UserRecipeId == dto.UserRecipeId);

        if (exists)
            return; // Already in collection

        _context.UserRecipeCollections.Add(new UserRecipeCollection
        {
            Id = Guid.NewGuid(),
            UserRecipeId = dto.UserRecipeId,
            CollectionId = collectionId,
            AddedAt = DateTime.UtcNow,
            AddedByUserId = userId
        });

        await _context.SaveChangesAsync();
    }

    public async Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId, Guid userId)
    {
        var collection = await _context.Collections
            .Include(c => c.Members)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (!IsMember(collection, userId))
            throw new InvalidOperationException("You must be a member to remove recipes from this collection");

        var link = await _context.UserRecipeCollections
            .FirstOrDefaultAsync(urc => urc.CollectionId == collectionId && urc.UserRecipeId == recipeId);

        if (link != null)
        {
            _context.UserRecipeCollections.Remove(link);
            await _context.SaveChangesAsync();
        }
    }

    #endregion

    #region Collection Membership

    public async Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId, Guid userId)
    {
        var collection = await _context.Collections
            .Include(c => c.Members)
                .ThenInclude(m => m.User)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (!IsMember(collection, userId))
            throw new InvalidOperationException("You don't have access to this collection");

        return collection.Members.Select(m => new CollectionMemberDto
        {
            UserId = m.UserId,
            DisplayName = m.User.DisplayName,
            AvatarUrl = m.User.AvatarUrl,
            IsOwner = m.Role == "owner",
            CreatedAt = m.JoinedAt
        }).ToList();
    }

    public async Task AddMemberAsync(Guid collectionId, Guid userId, AddCollectionMemberDto dto)
    {
        var collection = await _context.Collections
            .Include(c => c.Members)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (collection.OwnerUserId != userId)
            throw new InvalidOperationException("Only the owner can add members");

        // Find user by share ID or email
        var targetUser = await _context.Users
            .FirstOrDefaultAsync(u => u.UniqueShareId == dto.UserIdentifier || u.Email == dto.UserIdentifier);

        if (targetUser == null)
            throw new InvalidOperationException("User not found");

        // Check if already a member
        if (collection.Members.Any(m => m.UserId == targetUser.Id))
            throw new InvalidOperationException("User is already a member of this collection");

        _context.CollectionMembers.Add(new CollectionMember
        {
            Id = Guid.NewGuid(),
            CollectionId = collectionId,
            UserId = targetUser.Id,
            Role = "member",
            JoinedAt = DateTime.UtcNow,
            InvitedByUserId = userId
        });

        await _context.SaveChangesAsync();
    }

    public async Task RemoveMemberAsync(Guid collectionId, Guid memberId, Guid userId)
    {
        var collection = await _context.Collections
            .Include(c => c.Members)
            .FirstOrDefaultAsync(c => c.Id == collectionId);

        if (collection == null)
            throw new InvalidOperationException("Collection not found");

        if (collection.OwnerUserId != userId)
            throw new InvalidOperationException("Only the owner can remove members");

        var member = collection.Members.FirstOrDefault(m => m.UserId == memberId);
        if (member == null)
            throw new InvalidOperationException("Member not found");

        if (member.Role == "owner")
            throw new InvalidOperationException("Cannot remove the owner");

        _context.CollectionMembers.Remove(member);
        await _context.SaveChangesAsync();
    }

    public async Task LeaveCollectionAsync(Guid collectionId, Guid userId)
    {
        var member = await _context.CollectionMembers
            .Include(m => m.Collection)
            .FirstOrDefaultAsync(m => m.CollectionId == collectionId && m.UserId == userId);

        if (member == null)
            throw new InvalidOperationException("You are not a member of this collection");

        if (member.Role == "owner")
            throw new InvalidOperationException("Cannot leave your own collection. Delete it instead.");

        _context.CollectionMembers.Remove(member);
        await _context.SaveChangesAsync();
    }

    #endregion

    #region Visibility

    public async Task<bool> CanUserViewRecipeViaCollectionAsync(Guid recipeId, Guid userId)
    {
        // Find collections that contain the recipe + minimal access info
        var collectionInfos = await _context.UserRecipeCollections
            .Where(urc => urc.UserRecipeId == recipeId)
            .Select(urc => new
            {
                OwnerUserId = urc.Collection.OwnerUserId,
                Visibility = urc.Collection.Visibility ?? (urc.Collection.IsShared ? "friends" : "private"),
                IsMember = urc.Collection.Members.Any(m => m.UserId == userId)
            })
            .ToListAsync();

        if (collectionInfos.Count == 0)
            return false;

        // Owner or member => allowed
        if (collectionInfos.Any(c => c.OwnerUserId == userId || c.IsMember))
            return true;

        // Public collection => allowed
        if (collectionInfos.Any(c => string.Equals(c.Visibility, "public", StringComparison.OrdinalIgnoreCase)))
            return true;

        // Friends collection => allowed if user is friends with the owner of ANY such collection
        var friendOwners = collectionInfos
            .Where(c => string.Equals(c.Visibility, "friends", StringComparison.OrdinalIgnoreCase))
            .Select(c => c.OwnerUserId)
            .Distinct()
            .ToList();

        if (friendOwners.Count == 0)
            return false;

        return await _context.UserFriendships.AnyAsync(f =>
            f.Status == "accepted" &&
            (
                (f.RequesterUserId == userId && friendOwners.Contains(f.TargetUserId)) ||
                (f.TargetUserId == userId && friendOwners.Contains(f.RequesterUserId))
            ));
    }



    public async Task<List<CollectionDto>> GetFriendSharedCollectionsAsync(Guid friendUserId, Guid currentUserId)
    {
        // Check if they are actually friends
        var areFriends = await _context.UserFriendships
            .AnyAsync(f =>
                f.Status == "accepted" &&
                ((f.RequesterUserId == currentUserId && f.TargetUserId == friendUserId) ||
                 (f.RequesterUserId == friendUserId && f.TargetUserId == currentUserId)));

        if (!areFriends)
            return new List<CollectionDto>();

        // Get collections owned by the friend that are visible to friends or public
        var collections = await _context.Collections
            .Include(c => c.Owner)
            .Include(c => c.Members)
                .ThenInclude(m => m.User)
            .Include(c => c.UserRecipeCollections)
            .Where(c => c.OwnerUserId == friendUserId &&
                       (c.Visibility == "friends" || c.Visibility == "public"))
            .OrderBy(c => c.Name)
            .ToListAsync();

        return collections.Select(c => MapToDto(c, currentUserId)).ToList();
    }

    #endregion

    #region Private Helpers

    private bool IsMember(Collection collection, Guid userId)
    {
        return collection.OwnerUserId == userId ||
               collection.Members.Any(m => m.UserId == userId);
    }

    private async Task<bool> CanUserViewCollectionAsync(Collection collection, Guid userId)
    {
        // Members can always view
        if (IsMember(collection, userId))
            return true;

        // Public collections can be viewed by anyone
        if (collection.Visibility == "public")
            return true;

        // Friends visibility - check if user is a friend of the owner
        if (collection.Visibility == "friends")
        {
            return await _friendshipService.AreFriendsAsync(collection.OwnerUserId, userId);
        }

        return false;
    }

    private CollectionDto MapToDto(Collection collection, Guid userId)
    {
        return new CollectionDto
        {
            Id = collection.Id,
            Name = collection.Name,
            Description = collection.Description,
            Visibility = collection.Visibility ?? (collection.IsShared ? "friends" : "private"),
            ShareCode = collection.UniqueShareId,
            OwnerId = collection.OwnerUserId,
            OwnerDisplayName = collection.Owner?.DisplayName ?? "Unknown",
            OwnerAvatarUrl = collection.Owner?.AvatarUrl,
            RecipeCount = collection.UserRecipeCollections?.Count ?? 0,
            MemberCount = collection.Members?.Count ?? 0,
            IsOwner = collection.OwnerUserId == userId,
            IsMember = IsMember(collection, userId),
            CreatedAt = collection.CreatedAt,
            UpdatedAt = collection.UpdatedAt,
            Members = collection.Members?.Select(m => new CollectionMemberDto
            {
                UserId = m.UserId,
                DisplayName = m.User?.DisplayName ?? "Unknown",
                AvatarUrl = m.User?.AvatarUrl,
                IsOwner = m.Role == "owner",
                CreatedAt = m.JoinedAt
            }).ToList() ?? new List<CollectionMemberDto>()
        };
    }

    private static string ValidateVisibility(string visibility)
    {
        var valid = new[] { "private", "friends", "public" };
        var normalized = visibility?.ToLower() ?? "private";
        return valid.Contains(normalized) ? normalized : "private";
    }

    private static string GenerateShareCode()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Avoid ambiguous chars like O/0, I/1
        var random = new Random();
        return new string(Enumerable.Range(0, 8).Select(_ => chars[random.Next(chars.Length)]).ToArray());
    }

    private UserRecipeDto MapUserRecipeToDto(UserRecipe recipe, Guid userId)
    {
        var myRating = recipe.Ratings?.FirstOrDefault(r => r.UserId == userId);
        var avgRating = recipe.Ratings?.Any() == true ? recipe.Ratings.Average(r => r.Score) : 0;

        // Build member ratings dictionary (excluding requesting user's own rating)
        var memberRatings = recipe.Ratings?
            .Where(r => r.User != null && r.UserId != userId)
            .ToDictionary(r => r.User!.DisplayName, r => (decimal?)r.Score)
            ?? new Dictionary<string, decimal?>();

        return new UserRecipeDto
        {
            Id = recipe.Id,
            UserId = recipe.UserId,
            UserDisplayName = recipe.User?.DisplayName ?? "Unknown",
            UserAvatarUrl = recipe.User?.AvatarUrl,
            Name = recipe.LocalTitle ?? recipe.GlobalRecipe?.Title ?? "Untitled",
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = GetImageUrls(recipe),
            GlobalRecipeId = recipe.GlobalRecipeId,
            GlobalRecipeName = recipe.GlobalRecipe?.Title,
            Visibility = recipe.Visibility,
            PersonalNotes = recipe.UserId == userId ? recipe.PersonalNotes : null,
            IsArchived = recipe.IsArchived,
            CreatedAt = recipe.CreatedAt,
            UpdatedAt = recipe.UpdatedAt,
            MyRating = myRating?.Score,
            AverageRating = (double)avgRating,
            RatingCount = recipe.Ratings?.Count ?? 0,
            MemberRatings = memberRatings,
            IsHellofresh = recipe.GlobalRecipe?.IsHellofresh ?? false,
            HellofreshWeek = recipe.GlobalRecipe?.HellofreshWeek
        };
    }

    private static List<string> GetImageUrls(UserRecipe recipe)
    {
        // 1) Local single
        if (!string.IsNullOrWhiteSpace(recipe.LocalImageUrl) && recipe.LocalImageUrl != "null")
            return new List<string> { recipe.LocalImageUrl };

        // 2) Local list
        if (!string.IsNullOrWhiteSpace(recipe.LocalImageUrls) &&
            recipe.LocalImageUrls != "[]" &&
            recipe.LocalImageUrls != "null")
        {
            try
            {
                return JsonSerializer.Deserialize<List<string>>(recipe.LocalImageUrls) ?? new();
            }
            catch { /* ignore */ }
        }

        // 3) Global list (this is the important fix for HF cases)
        if (!string.IsNullOrWhiteSpace(recipe.GlobalRecipe?.ImageUrls) &&
            recipe.GlobalRecipe.ImageUrls != "[]" &&
            recipe.GlobalRecipe.ImageUrls != "null")
        {
            try
            {
                return JsonSerializer.Deserialize<List<string>>(recipe.GlobalRecipe.ImageUrls) ?? new();
            }
            catch { /* ignore */ }
        }

        // 4) Global single fallback
        if (!string.IsNullOrWhiteSpace(recipe.GlobalRecipe?.ImageUrl) && recipe.GlobalRecipe.ImageUrl != "null")
            return new List<string> { recipe.GlobalRecipe.ImageUrl };

        return new();
    }


    #endregion
}


================================================================================
FILE END: \StorhaugenEats.API\Services\CollectionService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\CurrentUserService.cs
================================================================================
using System.Security.Claims;
using System.Text.Json; // Add this
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class CurrentUserService : ICurrentUserService
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly AppDbContext _context;

    public CurrentUserService(IHttpContextAccessor httpContextAccessor, AppDbContext context)
    {
        _httpContextAccessor = httpContextAccessor;
        _context = context;
    }

    public string? GetUserEmail()
    {
        return _httpContextAccessor.HttpContext?.User?.FindFirst(ClaimTypes.Email)?.Value
            ?? _httpContextAccessor.HttpContext?.User?.FindFirst("email")?.Value;
    }

    public string? GetUserSubject()
    {
        return _httpContextAccessor.HttpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value
            ?? _httpContextAccessor.HttpContext?.User?.FindFirst("sub")?.Value;
    }

    public bool IsAuthenticated()
    {
        return _httpContextAccessor.HttpContext?.User?.Identity?.IsAuthenticated ?? false;
    }

    public async Task<Guid> GetOrCreateUserIdAsync()
    {
        if (!IsAuthenticated())
        {
            throw new UnauthorizedAccessException("User is not authenticated");
        }

        var email = GetUserEmail();
        var subject = GetUserSubject();

        if (string.IsNullOrEmpty(email))
        {
            throw new UnauthorizedAccessException("User email not found in token");
        }

        // 1. Resolve the best possible display name from the token
        var displayName = GetDisplayNameFromToken(email);
        var avatarUrl = GetAvatarFromToken();

        // 2. Check DB
        var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == email);

        if (user == null)
        {
            // --- CREATE NEW USER ---
            user = new User
            {
                Id = Guid.NewGuid(),
                Email = email,
                DisplayName = displayName, // Now uses the parsed name
                AvatarUrl = avatarUrl,
                SupabaseUserId = subject,
                UniqueShareId = GenerateUniqueShareId(),
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
        }
        else
        {
            // --- AUTO-UPDATE EXISTING USER ---
            // If the DB has an email-like name, but we found a real name in the token, update it!
            bool dataChanged = false;

            // Update Name if better one found
            if (user.DisplayName.Contains("@") && !displayName.Contains("@"))
            {
                user.DisplayName = displayName;
                dataChanged = true;
            }

            // Update Avatar if new one found
            if (string.IsNullOrEmpty(user.AvatarUrl) && !string.IsNullOrEmpty(avatarUrl))
            {
                user.AvatarUrl = avatarUrl;
                dataChanged = true;
            }

            if (dataChanged)
            {
                user.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
        }

        return user.Id;
    }

    // --- HELPER METHODS ---

    private string GetDisplayNameFromToken(string email)
    {
        var user = _httpContextAccessor.HttpContext?.User;
        if (user == null) return email.Split('@')[0];

        // 1. Try standard claims
        var name = user.FindFirst("name")?.Value ?? user.FindFirst(ClaimTypes.Name)?.Value;

        // 2. Try parsing Supabase 'user_metadata' claim
        if (string.IsNullOrEmpty(name) || name.Contains("@"))
        {
            var metadata = user.FindFirst("user_metadata")?.Value;
            if (!string.IsNullOrEmpty(metadata))
            {
                try
                {
                    using var doc = JsonDocument.Parse(metadata);
                    if (doc.RootElement.TryGetProperty("name", out var nameProp))
                    {
                        name = nameProp.GetString();
                    }
                    else if (doc.RootElement.TryGetProperty("full_name", out var fullProp))
                    {
                        name = fullProp.GetString();
                    }
                }
                catch { /* Ignore JSON errors */ }
            }
        }

        // 3. Fallback to Email prefix
        return !string.IsNullOrWhiteSpace(name) ? name : email.Split('@')[0];
    }

    private string? GetAvatarFromToken()
    {
        var user = _httpContextAccessor.HttpContext?.User;
        if (user == null) return null;

        // 1. Try standard picture claim
        var avatar = user.FindFirst("picture")?.Value;

        // 2. Try Supabase 'user_metadata'
        if (string.IsNullOrEmpty(avatar))
        {
            var metadata = user.FindFirst("user_metadata")?.Value;
            if (!string.IsNullOrEmpty(metadata))
            {
                try
                {
                    using var doc = JsonDocument.Parse(metadata);
                    if (doc.RootElement.TryGetProperty("avatar_url", out var avProp))
                    {
                        avatar = avProp.GetString();
                    }
                    else if (doc.RootElement.TryGetProperty("picture", out var picProp))
                    {
                        avatar = picProp.GetString();
                    }
                }
                catch { }
            }
        }
        return avatar;
    }

    private string GenerateUniqueShareId()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        var random = new Random();
        return new string(Enumerable.Repeat(chars, 12)
            .Select(s => s[random.Next(s.Length)]).ToArray());
    }
}

================================================================================
FILE END: \StorhaugenEats.API\Services\CurrentUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\GlobalRecipeService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class GlobalRecipeService : IGlobalRecipeService
{
    private readonly AppDbContext _context;

    public GlobalRecipeService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<GlobalRecipe?> GetByIdAsync(Guid id)
    {
        return await _context.GlobalRecipes
            .Include(gr => gr.Ratings)
            .FirstOrDefaultAsync(gr => gr.Id == id);
    }

    public async Task<GlobalRecipe?> GetByHellofreshUuidAsync(string uuid)
    {
        return await _context.GlobalRecipes
            .FirstOrDefaultAsync(gr => gr.HellofreshUuid == uuid);
    }

    public async Task<IEnumerable<GlobalRecipe>> GetPublicRecipesAsync(int skip = 0, int take = 50, string? sortBy = "rating")
    {
        var query = _context.GlobalRecipes
            .Where(gr => gr.IsHellofresh || gr.IsPublic);

        query = sortBy?.ToLower() switch
        {
            "rating" => query.OrderByDescending(gr => gr.AverageRating).ThenByDescending(gr => gr.RatingCount),
            "date" => query.OrderByDescending(gr => gr.CreatedAt),
            "title" => query.OrderBy(gr => gr.Title),
            _ => query.OrderByDescending(gr => gr.AverageRating)
        };

        return await query
            .Skip(skip)
            .Take(take)
            .ToListAsync();
    }

    public async Task<GlobalRecipe> CreateAsync(GlobalRecipe recipe)
    {
        recipe.CreatedAt = DateTime.UtcNow;
        recipe.UpdatedAt = DateTime.UtcNow;
        _context.GlobalRecipes.Add(recipe);
        await _context.SaveChangesAsync();
        return recipe;
    }

    public async Task<GlobalRecipe> UpdateAsync(GlobalRecipe recipe)
    {
        recipe.UpdatedAt = DateTime.UtcNow;
        _context.GlobalRecipes.Update(recipe);
        await _context.SaveChangesAsync();
        return recipe;
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var recipe = await _context.GlobalRecipes.FindAsync(id);
        if (recipe == null) return false;

        _context.GlobalRecipes.Remove(recipe);
        await _context.SaveChangesAsync();
        return true;
    }

    public async Task UpsertHellofreshRecipeAsync(GlobalRecipe recipe)
    {
        var existing = await GetByHellofreshUuidAsync(recipe.HellofreshUuid!);

        if (existing != null)
        {
            // Update existing
            existing.Title = recipe.Title;
            existing.Description = recipe.Description;
            existing.ImageUrl = recipe.ImageUrl;
            existing.Ingredients = recipe.Ingredients;
            existing.NutritionData = recipe.NutritionData;
            existing.CookTimeMinutes = recipe.CookTimeMinutes;
            existing.Difficulty = recipe.Difficulty;
            existing.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
        }
        else
        {
            // Insert new
            recipe.IsHellofresh = true;
            recipe.CreatedAt = DateTime.UtcNow;
            recipe.UpdatedAt = DateTime.UtcNow;
            _context.GlobalRecipes.Add(recipe);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<Dictionary<string, GlobalRecipe>> GetHellofreshRecipesByUuidsAsync(IEnumerable<string> uuids)
    {
        var recipes = await _context.GlobalRecipes
            .Where(gr => gr.IsHellofresh && uuids.Contains(gr.HellofreshUuid!))
            .ToListAsync();

        return recipes.ToDictionary(r => r.HellofreshUuid!, r => r);
    }

    public async Task BatchUpsertHellofreshRecipesAsync(IEnumerable<GlobalRecipe> recipes)
    {
        var recipeList = recipes.ToList();
        if (!recipeList.Any()) return;

        // Get all UUIDs from incoming recipes
        var uuids = recipeList.Select(r => r.HellofreshUuid!).ToList();

        // Fetch all existing recipes in one query
        var existingRecipes = await GetHellofreshRecipesByUuidsAsync(uuids);

        var toAdd = new List<GlobalRecipe>();
        var toUpdate = new List<GlobalRecipe>();

        foreach (var recipe in recipeList)
        {
            if (existingRecipes.TryGetValue(recipe.HellofreshUuid!, out var existing))
            {
                // Update existing
                existing.Title = recipe.Title;
                existing.Description = recipe.Description;
                existing.ImageUrl = recipe.ImageUrl;
                existing.Ingredients = recipe.Ingredients;
                existing.NutritionData = recipe.NutritionData;
                existing.CookTimeMinutes = recipe.CookTimeMinutes;
                existing.Difficulty = recipe.Difficulty;
                existing.UpdatedAt = DateTime.UtcNow;
                toUpdate.Add(existing);
            }
            else
            {
                // Insert new
                recipe.IsHellofresh = true;
                recipe.CreatedAt = DateTime.UtcNow;
                recipe.UpdatedAt = DateTime.UtcNow;
                toAdd.Add(recipe);
            }
        }

        // Batch add new recipes
        if (toAdd.Any())
        {
            await _context.GlobalRecipes.AddRangeAsync(toAdd);
        }

        // Save all changes in one transaction
        await _context.SaveChangesAsync();
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\GlobalRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\HelloFreshScraperService.cs
================================================================================
using HtmlAgilityPack;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using System.Globalization;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace StorhaugenEats.API.Services;

public class HelloFreshScraperService : IHelloFreshScraperService
{
    private readonly HttpClient _httpClient;
    private readonly AppDbContext _context;
    private readonly IGlobalRecipeService _globalRecipeService;
    private readonly IStorageService _storageService;
    private readonly IConfiguration _configuration;

    private const string BaseUrl = "https://www.hellofresh.no";

    public HelloFreshScraperService(
        HttpClient httpClient,
        AppDbContext context,
        IGlobalRecipeService globalRecipeService,
        IStorageService storageService,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _context = context;
        _globalRecipeService = globalRecipeService;
        _storageService = storageService;
        _configuration = configuration;
    }

    public async Task<bool> ShouldRunSyncAsync()
    {
        var syncIntervalHours = _configuration.GetValue<int>("HelloFresh:SyncIntervalHours", 24);

        var lastSync = await _context.EtlSyncLogs
            .Where(log => log.SyncType == "hellofresh" && log.Status == "success")
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        if (lastSync == null) return true;

        var hoursSinceLastSync = (DateTime.UtcNow - lastSync.StartedAt).TotalHours;
        return hoursSinceLastSync >= syncIntervalHours;
    }

    public async Task<string> GetBuildIdAsync()
    {
        var response = await _httpClient.GetStringAsync(BaseUrl);

        // Extract build ID from HTML
        // Pattern: /_next/static/[BUILD_ID]/_buildManifest.js
        var buildIdPattern = @"/_next/static/([^/]+)/_buildManifest\.js";
        var match = Regex.Match(response, buildIdPattern);

        if (!match.Success)
            throw new Exception("Failed to extract HelloFresh build ID");

        return match.Groups[1].Value;
    }

    public async Task<(int added, int updated)> SyncRecipesAsync()
    {
        var syncLog = new EtlSyncLog
        {
            Id = Guid.NewGuid(),
            SyncType = "hellofresh",
            StartedAt = DateTime.UtcNow
        };

        try
        {
            // Step 1: Get Build ID
            var buildId = await GetBuildIdAsync();
            syncLog.BuildId = buildId;

            // Step 2: Generate weeks to fetch
            var weeksToFetch = _configuration.GetValue<int>("HelloFresh:WeeksToFetch", 4);
            var weeks = GenerateWeeks(weeksToFetch);
            syncLog.WeeksSynced = string.Join(",", weeks);

            // Step 3: Fetch data for all weeks and collect recipes
            var allRecipes = new List<GlobalRecipe>();

            foreach (var week in weeks)
            {
                var url = $"{BaseUrl}/_next/data/{buildId}/menus/{week}.json";

                try
                {
                    var json = await _httpClient.GetStringAsync(url);
                    var weekRecipes = await ParseWeekDataAsync(json, week);
                    allRecipes.AddRange(weekRecipes);
                }
                catch (Exception ex)
                {
                    // Log error but continue with other weeks
                    Console.WriteLine($"Error fetching week {week}: {ex.Message}");
                }
            }

            // Step 4: Batch upsert all recipes in one operation
            int recipesAdded = 0;
            int recipesUpdated = 0;

            if (allRecipes.Any())
            {
                // Get existing recipes to count adds vs updates
                var uuids = allRecipes.Select(r => r.HellofreshUuid!).ToList();
                var existing = await _globalRecipeService.GetHellofreshRecipesByUuidsAsync(uuids);

                recipesAdded = allRecipes.Count(r => !existing.ContainsKey(r.HellofreshUuid!));
                recipesUpdated = allRecipes.Count(r => existing.ContainsKey(r.HellofreshUuid!));

                // Batch upsert
                await _globalRecipeService.BatchUpsertHellofreshRecipesAsync(allRecipes);
            }

            syncLog.RecipesAdded = recipesAdded;
            syncLog.RecipesUpdated = recipesUpdated;
            syncLog.Status = "success";
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            return (recipesAdded, recipesUpdated);
        }
        catch (Exception ex)
        {
            syncLog.Status = "failed";
            syncLog.ErrorMessage = ex.Message;
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            throw;
        }
    }

    private async Task<List<GlobalRecipe>> ParseWeekDataAsync(string jsonData, string week)
    {
        var recipes = new List<GlobalRecipe>();

        using var doc = JsonDocument.Parse(jsonData);
        var root = doc.RootElement;

        // Navigate to courses: pageProps.ssrPayload.courses
        if (!root.TryGetProperty("pageProps", out var pageProps) ||
            !pageProps.TryGetProperty("ssrPayload", out var ssrPayload) ||
            !ssrPayload.TryGetProperty("courses", out var courses))
        {
            return recipes;
        }

        foreach (var course in courses.EnumerateArray())
        {
            try
            {
                // Extract recipe data with week info
                var recipe = await ParseHelloFreshRecipeAsync(course, week);

                if (recipe != null)
                {
                    recipes.Add(recipe);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing recipe: {ex.Message}");
            }
        }

        return recipes;
    }

    private async Task<GlobalRecipe?> ParseHelloFreshRecipeAsync(JsonElement course, string week)
    {
        try
        {
            // Extract the recipe object from the course
            if (!course.TryGetProperty("recipe", out var recipeElement))
            {
                return null;
            }

            // Extract basic data from recipe object
            if (!recipeElement.TryGetProperty("uuid", out var uuidElement) ||
                !recipeElement.TryGetProperty("name", out var nameElement))
            {
                return null;
            }

            var uuid = uuidElement.GetString();
            var title = nameElement.GetString();

            if (string.IsNullOrEmpty(uuid) || string.IsNullOrEmpty(title))
                return null;

            // Extract description (use headline as description)
            string? description = null;
            if (recipeElement.TryGetProperty("headline", out var descElement))
            {
                description = descElement.GetString();
            }

            // Extract image URL (use HelloFresh URL directly to reduce requests)
            string? imageUrl = null;
            if (recipeElement.TryGetProperty("imageLink", out var imageElement))
            {
                imageUrl = imageElement.GetString();
            }

            // Extract ingredients
            var ingredients = new List<object>();
            if (recipeElement.TryGetProperty("ingredients", out var ingredientsElement))
            {
                foreach (var ing in ingredientsElement.EnumerateArray())
                {
                    var ingredient = new Dictionary<string, string>();

                    // Safely extract each property, handling both string and number types
                    if (ing.TryGetProperty("name", out var ingName))
                        ingredient["name"] = SafeGetString(ingName);

                    if (ing.TryGetProperty("quantity", out var quantity))
                        ingredient["amount"] = SafeGetString(quantity);

                    if (ing.TryGetProperty("unit", out var unit))
                        ingredient["unit"] = SafeGetString(unit);

                    if (ing.TryGetProperty("imagePath", out var ingImage))
                        ingredient["image"] = SafeGetString(ingImage);

                    ingredients.Add(ingredient);
                }
            }

            // Extract nutrition data
            Dictionary<string, object>? nutritionData = null;
            if (recipeElement.TryGetProperty("nutrition", out var nutritionElement))
            {
                nutritionData = new Dictionary<string, object>();

                // Handle both array and object formats
                if (nutritionElement.ValueKind == JsonValueKind.Array)
                {
                    // Nutrition is an array of objects
                    foreach (var item in nutritionElement.EnumerateArray())
                    {
                        if (item.TryGetProperty("name", out var nameEl) &&
                            item.TryGetProperty("amount", out var amountEl))
                        {
                            var name = nameEl.GetString();
                            if (!string.IsNullOrEmpty(name))
                            {
                                // Safely extract amount value based on its type
                                object amountValue = amountEl.ValueKind switch
                                {
                                    JsonValueKind.Number => amountEl.GetDouble(),
                                    JsonValueKind.String => amountEl.GetString() ?? "",
                                    _ => amountEl.GetRawText()
                                };
                                nutritionData[name] = amountValue;
                            }
                        }
                    }
                }
                else if (nutritionElement.ValueKind == JsonValueKind.Object)
                {
                    // Nutrition is an object
                    foreach (var prop in nutritionElement.EnumerateObject())
                    {
                        // Safely extract value based on its type
                        object value = prop.Value.ValueKind switch
                        {
                            JsonValueKind.Number => prop.Value.GetDouble(),
                            JsonValueKind.String => prop.Value.GetString() ?? "",
                            _ => prop.Value.GetRawText()
                        };
                        nutritionData[prop.Name] = value;
                    }
                }
            }

            // Extract cook time
            int? cookTime = null;
            if (recipeElement.TryGetProperty("prepTime", out var prepTimeElement))
            {
                // Handle both number and string formats
                if (prepTimeElement.ValueKind == JsonValueKind.Number)
                {
                    cookTime = prepTimeElement.GetInt32();
                }
                else if (prepTimeElement.ValueKind == JsonValueKind.String)
                {
                    // Sometimes it's a string like "PT20M" or just a number as string
                    var timeStr = prepTimeElement.GetString();
                    if (!string.IsNullOrEmpty(timeStr))
                    {
                        // Try parsing as direct number first
                        if (int.TryParse(timeStr, out var directParse))
                        {
                            cookTime = directParse;
                        }
                        else
                        {
                            // Try extracting from ISO 8601 duration format
                            var match = Regex.Match(timeStr, @"\d+");
                            if (match.Success && int.TryParse(match.Value, out var parsedTime))
                            {
                                cookTime = parsedTime;
                            }
                        }
                    }
                }
            }

            // Extract difficulty
            string? difficulty = null;
            if (recipeElement.TryGetProperty("difficulty", out var difficultyElement))
            {
                int diffValue = 0;

                // Handle both number and string formats
                if (difficultyElement.ValueKind == JsonValueKind.Number)
                {
                    diffValue = difficultyElement.GetInt32();
                }
                else if (difficultyElement.ValueKind == JsonValueKind.String)
                {
                    int.TryParse(difficultyElement.GetString(), out diffValue);
                }

                difficulty = diffValue switch
                {
                    1 => "Easy",
                    2 => "Medium",
                    3 => "Hard",
                    _ => "Easy"
                };
            }

            // Extract slug
            string? slug = null;
            if (recipeElement.TryGetProperty("slug", out var slugElement))
            {
                slug = slugElement.GetString();
            }

            // Extract tags from HelloFresh
            var tags = new List<string>();
            if (recipeElement.TryGetProperty("tags", out var tagsElement) && tagsElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var tagItem in tagsElement.EnumerateArray())
                {
                    if (tagItem.TryGetProperty("name", out var tagName))
                    {
                        var tagStr = tagName.GetString();
                        if (!string.IsNullOrEmpty(tagStr))
                            tags.Add(tagStr);
                    }
                }
            }

            // Extract cuisine
            string? cuisine = null;
            if (recipeElement.TryGetProperty("cuisines", out var cuisinesElement) && cuisinesElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var cuisineItem in cuisinesElement.EnumerateArray())
                {
                    if (cuisineItem.TryGetProperty("name", out var cuisineName))
                    {
                        cuisine = cuisineName.GetString();
                        break; // Take first cuisine
                    }
                }
            }

            // Extract total time
            int? totalTime = null;
            if (recipeElement.TryGetProperty("totalTime", out var totalTimeElement))
            {
                if (totalTimeElement.ValueKind == JsonValueKind.Number)
                {
                    totalTime = totalTimeElement.GetInt32();
                }
                else if (totalTimeElement.ValueKind == JsonValueKind.String)
                {
                    var timeStr = totalTimeElement.GetString();
                    if (!string.IsNullOrEmpty(timeStr))
                    {
                        var match = Regex.Match(timeStr, @"\d+");
                        if (match.Success && int.TryParse(match.Value, out var parsedTime))
                        {
                            totalTime = parsedTime;
                        }
                    }
                }
            }

            return new GlobalRecipe
            {
                Id = Guid.NewGuid(),
                Title = title,
                Description = description,
                ImageUrl = imageUrl,
                Ingredients = JsonSerializer.Serialize(ingredients),
                NutritionData = nutritionData != null ? JsonSerializer.Serialize(nutritionData) : null,
                CookTimeMinutes = cookTime,
                PrepTimeMinutes = cookTime, // prepTime maps to both for HelloFresh
                TotalTimeMinutes = totalTime,
                Difficulty = difficulty,
                IsHellofresh = true,
                HellofreshUuid = uuid,
                HellofreshSlug = slug,
                HellofreshWeek = week,
                Tags = JsonSerializer.Serialize(tags),
                Cuisine = cuisine,
                IsPublic = false,
                CreatedByUserId = null
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing HelloFresh recipe: {ex.Message}");
            return null;
        }
    }

    public List<string> GenerateAvailableWeeks(int count = 8)
    {
        var weeks = new List<string>();
        var currentDate = DateTime.UtcNow;

        // Generate weeks starting from 2 weeks ago to include past weeks
        for (int i = -2; i < count; i++)
        {
            var targetDate = currentDate.AddDays(i * 7);
            var calendar = CultureInfo.CurrentCulture.Calendar;
            var weekNumber = calendar.GetWeekOfYear(
                targetDate,
                CalendarWeekRule.FirstFourDayWeek,
                DayOfWeek.Monday
            );

            var weekString = $"{targetDate.Year}-W{weekNumber:D2}";
            weeks.Add(weekString);
        }

        return weeks.Distinct().ToList();
    }

    private List<string> GenerateWeeks(int count)
    {
        var weeks = new List<string>();
        var currentDate = DateTime.UtcNow;

        for (int i = 0; i < count; i++)
        {
            var targetDate = currentDate.AddDays(i * 7);
            var calendar = CultureInfo.CurrentCulture.Calendar;
            var weekNumber = calendar.GetWeekOfYear(
                targetDate,
                CalendarWeekRule.FirstFourDayWeek,
                DayOfWeek.Monday
            );

            var weekString = $"{targetDate.Year}-W{weekNumber:D2}";
            weeks.Add(weekString);
        }

        return weeks;
    }

    public async Task<(int added, int updated)> SyncWeekAsync(string week)
    {
        var syncLog = new EtlSyncLog
        {
            Id = Guid.NewGuid(),
            SyncType = "hellofresh",
            StartedAt = DateTime.UtcNow
        };

        try
        {
            // Step 1: Get Build ID
            var buildId = await GetBuildIdAsync();
            syncLog.BuildId = buildId;
            syncLog.WeeksSynced = week;

            // Step 2: Fetch data for the specific week
            var allRecipes = new List<GlobalRecipe>();
            var url = $"{BaseUrl}/_next/data/{buildId}/menus/{week}.json";

            try
            {
                var json = await _httpClient.GetStringAsync(url);
                var weekRecipes = await ParseWeekDataAsync(json, week);
                allRecipes.AddRange(weekRecipes);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error fetching week {week}: {ex.Message}");
                throw;
            }

            // Step 3: Batch upsert all recipes in one operation
            int recipesAdded = 0;
            int recipesUpdated = 0;

            if (allRecipes.Any())
            {
                // Get existing recipes to count adds vs updates
                var uuids = allRecipes.Select(r => r.HellofreshUuid!).ToList();
                var existing = await _globalRecipeService.GetHellofreshRecipesByUuidsAsync(uuids);

                recipesAdded = allRecipes.Count(r => !existing.ContainsKey(r.HellofreshUuid!));
                recipesUpdated = allRecipes.Count(r => existing.ContainsKey(r.HellofreshUuid!));

                // Batch upsert
                await _globalRecipeService.BatchUpsertHellofreshRecipesAsync(allRecipes);
            }

            syncLog.RecipesAdded = recipesAdded;
            syncLog.RecipesUpdated = recipesUpdated;
            syncLog.Status = "success";
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            return (recipesAdded, recipesUpdated);
        }
        catch (Exception ex)
        {
            syncLog.Status = "failed";
            syncLog.ErrorMessage = ex.Message;
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            throw;
        }
    }

    /// <summary>
    /// Safely extract string value from JsonElement, handling both string and number types
    /// </summary>
    private string SafeGetString(JsonElement element)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString() ?? "",
            JsonValueKind.Number => element.GetDecimal().ToString(CultureInfo.InvariantCulture),
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "",
            _ => element.GetRawText()
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\HelloFreshScraperService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IActivityFeedService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing the social activity feed.
/// </summary>
public interface IActivityFeedService
{
    // Feed queries
    Task<ActivityFeedPagedResult> GetFeedAsync(Guid userId, ActivityFeedQuery query);
    Task<ActivityFeedPagedResult> GetUserActivityAsync(Guid userId, int page = 1, int pageSize = 20);
    Task<ActivitySummaryDto> GetActivitySummaryAsync(Guid userId);

    // Activity creation (called by other services)
    Task RecordRatingActivityAsync(Guid userId, Guid recipeId, string recipeName, decimal rating, string? imageUrl = null);
    Task RecordAddedRecipeActivityAsync(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null);
    Task RecordPublishedActivityAsync(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null);

    // Cleanup
    Task CleanupOldActivitiesAsync(int daysToKeep = 90);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ICollectionService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing recipe collections.
/// </summary>
public interface ICollectionService
{
    // Collection CRUD
    Task<List<CollectionDto>> GetUserCollectionsAsync(Guid userId);
    Task<CollectionDto?> GetCollectionAsync(Guid collectionId, Guid userId);
    Task<CollectionDto?> GetCollectionByShareCodeAsync(string shareCode, Guid? userId);
    Task<CollectionDto> CreateCollectionAsync(Guid userId, CreateCollectionDto dto);
    Task<CollectionDto> UpdateCollectionAsync(Guid collectionId, Guid userId, UpdateCollectionDto dto);
    Task DeleteCollectionAsync(Guid collectionId, Guid userId);

    // Recipe-Collection management
    Task<CollectionRecipesResult> GetCollectionRecipesAsync(Guid collectionId, Guid userId, GetCollectionRecipesQuery? query = null);
    Task AddRecipeToCollectionAsync(Guid collectionId, Guid userId, AddRecipeToCollectionDto dto);
    Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId, Guid userId);

    // Collection membership
    Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId, Guid userId);
    Task AddMemberAsync(Guid collectionId, Guid userId, AddCollectionMemberDto dto);
    Task RemoveMemberAsync(Guid collectionId, Guid memberId, Guid userId);
    Task LeaveCollectionAsync(Guid collectionId, Guid userId);

    // Visibility check for recipes
    Task<bool> CanUserViewRecipeViaCollectionAsync(Guid recipeId, Guid userId);

    // Get collections shared by a friend that are visible to the current user
    Task<List<CollectionDto>> GetFriendSharedCollectionsAsync(Guid friendUserId, Guid currentUserId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ICollectionService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ICurrentUserService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface ICurrentUserService
{
    /// <summary>
    /// Gets the current authenticated user's email from JWT
    /// </summary>
    string? GetUserEmail();

    /// <summary>
    /// Gets the current authenticated user's Supabase UUID from JWT
    /// </summary>
    string? GetUserSubject();

    /// <summary>
    /// Gets or creates the user in the database and returns their ID
    /// </summary>
    Task<Guid> GetOrCreateUserIdAsync();

    /// <summary>
    /// Checks if user is authenticated
    /// </summary>
    bool IsAuthenticated();
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ICurrentUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IGlobalRecipeService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public interface IGlobalRecipeService
{
    Task<GlobalRecipe?> GetByIdAsync(Guid id);
    Task<GlobalRecipe?> GetByHellofreshUuidAsync(string uuid);
    Task<IEnumerable<GlobalRecipe>> GetPublicRecipesAsync(int skip = 0, int take = 50, string? sortBy = "rating");
    Task<GlobalRecipe> CreateAsync(GlobalRecipe recipe);
    Task<GlobalRecipe> UpdateAsync(GlobalRecipe recipe);
    Task<bool> DeleteAsync(Guid id);
    Task UpsertHellofreshRecipeAsync(GlobalRecipe recipe);
    Task<Dictionary<string, GlobalRecipe>> GetHellofreshRecipesByUuidsAsync(IEnumerable<string> uuids);
    Task BatchUpsertHellofreshRecipesAsync(IEnumerable<GlobalRecipe> recipes);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IGlobalRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IHelloFreshScraperService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface IHelloFreshScraperService
{
    Task<(int added, int updated)> SyncRecipesAsync();
    Task<(int added, int updated)> SyncWeekAsync(string week);
    Task<string> GetBuildIdAsync();
    Task<bool> ShouldRunSyncAsync();
    List<string> GenerateAvailableWeeks(int count = 8);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IHelloFreshScraperService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IRatingService.cs
================================================================================
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

public interface IRatingService
{
    Task<Rating?> GetUserRatingForRecipeAsync(Guid userId, Guid globalRecipeId);
    Task<IEnumerable<Rating>> GetRatingsForRecipeAsync(Guid globalRecipeId);
    Task<Rating> UpsertRatingAsync(Guid userId, Guid globalRecipeId, decimal score, string? comment = null);
    Task<bool> DeleteRatingAsync(Guid userId, Guid globalRecipeId);
    Task<List<UserRatingDto>> GetGlobalRecipeRatingsForUserAsync(Guid userId, int skip = 0, int take = 50);

}


================================================================================
FILE END: \StorhaugenEats.API\Services\IRatingService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IStorageService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface IStorageService
{
    Task<string> UploadImageAsync(Stream imageStream, string fileName, string folder = "recipes");
    Task<string> UploadImageFromUrlAsync(string imageUrl, string fileName, string folder = "recipes");
    Task<bool> DeleteImageAsync(string imageUrl);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IStorageService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ITagService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing personal recipe tags.
/// </summary>
public interface ITagService
{
    // Tag CRUD
    Task<List<TagDto>> GetUserTagsAsync(Guid userId);
    Task<TagDto?> GetTagAsync(Guid tagId, Guid userId);
    Task<TagDto> CreateTagAsync(Guid userId, CreateTagDto dto);
    Task<TagDto> UpdateTagAsync(Guid tagId, Guid userId, UpdateTagDto dto);
    Task DeleteTagAsync(Guid tagId, Guid userId);

    // Recipe-Tag management
    Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId, Guid userId);
    Task SetRecipeTagsAsync(Guid recipeId, Guid userId, List<Guid> tagIds);
    Task AddTagToRecipeAsync(Guid recipeId, Guid tagId, Guid userId);
    Task RemoveTagFromRecipeAsync(Guid recipeId, Guid tagId, Guid userId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ITagService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserFriendshipService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing user-to-user friendships.
/// </summary>
public interface IUserFriendshipService
{
    // Friendship queries
    Task<FriendshipListDto> GetFriendshipsAsync(Guid userId);
    Task<List<FriendProfileDto>> GetFriendsAsync(Guid userId);
    Task<UserFriendshipDto?> GetFriendshipAsync(Guid friendshipId, Guid userId);

    // Friend requests
    Task<UserFriendshipDto> SendFriendRequestAsync(Guid userId, SendFriendRequestDto dto);
    Task<UserFriendshipDto> RespondToRequestAsync(Guid friendshipId, Guid userId, string action);
    Task RemoveFriendshipAsync(Guid friendshipId, Guid userId);

    // Queries
    Task<List<UserSearchResultDto>> SearchUsersAsync(Guid userId, string query, int limit = 20);
    Task<FriendProfileDto?> GetUserProfileAsync(Guid profileUserId, Guid requestingUserId);

    // Helpers
    Task<bool> AreFriendsAsync(Guid userId1, Guid userId2);
    Task<List<Guid>> GetFriendIdsAsync(Guid userId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserRecipeService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing user-owned recipes.
/// </summary>
public interface IUserRecipeService
{
    // CRUD Operations
    Task<UserRecipePagedResult> GetUserRecipesAsync(Guid userId, GetUserRecipesQuery query);
    Task<UserRecipeDto?> GetRecipeAsync(Guid recipeId, Guid requestingUserId);
    Task<UserRecipeDto> CreateRecipeAsync(Guid userId, CreateUserRecipeDto dto);
    Task<UserRecipeDto> UpdateRecipeAsync(Guid recipeId, Guid userId, UpdateUserRecipeDto dto);
    Task DeleteRecipeAsync(Guid recipeId, Guid userId);

    // Publishing
    Task<PublishRecipeResultDto> PublishRecipeAsync(Guid recipeId, Guid userId);
    Task<UserRecipeDto> DetachRecipeAsync(Guid recipeId, Guid userId);

    // Rating
    Task<UserRecipeDto> RateRecipeAsync(Guid recipeId, Guid userId, decimal rating, string? comment = null);
    Task RemoveRatingAsync(Guid recipeId, Guid userId);

    // Archive
    Task<UserRecipeDto> ArchiveRecipeAsync(Guid recipeId, Guid userId);
    Task<UserRecipeDto> RestoreRecipeAsync(Guid recipeId, Guid userId);

    // Visibility checks
    Task<bool> CanUserViewRecipeAsync(Guid recipeId, Guid requestingUserId);

    // Friends' recipes
    Task<UserRecipePagedResult> GetFriendsRecipesAsync(Guid userId, GetUserRecipesQuery query);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public interface IUserService
{
    Task<User?> GetByIdAsync(Guid id);
    Task<User?> GetByEmailAsync(string email);
    Task<User?> GetByShareIdAsync(string shareId);
    Task<User> CreateAsync(Guid authUserId, string email, string displayName, string? avatarUrl = null);
    Task<User> UpdateAsync(User user);
    Task<string> GenerateUniqueShareIdAsync();
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\RatingService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;
using Supabase.Gotrue;

namespace StorhaugenEats.API.Services;

public class RatingService : IRatingService
{
    private readonly AppDbContext _context;

    public RatingService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Rating?> GetUserRatingForRecipeAsync(Guid userId, Guid globalRecipeId)
    {
        return await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserId == userId && r.GlobalRecipeId == globalRecipeId);
    }

    public async Task<IEnumerable<Rating>> GetRatingsForRecipeAsync(Guid globalRecipeId)
    {
        return await _context.Ratings
            .Include(r => r.User)
            .Where(r => r.GlobalRecipeId == globalRecipeId)
            .OrderByDescending(r => r.CreatedAt)
            .ToListAsync();
    }

    public async Task<Rating> UpsertRatingAsync(Guid userId, Guid globalRecipeId, decimal score, string? comment = null)
    {
        if (score < 0 || score > 10)
            throw new ArgumentException("Score must be between 0 and 10");

        var existing = await GetUserRatingForRecipeAsync(userId, globalRecipeId);

        if (existing != null)
        {
            existing.Score = score;
            existing.Comment = comment;
            existing.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return existing;
        }

        var rating = new Rating
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            GlobalRecipeId = globalRecipeId,
            Score = score,
            Comment = comment,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Ratings.Add(rating);
        await _context.SaveChangesAsync();

        // Note: The database trigger will automatically update global_recipes.average_rating

        return rating;
    }

    public async Task<bool> DeleteRatingAsync(Guid userId, Guid globalRecipeId)
    {
        var rating = await GetUserRatingForRecipeAsync(userId, globalRecipeId);
        if (rating == null) return false;

        _context.Ratings.Remove(rating);
        await _context.SaveChangesAsync();

        // Note: The database trigger will automatically update global_recipes.average_rating

        return true;
    }

    public async Task<List<UserRatingDto>> GetGlobalRecipeRatingsForUserAsync(Guid userId, int skip = 0, int take = 50)
    {
        return await _context.Ratings
            .AsNoTracking()
           .Where(r => r.UserId == userId && r.GlobalRecipeId != null)
            .OrderByDescending(r => r.UpdatedAt)
            .Skip(skip)
            .Take(take)
            .Select(r => new UserRatingDto
            {
                GlobalRecipeId = r.GlobalRecipeId!.Value,
                RecipeTitle = r.GlobalRecipe!.Title,
                ImageUrl = r.GlobalRecipe!.ImageUrl,
                Score = r.Score,
                Comment = r.Comment,
                RatedAt = r.UpdatedAt
            })
            .ToListAsync();
    }

}


================================================================================
FILE END: \StorhaugenEats.API\Services\RatingService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\SupabaseStorageService.cs
================================================================================
using Supabase;

namespace StorhaugenEats.API.Services;

public class SupabaseStorageService : IStorageService
{
    private readonly Client _supabaseClient;
    private readonly HttpClient _httpClient;
    private const string BucketName = "recipe-images";

    public SupabaseStorageService(Client supabaseClient, HttpClient httpClient)
    {
        _supabaseClient = supabaseClient;
        _httpClient = httpClient;
    }

    public async Task<string> UploadImageAsync(Stream imageStream, string fileName, string folder = "recipes")
    {
        var path = $"{folder}/{Guid.NewGuid()}_{fileName}";

        // Convert stream to byte array
        using var memoryStream = new MemoryStream();
        await imageStream.CopyToAsync(memoryStream);
        var bytes = memoryStream.ToArray();

        // Upload to Supabase Storage
        await _supabaseClient.Storage
            .From(BucketName)
            .Upload(bytes, path);

        // Get public URL
        var publicUrl = _supabaseClient.Storage
            .From(BucketName)
            .GetPublicUrl(path);

        return publicUrl;
    }

    public async Task<string> UploadImageFromUrlAsync(string imageUrl, string fileName, string folder = "recipes")
    {
        // Download image from URL
        var response = await _httpClient.GetAsync(imageUrl);
        response.EnsureSuccessStatusCode();

        using var stream = await response.Content.ReadAsStreamAsync();
        return await UploadImageAsync(stream, fileName, folder);
    }

    public async Task<bool> DeleteImageAsync(string imageUrl)
    {
        try
        {
            // Extract path from public URL
            var uri = new Uri(imageUrl);
            var pathSegments = uri.AbsolutePath.Split('/');
            var bucketIndex = Array.IndexOf(pathSegments, BucketName);

            if (bucketIndex == -1) return false;

            var path = string.Join("/", pathSegments.Skip(bucketIndex + 1));

            await _supabaseClient.Storage
                .From(BucketName)
                .Remove(path);

            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\SupabaseStorageService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\TagService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing personal recipe tags.
/// </summary>
public class TagService : ITagService
{
    private readonly AppDbContext _context;

    public TagService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<List<TagDto>> GetUserTagsAsync(Guid userId)
    {
        var tags = await _context.RecipeTags
            .Where(t => t.UserId == userId)
            .Select(t => new TagDto
            {
                Id = t.Id,
                Name = t.Name,
                Color = t.Color,
                Icon = t.Icon,
                RecipeCount = t.UserRecipeTags.Count,
                CreatedAt = t.CreatedAt
            })
            .OrderBy(t => t.Name)
            .ToListAsync();

        return tags;
    }

    public async Task<TagDto?> GetTagAsync(Guid tagId, Guid userId)
    {
        var tag = await _context.RecipeTags
            .Where(t => t.Id == tagId && t.UserId == userId)
            .Select(t => new TagDto
            {
                Id = t.Id,
                Name = t.Name,
                Color = t.Color,
                Icon = t.Icon,
                RecipeCount = t.UserRecipeTags.Count,
                CreatedAt = t.CreatedAt
            })
            .FirstOrDefaultAsync();

        return tag;
    }

    public async Task<TagDto> CreateTagAsync(Guid userId, CreateTagDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new InvalidOperationException("Tag name is required");

        // Check for duplicate name
        var exists = await _context.RecipeTags
            .AnyAsync(t => t.UserId == userId && t.Name.ToLower() == dto.Name.ToLower());

        if (exists)
            throw new InvalidOperationException($"A tag with name '{dto.Name}' already exists");

        var tag = new RecipeTag
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            Name = dto.Name.Trim(),
            Color = dto.Color,
            Icon = dto.Icon,
            CreatedAt = DateTime.UtcNow
        };

        _context.RecipeTags.Add(tag);
        await _context.SaveChangesAsync();

        return new TagDto
        {
            Id = tag.Id,
            Name = tag.Name,
            Color = tag.Color,
            Icon = tag.Icon,
            RecipeCount = 0,
            CreatedAt = tag.CreatedAt
        };
    }

    public async Task<TagDto> UpdateTagAsync(Guid tagId, Guid userId, UpdateTagDto dto)
    {
        var tag = await _context.RecipeTags
            .Include(t => t.UserRecipeTags)
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        if (!string.IsNullOrWhiteSpace(dto.Name))
        {
            // Check for duplicate name (excluding current tag)
            var exists = await _context.RecipeTags
                .AnyAsync(t => t.UserId == userId && t.Id != tagId && t.Name.ToLower() == dto.Name.ToLower());

            if (exists)
                throw new InvalidOperationException($"A tag with name '{dto.Name}' already exists");

            tag.Name = dto.Name.Trim();
        }

        if (dto.Color != null)
            tag.Color = dto.Color;

        if (dto.Icon != null)
            tag.Icon = dto.Icon;

        await _context.SaveChangesAsync();

        return new TagDto
        {
            Id = tag.Id,
            Name = tag.Name,
            Color = tag.Color,
            Icon = tag.Icon,
            RecipeCount = tag.UserRecipeTags.Count,
            CreatedAt = tag.CreatedAt
        };
    }

    public async Task DeleteTagAsync(Guid tagId, Guid userId)
    {
        var tag = await _context.RecipeTags
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        _context.RecipeTags.Remove(tag);
        await _context.SaveChangesAsync();
    }

    public async Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        var tags = await _context.UserRecipeTags
            .Where(rt => rt.UserRecipeId == recipeId)
            .Select(rt => new TagReferenceDto
            {
                Id = rt.Tag.Id,
                Name = rt.Tag.Name,
                Color = rt.Tag.Color
            })
            .ToListAsync();

        return tags;
    }

    public async Task SetRecipeTagsAsync(Guid recipeId, Guid userId, List<Guid> tagIds)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .Include(r => r.UserRecipeTags)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        // Verify all tags belong to user
        var validTagIds = await _context.RecipeTags
            .Where(t => t.UserId == userId && tagIds.Contains(t.Id))
            .Select(t => t.Id)
            .ToListAsync();

        // Remove existing tags
        _context.UserRecipeTags.RemoveRange(recipe.UserRecipeTags);

        // Add new tags
        foreach (var tagId in validTagIds)
        {
            recipe.UserRecipeTags.Add(new UserRecipeTag
            {
                Id = Guid.NewGuid(),
                UserRecipeId = recipeId,
                TagId = tagId,
                CreatedAt = DateTime.UtcNow
            });
        }

        await _context.SaveChangesAsync();
    }

    public async Task AddTagToRecipeAsync(Guid recipeId, Guid tagId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        // Verify tag belongs to user
        var tag = await _context.RecipeTags
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        // Check if already exists
        var exists = await _context.UserRecipeTags
            .AnyAsync(rt => rt.UserRecipeId == recipeId && rt.TagId == tagId);

        if (exists)
            return; // Already tagged

        _context.UserRecipeTags.Add(new UserRecipeTag
        {
            Id = Guid.NewGuid(),
            UserRecipeId = recipeId,
            TagId = tagId,
            CreatedAt = DateTime.UtcNow
        });

        await _context.SaveChangesAsync();
    }

    public async Task RemoveTagFromRecipeAsync(Guid recipeId, Guid tagId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        var recipeTag = await _context.UserRecipeTags
            .FirstOrDefaultAsync(rt => rt.UserRecipeId == recipeId && rt.TagId == tagId);

        if (recipeTag != null)
        {
            _context.UserRecipeTags.Remove(recipeTag);
            await _context.SaveChangesAsync();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\TagService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserFriendshipService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class UserFriendshipService : IUserFriendshipService
{
    private readonly AppDbContext _context;

    public UserFriendshipService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<FriendshipListDto> GetFriendshipsAsync(Guid userId)
    {
        var friendships = await _context.UserFriendships
            .Include(f => f.RequesterUser)
            .Include(f => f.TargetUser)
            .Where(f => f.RequesterUserId == userId || f.TargetUserId == userId)
            .ToListAsync();

        var result = new FriendshipListDto();

        foreach (var friendship in friendships)
        {
            var isRequester = friendship.RequesterUserId == userId;
            var otherUser = isRequester ? friendship.TargetUser : friendship.RequesterUser;

            var recipeCount = await _context.UserRecipes
                .CountAsync(r => r.UserId == otherUser.Id && !r.IsArchived);

            var dto = new UserFriendshipDto
            {
                Id = friendship.Id,
                FriendUserId = otherUser.Id,
                FriendDisplayName = otherUser.DisplayName,
                FriendAvatarUrl = otherUser.AvatarUrl,
                FriendShareId = otherUser.UniqueShareId,
                Message = friendship.Message,
                CreatedAt = friendship.CreatedAt,
                RespondedAt = friendship.RespondedAt,
                RecipeCount = recipeCount
            };

            if (friendship.Status == "accepted")
            {
                dto.Status = "accepted";
                result.Friends.Add(dto);
            }
            else if (friendship.Status == "pending")
            {
                if (isRequester)
                {
                    dto.Status = "pending_sent";
                    result.PendingSent.Add(dto);
                }
                else
                {
                    dto.Status = "pending_received";
                    result.PendingReceived.Add(dto);
                }
            }
        }

        return result;
    }

    public async Task<List<FriendProfileDto>> GetFriendsAsync(Guid userId)
    {
        var friendIds = await GetFriendIdsAsync(userId);

        var friends = await _context.Users
            .Where(u => friendIds.Contains(u.Id))
            .ToListAsync();

        var result = new List<FriendProfileDto>();
        foreach (var friend in friends)
        {
            var recipeCount = await _context.UserRecipes
                .CountAsync(r => r.UserId == friend.Id && !r.IsArchived);

            result.Add(new FriendProfileDto
            {
                Id = friend.Id,
                DisplayName = friend.DisplayName,
                AvatarUrl = friend.AvatarUrl,
                ShareId = friend.UniqueShareId,
                Bio = friend.Bio,
                IsProfilePublic = friend.IsProfilePublic,
                FavoriteCuisines = ParseJsonList(friend.FavoriteCuisines),
                RecipeCount = recipeCount,
                JoinedAt = friend.CreatedAt
            });
        }

        return result;
    }

    public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid friendshipId, Guid userId)
    {
        var friendship = await _context.UserFriendships
            .Include(f => f.RequesterUser)
            .Include(f => f.TargetUser)
            .FirstOrDefaultAsync(f => f.Id == friendshipId &&
                (f.RequesterUserId == userId || f.TargetUserId == userId));

        if (friendship == null) return null;

        var isRequester = friendship.RequesterUserId == userId;
        var otherUser = isRequester ? friendship.TargetUser : friendship.RequesterUser;

        var recipeCount = await _context.UserRecipes
            .CountAsync(r => r.UserId == otherUser.Id && !r.IsArchived);

        string status = friendship.Status;
        if (friendship.Status == "pending")
        {
            status = isRequester ? "pending_sent" : "pending_received";
        }

        return new UserFriendshipDto
        {
            Id = friendship.Id,
            FriendUserId = otherUser.Id,
            FriendDisplayName = otherUser.DisplayName,
            FriendAvatarUrl = otherUser.AvatarUrl,
            FriendShareId = otherUser.UniqueShareId,
            Status = status,
            Message = friendship.Message,
            CreatedAt = friendship.CreatedAt,
            RespondedAt = friendship.RespondedAt,
            RecipeCount = recipeCount
        };
    }

    public async Task<UserFriendshipDto> SendFriendRequestAsync(Guid userId, SendFriendRequestDto dto)
    {
        Guid targetUserId;

        if (dto.TargetUserId.HasValue)
        {
            targetUserId = dto.TargetUserId.Value;
        }
        else if (!string.IsNullOrEmpty(dto.TargetShareId))
        {
            var targetUser = await _context.Users
                .FirstOrDefaultAsync(u => u.UniqueShareId == dto.TargetShareId)
                ?? throw new InvalidOperationException("User not found with that share ID");
            targetUserId = targetUser.Id;
        }
        else
        {
            throw new InvalidOperationException("Either TargetUserId or TargetShareId must be provided");
        }

        // Validate
        if (targetUserId == userId)
            throw new InvalidOperationException("You cannot send a friend request to yourself");

        // Check for existing friendship
        var existing = await _context.UserFriendships
            .FirstOrDefaultAsync(f =>
                (f.RequesterUserId == userId && f.TargetUserId == targetUserId) ||
                (f.RequesterUserId == targetUserId && f.TargetUserId == userId));

        if (existing != null)
        {
            if (existing.Status == "accepted")
                throw new InvalidOperationException("You are already friends");
            if (existing.Status == "pending")
                throw new InvalidOperationException("A friend request already exists");
            if (existing.Status == "blocked")
                throw new InvalidOperationException("Unable to send friend request");
        }

        var friendship = new UserFriendship
        {
            Id = Guid.NewGuid(),
            RequesterUserId = userId,
            TargetUserId = targetUserId,
            Status = "pending",
            Message = dto.Message,
            CreatedAt = DateTime.UtcNow
        };

        _context.UserFriendships.Add(friendship);
        await _context.SaveChangesAsync();

        return (await GetFriendshipAsync(friendship.Id, userId))!;
    }

    public async Task<UserFriendshipDto> RespondToRequestAsync(Guid friendshipId, Guid userId, string action)
    {
        var friendship = await _context.UserFriendships
            .FirstOrDefaultAsync(f => f.Id == friendshipId && f.TargetUserId == userId && f.Status == "pending")
            ?? throw new InvalidOperationException("Friend request not found or you cannot respond to it");

        action = action.ToLower();
        if (action != "accept" && action != "reject")
            throw new InvalidOperationException("Action must be 'accept' or 'reject'");

        friendship.Status = action == "accept" ? "accepted" : "rejected";
        friendship.RespondedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return (await GetFriendshipAsync(friendshipId, userId))!;
    }

    public async Task RemoveFriendshipAsync(Guid friendshipId, Guid userId)
    {
        var friendship = await _context.UserFriendships
            .FirstOrDefaultAsync(f => f.Id == friendshipId &&
                (f.RequesterUserId == userId || f.TargetUserId == userId))
            ?? throw new InvalidOperationException("Friendship not found");

        _context.UserFriendships.Remove(friendship);
        await _context.SaveChangesAsync();
    }

    public async Task<List<UserSearchResultDto>> SearchUsersAsync(Guid userId, string query, int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(query) || query.Length < 2)
            return new List<UserSearchResultDto>();

        query = query.ToLower();

        var users = await _context.Users
            .Where(u => u.Id != userId)
            .Where(u => u.IsProfilePublic)
            .Where(u =>
                u.DisplayName.ToLower().Contains(query) ||
                u.UniqueShareId.ToLower() == query ||
                u.Email.ToLower().Contains(query))
            .Take(limit)
            .ToListAsync();

        // Get friendship statuses
        var userIds = users.Select(u => u.Id).ToList();
        var friendships = await _context.UserFriendships
            .Where(f =>
                (f.RequesterUserId == userId && userIds.Contains(f.TargetUserId)) ||
                (f.TargetUserId == userId && userIds.Contains(f.RequesterUserId)))
            .ToListAsync();

        return users.Select(u =>
        {
            var friendship = friendships.FirstOrDefault(f =>
                (f.RequesterUserId == userId && f.TargetUserId == u.Id) ||
                (f.TargetUserId == userId && f.RequesterUserId == u.Id));

            string status = "none";
            if (friendship != null)
            {
                if (friendship.Status == "accepted")
                    status = "friends";
                else if (friendship.Status == "pending")
                    status = friendship.RequesterUserId == userId ? "pending_sent" : "pending_received";
            }

            return new UserSearchResultDto
            {
                Id = u.Id,
                DisplayName = u.DisplayName,
                AvatarUrl = u.AvatarUrl,
                ShareId = u.UniqueShareId,
                FriendshipStatus = status
            };
        }).ToList();
    }

    public async Task<FriendProfileDto?> GetUserProfileAsync(Guid profileUserId, Guid requestingUserId)
    {
        var user = await _context.Users.FindAsync(profileUserId);
        if (user == null) return null;

        // Check if profile is public or if they are friends
        var areFriends = await AreFriendsAsync(profileUserId, requestingUserId);
        if (!user.IsProfilePublic && !areFriends && profileUserId != requestingUserId)
            return null;

        var recipeCount = await _context.UserRecipes
            .CountAsync(r => r.UserId == profileUserId && !r.IsArchived &&
                (r.Visibility == "public" ||
                 (r.Visibility == "friends" && areFriends) ||
                 r.UserId == requestingUserId));

        return new FriendProfileDto
        {
            Id = user.Id,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            ShareId = user.UniqueShareId,
            Bio = user.Bio,
            IsProfilePublic = user.IsProfilePublic,
            FavoriteCuisines = ParseJsonList(user.FavoriteCuisines),
            RecipeCount = recipeCount,
            JoinedAt = user.CreatedAt
        };
    }

    public async Task<bool> AreFriendsAsync(Guid userId1, Guid userId2)
    {
        if (userId1 == userId2) return true; // User is always "friends" with themselves

        return await _context.UserFriendships
            .AnyAsync(f =>
                f.Status == "accepted" &&
                ((f.RequesterUserId == userId1 && f.TargetUserId == userId2) ||
                 (f.RequesterUserId == userId2 && f.TargetUserId == userId1)));
    }

    public async Task<List<Guid>> GetFriendIdsAsync(Guid userId)
    {
        var friendships = await _context.UserFriendships
            .Where(f => f.Status == "accepted")
            .Where(f => f.RequesterUserId == userId || f.TargetUserId == userId)
            .ToListAsync();

        return friendships
            .Select(f => f.RequesterUserId == userId ? f.TargetUserId : f.RequesterUserId)
            .Distinct()
            .ToList();
    }

    private static List<string> ParseJsonList(string json)
    {
        try
        {
            return System.Text.Json.JsonSerializer.Deserialize<List<string>>(json) ?? new();
        }
        catch
        {
            return new List<string>();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\UserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserRecipeService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using System.Text.Json;

namespace StorhaugenEats.API.Services;

public class UserRecipeService : IUserRecipeService
{
    private readonly AppDbContext _context;
    private readonly IActivityFeedService _activityFeedService;
    private readonly IUserFriendshipService _friendshipService;
    private readonly ICollectionService _collectionService;

    public UserRecipeService(
        AppDbContext context,
        IActivityFeedService activityFeedService,
        IUserFriendshipService friendshipService,
        ICollectionService collectionService)
    {
        _context = context;
        _activityFeedService = activityFeedService;
        _friendshipService = friendshipService;
        _collectionService = collectionService;
    }

    public async Task<UserRecipePagedResult> GetUserRecipesAsync(Guid userId, GetUserRecipesQuery query)
    {
        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
            .Include(r => r.UserRecipeTags)
                .ThenInclude(rt => rt.Tag)
            .Where(r => r.UserId == userId);

        if (!query.IncludeArchived)
        {
            queryable = queryable.Where(r => !r.IsArchived);
        }

        if (!string.IsNullOrEmpty(query.Visibility) && query.Visibility != "all")
        {
            queryable = queryable.Where(r => r.Visibility == query.Visibility);
        }

        // Search filter
        if (!string.IsNullOrWhiteSpace(query.Search))
        {
            var searchLower = query.Search.ToLower();
            queryable = queryable.Where(r =>
                (r.LocalTitle != null && r.LocalTitle.ToLower().Contains(searchLower)) ||
                (r.GlobalRecipe != null && r.GlobalRecipe.Title.ToLower().Contains(searchLower)) ||
                (r.LocalDescription != null && r.LocalDescription.ToLower().Contains(searchLower)));
        }

        // Tag filter
        if (query.TagIds != null && query.TagIds.Count > 0)
        {
            queryable = queryable.Where(r => r.UserRecipeTags.Any(rt => query.TagIds.Contains(rt.TagId)));
        }

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "name" => query.SortDescending
                ? queryable.OrderByDescending(r => r.LocalTitle ?? r.GlobalRecipe!.Title)
                : queryable.OrderBy(r => r.LocalTitle ?? r.GlobalRecipe!.Title),
            "rating" => query.SortDescending
                ? queryable.OrderByDescending(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0)
                : queryable.OrderBy(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0),
            _ => query.SortDescending
                ? queryable.OrderByDescending(r => r.CreatedAt)
                : queryable.OrderBy(r => r.CreatedAt)
        };

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new UserRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToDto(r, userId)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<UserRecipeDto?> GetRecipeAsync(Guid recipeId, Guid requestingUserId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .FirstOrDefaultAsync(r => r.Id == recipeId);

        if (recipe == null) return null;

        // Check visibility
        if (!await CanUserViewRecipeAsync(recipeId, requestingUserId))
            return null;

        return MapToDto(recipe, requestingUserId);
    }

    public async Task<UserRecipeDto> CreateRecipeAsync(Guid userId, CreateUserRecipeDto dto)
    {
        // 1) Validate user exists
        var userExists = await _context.Users.AnyAsync(u => u.Id == userId);
        if (!userExists)
            throw new InvalidOperationException("User not found");

        // 2) Idempotency: if adding a GlobalRecipe, return existing (or restore if archived)
        if (dto.GlobalRecipeId.HasValue)
        {
            var existing = await _context.UserRecipes
                .Include(r => r.User)
                .Include(r => r.GlobalRecipe)
                .Include(r => r.Ratings).ThenInclude(rt => rt.User)
                .FirstOrDefaultAsync(r => r.UserId == userId && r.GlobalRecipeId == dto.GlobalRecipeId.Value);

            if (existing != null)
            {
                // If it exists but is archived, restore it (treat as "added back")
                if (existing.IsArchived)
                {
                    existing.IsArchived = false;
                    existing.ArchivedDate = null;
                    existing.UpdatedAt = DateTime.UtcNow;
                    await _context.SaveChangesAsync();

                    // record activity (optional, but usually nice UX)
                    var img = dto.ImageUrls?.FirstOrDefault()
                              ?? existing.GlobalRecipe?.ImageUrl
                              ?? existing.LocalImageUrl;

                    await _activityFeedService.RecordAddedRecipeActivityAsync(
                        userId, existing.Id, existing.DisplayTitle, img);
                }

                return MapToDto(existing, userId);
            }
        }

        var now = DateTime.UtcNow;

        await using var tx = await _context.Database.BeginTransactionAsync();
        try
        {
            // 3) Create new user recipe
            var recipe = new UserRecipe
            {
                Id = Guid.NewGuid(),
                UserId = userId,
                GlobalRecipeId = dto.GlobalRecipeId,

                LocalTitle = dto.Name,
                LocalDescription = dto.Description,
                LocalIngredients = dto.Ingredients != null ? JsonSerializer.Serialize(dto.Ingredients) : null,
                LocalImageUrls = dto.ImageUrls != null ? JsonSerializer.Serialize(dto.ImageUrls) : "[]",
                PersonalNotes = dto.PersonalNotes,
                Visibility = dto.Visibility ?? "private",

                // Local metadata fields
                LocalPrepTimeMinutes = dto.PrepTimeMinutes,
                LocalCookTimeMinutes = dto.CookTimeMinutes,
                LocalServings = dto.Servings,
                LocalDifficulty = dto.Difficulty,
                LocalCuisine = dto.Cuisine,

                CreatedAt = now,
                UpdatedAt = now
            };

            _context.UserRecipes.Add(recipe);

            // 4) Increment global usage count (atomic) ONLY if we are actually inserting successfully
            if (dto.GlobalRecipeId.HasValue)
            {
                var affected = await _context.Database.ExecuteSqlInterpolatedAsync($@"
                UPDATE global_recipes
                SET total_times_added = total_times_added + 1
                WHERE id = {dto.GlobalRecipeId.Value};
            ");

                if (affected == 0)
                    throw new InvalidOperationException("Global recipe not found");
            }

            await _context.SaveChangesAsync();

            // 5) Optional: initial rating from creator only (keeps your existing rule)
            if (dto.MemberRatings != null && dto.MemberRatings.Any())
            {
                var ratingsToAdd = dto.MemberRatings
                    .Where(kvp => kvp.Key == userId)
                    .Select(kvp => new Rating
                    {
                        Id = Guid.NewGuid(),
                        UserRecipeId = recipe.Id,
                        GlobalRecipeId = recipe.GlobalRecipeId,
                        UserId = kvp.Key,
                        Score = Math.Clamp(kvp.Value, 0m, 10m),
                        CreatedAt = now,
                        UpdatedAt = now
                    })
                    .ToList();

                if (ratingsToAdd.Any())
                {
                    _context.Ratings.AddRange(ratingsToAdd);
                    await _context.SaveChangesAsync();

                    if (recipe.GlobalRecipeId.HasValue)
                    {
                        await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
                        await _context.SaveChangesAsync(); // <-- important if UpdateGlobalRecipeRatingAsync sets fields
                    }
                }
            }

            await tx.CommitAsync();

            // 6) Load with includes for DTO + activity text/image
            var createdRecipe = await _context.UserRecipes
                .Include(r => r.User)
                .Include(r => r.GlobalRecipe)
                .Include(r => r.Ratings).ThenInclude(rt => rt.User)
                .FirstAsync(r => r.Id == recipe.Id);

            var imageForActivity = dto.ImageUrls?.FirstOrDefault()
                                  ?? createdRecipe.GlobalRecipe?.ImageUrl
                                  ?? createdRecipe.LocalImageUrl;

            await _activityFeedService.RecordAddedRecipeActivityAsync(
                userId, createdRecipe.Id, createdRecipe.DisplayTitle, imageForActivity);

            return MapToDto(createdRecipe, userId);
        }
        catch (DbUpdateException ex)
            when (ex.InnerException is Npgsql.PostgresException pg
                  && pg.SqlState == Npgsql.PostgresErrorCodes.UniqueViolation)
        {
            await tx.RollbackAsync();

            // If the insert raced / double-clicked, return the existing row (idempotent behavior)
            if (dto.GlobalRecipeId.HasValue)
            {
                var existing = await _context.UserRecipes
                    .Include(r => r.User)
                    .Include(r => r.GlobalRecipe)
                    .Include(r => r.Ratings).ThenInclude(rt => rt.User)
                    .FirstOrDefaultAsync(r => r.UserId == userId && r.GlobalRecipeId == dto.GlobalRecipeId.Value);

                if (existing != null)
                    return MapToDto(existing, userId);
            }

            throw;
        }
        catch
        {
            await tx.RollbackAsync();
            throw;
        }
    }


    public async Task<UserRecipeDto> UpdateRecipeAsync(Guid recipeId, Guid userId, UpdateUserRecipeDto dto)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission to edit it");

        // Check if recipe is published - published recipes cannot be edited (only deleted)
        bool isPublished = recipe.GlobalRecipe?.PublishedFromUserRecipeId == recipe.Id;
        if (isPublished)
        {
            // Only allow personal notes and visibility changes on published recipes
            if (dto.PersonalNotes != null) recipe.PersonalNotes = dto.PersonalNotes;
            if (dto.Visibility != null) recipe.Visibility = dto.Visibility;
            recipe.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return MapToDto(recipe, userId);
        }

        // Check if recipe is HelloFresh - HelloFresh recipes have restrictions
        bool isHelloFresh = recipe.GlobalRecipe?.IsHellofresh ?? false;

        // Basic fields - always editable for non-published recipes
        if (dto.Name != null) recipe.LocalTitle = dto.Name;
        if (dto.Description != null) recipe.LocalDescription = dto.Description;
        if (dto.Ingredients != null) recipe.LocalIngredients = JsonSerializer.Serialize(dto.Ingredients);
        if (dto.ImageUrls != null) recipe.LocalImageUrls = JsonSerializer.Serialize(dto.ImageUrls);
        if (dto.PersonalNotes != null) recipe.PersonalNotes = dto.PersonalNotes;
        if (dto.Visibility != null) recipe.Visibility = dto.Visibility;

        // Metadata fields - only editable for non-HelloFresh recipes
        if (!isHelloFresh)
        {
            if (dto.PrepTimeMinutes.HasValue) recipe.LocalPrepTimeMinutes = dto.PrepTimeMinutes;
            if (dto.CookTimeMinutes.HasValue) recipe.LocalCookTimeMinutes = dto.CookTimeMinutes;
            if (dto.Servings.HasValue) recipe.LocalServings = dto.Servings;
            if (dto.Difficulty != null) recipe.LocalDifficulty = dto.Difficulty;
            if (dto.Cuisine != null) recipe.LocalCuisine = dto.Cuisine;
        }

        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task DeleteRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission to delete it");

        _context.UserRecipes.Remove(recipe);
        await _context.SaveChangesAsync();
    }

    public async Task<PublishRecipeResultDto> PublishRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission");

        if (recipe.GlobalRecipeId.HasValue)
            throw new InvalidOperationException("This recipe is already linked to a global recipe");

        var globalRecipe = new GlobalRecipe
        {
            Id = Guid.NewGuid(),
            Title = recipe.LocalTitle ?? "Untitled Recipe",
            Description = recipe.LocalDescription,
            ImageUrl = recipe.LocalImageUrl,
            ImageUrls = recipe.LocalImageUrls ?? "[]",
            Ingredients = recipe.LocalIngredients ?? "[]",

            // Metadata fields
            PrepTimeMinutes = recipe.LocalPrepTimeMinutes,
            CookTimeMinutes = recipe.LocalCookTimeMinutes,
            TotalTimeMinutes = (recipe.LocalPrepTimeMinutes ?? 0) + (recipe.LocalCookTimeMinutes ?? 0) > 0
                ? (recipe.LocalPrepTimeMinutes ?? 0) + (recipe.LocalCookTimeMinutes ?? 0)
                : null,
            Servings = recipe.LocalServings,
            Difficulty = recipe.LocalDifficulty,
            Cuisine = recipe.LocalCuisine,

            CreatedByUserId = userId,
            IsPublic = true,
            IsHellofresh = false,
            IsEditable = false,
            PublishedFromUserRecipeId = recipe.Id,
            TotalTimesAdded = 1,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.GlobalRecipes.Add(globalRecipe);

        recipe.GlobalRecipeId = globalRecipe.Id;
        recipe.Visibility = "public";
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        await _activityFeedService.RecordPublishedActivityAsync(
            userId,
            globalRecipe.Id,
            globalRecipe.Title,
            globalRecipe.ImageUrl);

        return new PublishRecipeResultDto
        {
            UserRecipe = MapToDto(recipe, userId),
            GlobalRecipeId = globalRecipe.Id,
            Message = "Recipe published successfully!"
        };
    }

    public async Task<UserRecipeDto> DetachRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission");

        if (!recipe.GlobalRecipeId.HasValue)
            throw new InvalidOperationException("This recipe is not linked to a global recipe");

        if (recipe.GlobalRecipe != null)
        {
            recipe.LocalTitle ??= recipe.GlobalRecipe.Title;
            recipe.LocalDescription ??= recipe.GlobalRecipe.Description;
            recipe.LocalIngredients ??= recipe.GlobalRecipe.Ingredients;
            recipe.LocalImageUrl ??= recipe.GlobalRecipe.ImageUrl;
            recipe.LocalImageUrls = string.IsNullOrEmpty(recipe.LocalImageUrls) || recipe.LocalImageUrls == "[]"
                ? recipe.GlobalRecipe.ImageUrls
                : recipe.LocalImageUrls;
        }

        recipe.GlobalRecipeId = null;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        var updatedRecipe = await _context.UserRecipes
            .Include(r => r.User)
            .FirstAsync(r => r.Id == recipeId);

        return MapToDto(updatedRecipe, userId);
    }

    public async Task<UserRecipeDto> RateRecipeAsync(Guid recipeId, Guid userId, decimal rating, string? comment = null)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
            .FirstOrDefaultAsync(r => r.Id == recipeId)
            ?? throw new InvalidOperationException("Recipe not found");

        if (!await CanUserViewRecipeAsync(recipeId, userId))
            throw new InvalidOperationException("You don't have permission to rate this recipe");

        var existingRating = await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserRecipeId == recipeId && r.UserId == userId);

        if (existingRating != null)
        {
            existingRating.Score = rating;
            existingRating.Comment = comment;
            existingRating.UpdatedAt = DateTime.UtcNow;
        }
        else
        {
            var newRating = new Rating
            {
                Id = Guid.NewGuid(),
                UserRecipeId = recipeId,
                GlobalRecipeId = recipe.GlobalRecipeId,
                UserId = userId,
                Score = rating,
                Comment = comment,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            _context.Ratings.Add(newRating);
        }

        if (recipe.GlobalRecipeId.HasValue)
        {
            await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
        }

        await _context.SaveChangesAsync();

        await _activityFeedService.RecordRatingActivityAsync(
            userId,
            recipeId,
            recipe.DisplayTitle,
            rating,
            recipe.LocalImageUrl);

        var updatedRecipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .FirstAsync(r => r.Id == recipeId);

        return MapToDto(updatedRecipe, userId);
    }

    public async Task RemoveRatingAsync(Guid recipeId, Guid userId)
    {
        var rating = await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserRecipeId == recipeId && r.UserId == userId);

        if (rating != null)
        {
            _context.Ratings.Remove(rating);

            var recipe = await _context.UserRecipes.FindAsync(recipeId);
            if (recipe?.GlobalRecipeId.HasValue == true)
            {
                await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
            }

            await _context.SaveChangesAsync();
        }
    }

    public async Task<UserRecipeDto> ArchiveRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found");

        recipe.IsArchived = true;
        recipe.ArchivedDate = DateTime.UtcNow;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task<UserRecipeDto> RestoreRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found");

        recipe.IsArchived = false;
        recipe.ArchivedDate = null;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task<bool> CanUserViewRecipeAsync(Guid recipeId, Guid requestingUserId)
    {
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId);

        if (recipe == null) return false;

        if (recipe.UserId == requestingUserId) return true;

        // Check visibility
        var visibility = (recipe.Visibility ?? "private").Trim().ToLowerInvariant();

        if (visibility == "public") return true;

        if (visibility == "friends")
        {
            return await _friendshipService.AreFriendsAsync(recipe.UserId, requestingUserId);
        }

        // Treat anything else as private/legacy => allow if accessible through a viewable collection
        return await _collectionService.CanUserViewRecipeViaCollectionAsync(recipeId, requestingUserId);
    }

    public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(Guid userId, GetUserRecipesQuery query)
    {
        var friendIds = await _friendshipService.GetFriendIdsAsync(userId);

        if (!friendIds.Any())
        {
            return new UserRecipePagedResult
            {
                Recipes = new List<UserRecipeDto>(),
                TotalCount = 0,
                Page = query.Page,
                PageSize = query.PageSize,
            };
        }

        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .Where(r => friendIds.Contains(r.UserId))
            .Where(r => r.Visibility == "friends" || r.Visibility == "public")
            .Where(r => !r.IsArchived);

        queryable = queryable.OrderByDescending(r => r.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new UserRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToDto(r, userId)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize,
        };
    }

    private async Task UpdateGlobalRecipeRatingAsync(Guid globalRecipeId)
    {
        var ratings = await _context.Ratings
            .Where(r => r.GlobalRecipeId == globalRecipeId)
            .ToListAsync();

        var globalRecipe = await _context.GlobalRecipes.FindAsync(globalRecipeId);
        if (globalRecipe != null)
        {
            globalRecipe.RatingCount = ratings.Count;
            globalRecipe.TotalRatings = ratings.Count;
            globalRecipe.AverageRating = ratings.Any()
                ? (decimal)ratings.Average(r => r.Score)
                : 0;
        }
    }

    private UserRecipeDto MapToDto(UserRecipe recipe, Guid requestingUserId)
    {
        var imageUrls = new List<string>();
        try
        {
            if (!string.IsNullOrEmpty(recipe.LocalImageUrl))
            {
                imageUrls.Add(recipe.LocalImageUrl);
            }
            else if (!string.IsNullOrEmpty(recipe.LocalImageUrls) && recipe.LocalImageUrls != "[]")
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.LocalImageUrls) ?? new();
            }
            else if (recipe.GlobalRecipe != null && !string.IsNullOrEmpty(recipe.GlobalRecipe.ImageUrls))
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.GlobalRecipe.ImageUrls) ?? new();
            }
        }
        catch { }

        var myRating = recipe.Ratings?.FirstOrDefault(r => r.UserId == requestingUserId);

        // Exclude the requesting user's rating from memberRatings to avoid duplicates
        var memberRatings = recipe.Ratings?
            .Where(r => r.User != null && r.UserId != requestingUserId)
            .ToDictionary(r => r.User!.DisplayName, r => (decimal?)r.Score)
            ?? new Dictionary<string, decimal?>();

        // Parse recipe tags from GlobalRecipe
        var recipeTags = new List<string>();
        if (recipe.GlobalRecipe?.Tags != null)
        {
            try { recipeTags = JsonSerializer.Deserialize<List<string>>(recipe.GlobalRecipe.Tags) ?? new(); }
            catch { }
        }

        // Parse nutrition data from GlobalRecipe
        object? nutritionData = null;
        if (recipe.GlobalRecipe?.NutritionData != null)
        {
            try { nutritionData = JsonSerializer.Deserialize<object>(recipe.GlobalRecipe.NutritionData); }
            catch { }
        }

        return new UserRecipeDto
        {
            Id = recipe.Id,
            UserId = recipe.UserId,
            UserDisplayName = recipe.User?.DisplayName ?? "Unknown",
            UserAvatarUrl = recipe.User?.AvatarUrl,
            Name = recipe.LocalTitle ?? recipe.GlobalRecipe?.Title ?? "Untitled",
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = imageUrls,
            Ingredients = recipe.LocalIngredients != null
                ? JsonSerializer.Deserialize<object>(recipe.LocalIngredients)
                : (recipe.GlobalRecipe?.Ingredients != null
                    ? JsonSerializer.Deserialize<object>(recipe.GlobalRecipe.Ingredients)
                    : null),

            // Metadata - use local values if available, otherwise fall back to GlobalRecipe
            PrepTimeMinutes = recipe.LocalPrepTimeMinutes ?? recipe.GlobalRecipe?.PrepTimeMinutes,
            CookTimeMinutes = recipe.LocalCookTimeMinutes ?? recipe.GlobalRecipe?.CookTimeMinutes,
            Servings = recipe.LocalServings ?? recipe.GlobalRecipe?.Servings,
            Difficulty = recipe.LocalDifficulty ?? recipe.GlobalRecipe?.Difficulty,
            Cuisine = recipe.LocalCuisine ?? recipe.GlobalRecipe?.Cuisine,
            RecipeTags = recipeTags,
            NutritionData = nutritionData,
            IsHellofresh = recipe.GlobalRecipe?.IsHellofresh ?? false,
            HellofreshWeek = recipe.GlobalRecipe?.HellofreshWeek,

            GlobalRecipeId = recipe.GlobalRecipeId,
            GlobalRecipeName = recipe.GlobalRecipe?.Title,
            IsPublished = recipe.GlobalRecipe?.PublishedFromUserRecipeId == recipe.Id,
            Visibility = recipe.Visibility,
            PersonalNotes = recipe.PersonalNotes,
            IsArchived = recipe.IsArchived,
            CreatedAt = recipe.CreatedAt,
            UpdatedAt = recipe.UpdatedAt,
            MyRating = myRating?.Score,
            AverageRating = recipe.Ratings?.Any() == true ? (double)recipe.Ratings.Average(r => r.Score) : 0,
            RatingCount = recipe.Ratings?.Count ?? 0,
            MemberRatings = memberRatings
        };
    }
}

================================================================================
FILE END: \StorhaugenEats.API\Services\UserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class UserService : IUserService
{
    private readonly AppDbContext _context;

    public UserService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<User?> GetByIdAsync(Guid id)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Id == id);
    }

    public async Task<User?> GetByEmailAsync(string email)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Email == email);
    }

    public async Task<User?> GetByShareIdAsync(string shareId)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.UniqueShareId == shareId);
    }

    public async Task<User> CreateAsync(Guid authUserId, string email, string displayName, string? avatarUrl = null)
    {
        var shareId = await GenerateUniqueShareIdAsync();

        var user = new User
        {
            Id = authUserId, // Use Supabase Auth user ID
            Email = email,
            DisplayName = displayName,
            AvatarUrl = avatarUrl,
            UniqueShareId = shareId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return user;
    }

    public async Task<User> UpdateAsync(User user)
    {
        user.UpdatedAt = DateTime.UtcNow;
        _context.Users.Update(user);
        await _context.SaveChangesAsync();
        return user;
    }

    public async Task<string> GenerateUniqueShareIdAsync()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Exclude confusing chars
        var random = new Random();
        string shareId;

        do
        {
            shareId = new string(Enumerable.Range(0, 12)
                .Select(_ => chars[random.Next(chars.Length)])
                .ToArray());
        }
        while (await _context.Users.AnyAsync(u => u.UniqueShareId == shareId));

        return shareId;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\UserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\appsettings.json
================================================================================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Host=aws-1-eu-west-1.pooler.supabase.com;Port=5432;Database=postgres;Username=postgres.ithuvxvsoozmvdicxedx;Password=Elias25112099!;Timeout=300;CommandTimeout=300;Pooling=true;MinPoolSize=1;MaxPoolSize=20;SSL Mode=Require;Trust Server Certificate=true;Include Error Detail=true;Keepalive=30;TCP Keepalive=true;TCP Keepalive Time=30;TCP Keepalive Interval=10"
  },
  "Supabase": {
    "Url": "https://ithuvxvsoozmvdicxedx.supabase.co",
    "AnonKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0",
    "ServiceRoleKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NDk2MDU3MiwiZXhwIjoyMDgwNTM2NTcyfQ.U5W3C_LKYYlBkqUfjXfL9nxrWyDxG3PReVsqamfjOWY",
    "JwtSecret": "qlDo8dj/zFMRia+cZa5ZqOHI+zOc6YLPmk8BhLf6pzREOdpQt+xHhHH/2FxY0z+eygXNrahHu0ihk/VH5VPelA=="
  },
  "HelloFresh": {
    "BaseUrl": "https://www.hellofresh.no",
    "SyncIntervalHours": 24,
    "WeeksToFetch": 4
  }
}


================================================================================
FILE END: \StorhaugenEats.API\appsettings.json
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Program.cs
================================================================================
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Add configuration
builder.Configuration.AddEnvironmentVariables();
builder.Configuration.AddJsonFile("appsettings.json", optional: false);
builder.Configuration.AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database Context
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(connectionString));

// Supabase Client
builder.Services.AddSingleton(sp =>
{
    var url = builder.Configuration["Supabase:Url"] ?? throw new InvalidOperationException("Supabase URL not configured");
    var key = builder.Configuration["Supabase:ServiceRoleKey"] ?? throw new InvalidOperationException("Supabase Service Role Key not configured");

    var options = new Supabase.SupabaseOptions
    {
        AutoConnectRealtime = false // We don't need realtime in the API
    };

    return new Supabase.Client(url, key, options);
});

// HTTP Context Accessor (needed for CurrentUserService)
builder.Services.AddHttpContextAccessor();

// Application Services
builder.Services.AddScoped<ICurrentUserService, CurrentUserService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IGlobalRecipeService, GlobalRecipeService>();
builder.Services.AddScoped<IRatingService, RatingService>();
builder.Services.AddScoped<IStorageService, SupabaseStorageService>();
builder.Services.AddScoped<IHelloFreshScraperService, HelloFreshScraperService>();
// HTTP Client for scraper
builder.Services.AddHttpClient<IHelloFreshScraperService, HelloFreshScraperService>();

// New User-Centric Services
builder.Services.AddScoped<IUserFriendshipService, UserFriendshipService>();
builder.Services.AddScoped<IActivityFeedService, ActivityFeedService>();
builder.Services.AddScoped<IUserRecipeService, UserRecipeService>();
builder.Services.AddScoped<ITagService, TagService>();
builder.Services.AddScoped<ICollectionService, CollectionService>();

// JWT Authentication (Supabase JWT)
var jwtSecret = builder.Configuration["Supabase:JwtSecret"] ?? throw new InvalidOperationException("JWT Secret not configured");
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSecret)),
        ValidateIssuer = true,
        ValidIssuer = $"{builder.Configuration["Supabase:Url"]}/auth/v1",
        ValidateAudience = false,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero,
        NameClaimType = "email", // Map email claim to Name for easier access
        RoleClaimType = "role"
    };

    // Enable detailed logging for JWT validation failures (development only)
    options.Events = new JwtBearerEvents
    {
        OnAuthenticationFailed = context =>
        {
            if (builder.Environment.IsDevelopment())
            {
                Console.WriteLine($"JWT Authentication failed: {context.Exception.Message}");
            }
            return Task.CompletedTask;
        },
        OnTokenValidated = context =>
        {
            if (builder.Environment.IsDevelopment())
            {
                var email = context.Principal?.FindFirst("email")?.Value;
                Console.WriteLine($"JWT Token validated for user: {email}");
            }
            return Task.CompletedTask;
        }
    };
});

builder.Services.AddAuthorization();

// CORS (for Blazor WASM)
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowBlazorWasm", policy =>
    {
        var allowedOrigins = new List<string>
        {
            // Development - Frontend
            "https://localhost:7280",  // Frontend HTTPS
            "http://localhost:5055",   // Frontend HTTP
            "https://localhost:7000",
            "https://localhost:7001",
            "https://localhost:5001",
            "http://localhost:5000",
            "https://127.0.0.1:7280",
            "https://127.0.0.1:7000",
            "https://127.0.0.1:7001",

            // Production (GitHub Pages)
            "https://markus-sv.github.io"
        };

        // Add additional production URL from configuration if specified
        var productionUrl = builder.Configuration["Frontend:ProductionUrl"];
        if (!string.IsNullOrEmpty(productionUrl))
        {
            allowedOrigins.Add(productionUrl);
        }

        policy.WithOrigins(allowedOrigins.ToArray())
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

var app = builder.Build();

// Run database migrations on startup
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    try
    {
        var context = services.GetRequiredService<AppDbContext>();
        context.Database.Migrate();
        Console.WriteLine("✅ Database migrations applied successfully");
    }
    catch (Exception ex)
    {
        var logger = services.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "An error occurred while migrating the database");
        // Don't fail startup, just log the error
    }
}

// Configure the HTTP request pipeline
// Enable Swagger in all environments for easier testing
app.UseSwagger();
app.UseSwaggerUI();

app.UseHttpsRedirection();
app.UseCors("AllowBlazorWasm");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

// Health check endpoint
app.MapGet("/health", () => Results.Ok(new { status = "healthy", timestamp = DateTime.UtcNow }));

// Database connection test endpoint
app.MapGet("/test-connections", async (IConfiguration configuration) =>
{
    await StorhaugenEats.API.ConnectionTester.TestAllConnectionsAsync(configuration);
    return Results.Ok(new { message = "Check console output for connection test results" });
});

app.Run();


================================================================================
FILE END: \StorhaugenEats.API\Program.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\StorhaugenEats.API.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- ASP.NET Core -->
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />

    <!-- Entity Framework Core for PostgreSQL -->
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>

    <!-- Supabase Client -->
	  <PackageReference Include="MudBlazor" Version="8.15.0" />

	  <PackageReference Include="Supabase" Version="1.1.1" />
	  <PackageReference Include="Supabase.Gotrue" Version="6.0.3" />

    <!-- HTTP Client for HelloFresh scraper -->
    <PackageReference Include="HtmlAgilityPack" Version="1.12.4" />

    <!-- Authentication -->
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />

    <!-- JSON -->
    <PackageReference Include="System.Text.Json" Version="10.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenEats.API\StorhaugenEats.API.csproj
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\ApiClient\ApiClient.cs
================================================================================
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenWebsite.Services;

namespace StorhaugenWebsite.ApiClient;

public class ApiClient : IApiClient
{
    private readonly HttpClient _httpClient;
    private readonly IAuthService _authService;
    private readonly JsonSerializerOptions _jsonOptions;

    public ApiClient(HttpClient httpClient, IAuthService authService)
    {
        _httpClient = httpClient;
        _authService = authService;

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    private async Task AddAuthHeaderAsync()
    {
        var token = await _authService.GetAccessTokenAsync();

        if (string.IsNullOrWhiteSpace(token))
        {
            _httpClient.DefaultRequestHeaders.Authorization = null;
            return;
        }

        _httpClient.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Bearer", token);
    }


    // User Methods
    public async Task<UserDto?> GetMyProfileAsync()
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserDto>("/api/users/me", _jsonOptions);
    }

    public async Task<UserDto> UpdateMyProfileAsync(UpdateUserDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync("/api/users/me", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserDto>(_jsonOptions))!;
    }

    // Collection Methods
    public async Task<List<CollectionDto>> GetMyCollectionsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<CollectionDto>>("/api/collections", _jsonOptions)) ?? new();
    }

    public async Task<CollectionDto?> GetCollectionAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<CollectionDto>($"/api/collections/{id}", _jsonOptions);
    }

    public async Task<CollectionDto?> GetCollectionByShareCodeAsync(string shareCode)
    {
        await AddAuthHeaderAsync();
        try
        {
            return await _httpClient.GetFromJsonAsync<CollectionDto>($"/api/collections/shared/{shareCode}", _jsonOptions);
        }
        catch (HttpRequestException)
        {
            return null;
        }
    }

    public async Task<CollectionDto> CreateCollectionAsync(CreateCollectionDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/collections", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<CollectionDto>(_jsonOptions))!;
    }

    public async Task<CollectionDto> UpdateCollectionAsync(Guid id, UpdateCollectionDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/collections/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<CollectionDto>(_jsonOptions))!;
    }

    public async Task DeleteCollectionAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/collections/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<CollectionRecipesResult> GetCollectionRecipesAsync(Guid id, GetCollectionRecipesQuery? query = null)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();

        if (query != null)
        {
            if (!string.IsNullOrWhiteSpace(query.Search))
                queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

            queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
            queryParams.Add($"sortDescending={query.SortDescending}");
            queryParams.Add($"page={query.Page}");
            queryParams.Add($"pageSize={query.PageSize}");
        }

        var url = queryParams.Count > 0
            ? $"/api/collections/{id}/recipes?{string.Join("&", queryParams)}"
            : $"/api/collections/{id}/recipes";

        return (await _httpClient.GetFromJsonAsync<CollectionRecipesResult>(url, _jsonOptions))
            ?? new CollectionRecipesResult();
    }

    public async Task AddRecipeToCollectionAsync(Guid collectionId, AddRecipeToCollectionDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync($"/api/collections/{collectionId}/recipes", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }

    public async Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/collections/{collectionId}/recipes/{recipeId}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId)
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<CollectionMemberDto>>($"/api/collections/{collectionId}/members", _jsonOptions))
            ?? new List<CollectionMemberDto>();
    }

    public async Task AddCollectionMemberAsync(Guid collectionId, AddCollectionMemberDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync($"/api/collections/{collectionId}/members", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }

    public async Task RemoveCollectionMemberAsync(Guid collectionId, Guid memberId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/collections/{collectionId}/members/{memberId}");
        response.EnsureSuccessStatusCode();
    }

    public async Task LeaveCollectionAsync(Guid collectionId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/collections/{collectionId}/leave", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<CollectionDto>> GetFriendCollectionsAsync(Guid friendUserId)
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<CollectionDto>>($"/api/collections/friend/{friendUserId}", _jsonOptions))
            ?? new List<CollectionDto>();
    }

    // Global Recipe Methods
    public async Task<GlobalRecipePagedResult> BrowseGlobalRecipesAsync(BrowseGlobalRecipesQuery query)
    {
        var queryParams = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.Search))
            queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

        if (!string.IsNullOrWhiteSpace(query.Cuisine))
            queryParams.Add($"cuisine={Uri.EscapeDataString(query.Cuisine)}");

        if (!string.IsNullOrWhiteSpace(query.Difficulty))
            queryParams.Add($"difficulty={Uri.EscapeDataString(query.Difficulty)}");

        if (query.MaxPrepTime.HasValue)
            queryParams.Add($"maxPrepTime={query.MaxPrepTime.Value}");

        if (query.Tags != null && query.Tags.Count > 0)
        {
            foreach (var tag in query.Tags)
                queryParams.Add($"tags={Uri.EscapeDataString(tag)}");
        }

        if (query.HellofreshOnly)
            queryParams.Add("hellofreshOnly=true");

        if (!string.IsNullOrWhiteSpace(query.HellofreshWeek))
            queryParams.Add($"hellofreshWeek={Uri.EscapeDataString(query.HellofreshWeek)}");

        queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = $"/api/global-recipes?{string.Join("&", queryParams)}";

        return (await _httpClient.GetFromJsonAsync<GlobalRecipePagedResult>(url, _jsonOptions))
            ?? new GlobalRecipePagedResult();
    }

    public async Task<GlobalRecipeDto?> GetGlobalRecipeAsync(Guid id)
    {
        return await _httpClient.GetFromJsonAsync<GlobalRecipeDto>($"/api/global-recipes/{id}", _jsonOptions);
    }

    public async Task<List<GlobalRecipeDto>> SearchGlobalRecipesAsync(string query, int limit = 20)
    {
        var url = $"/api/global-recipes/search?q={Uri.EscapeDataString(query)}&limit={limit}";
        return (await _httpClient.GetFromJsonAsync<List<GlobalRecipeDto>>(url, _jsonOptions)) ?? new();
    }

    public async Task DeleteGlobalRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/global-recipes/{id}");
        response.EnsureSuccessStatusCode();
    }

    // Storage Methods
    public async Task<UploadImageResultDto> UploadImageAsync(byte[] imageData, string fileName)
    {
        await AddAuthHeaderAsync();

        var base64 = Convert.ToBase64String(imageData);
        var dto = new UploadImageDto
        {
            FileName = fileName,
            Base64Data = base64
        };

        var response = await _httpClient.PostAsJsonAsync("/api/storage/upload", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();

        return (await response.Content.ReadFromJsonAsync<UploadImageResultDto>(_jsonOptions))!;
    }

    public async Task DeleteImageAsync(string fileName)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/storage/{Uri.EscapeDataString(fileName)}");
        response.EnsureSuccessStatusCode();
    }

    // User Recipes (user-centric recipe management)
    public async Task<UserRecipePagedResult> GetMyUserRecipesAsync(GetUserRecipesQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.Visibility))
            queryParams.Add($"visibility={Uri.EscapeDataString(query.Visibility)}");

        if (query.IncludeArchived)
            queryParams.Add("includeArchived=true");

        if (!string.IsNullOrWhiteSpace(query.Search))
            queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

        if (query.TagIds != null && query.TagIds.Count > 0)
        {
            foreach (var tagId in query.TagIds)
                queryParams.Add($"tagIds={tagId}");
        }

        queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = $"/api/user-recipes?{string.Join("&", queryParams)}";
        return (await _httpClient.GetFromJsonAsync<UserRecipePagedResult>(url, _jsonOptions))
            ?? new UserRecipePagedResult();
    }

    public async Task<UserRecipeDto?> GetUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserRecipeDto>($"/api/user-recipes/{id}", _jsonOptions);
    }

    public async Task<UserRecipeDto> CreateUserRecipeAsync(CreateUserRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/user-recipes", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> UpdateUserRecipeAsync(Guid id, UpdateUserRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/user-recipes/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task DeleteUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/user-recipes/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<PublishRecipeResultDto> PublishUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/publish", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<PublishRecipeResultDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> DetachUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/detach", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> RateUserRecipeAsync(Guid id, decimal rating, string? comment = null)
    {
        await AddAuthHeaderAsync();
        var dto = new { Rating = rating, Comment = comment };
        var response = await _httpClient.PostAsJsonAsync($"/api/user-recipes/{id}/rate", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task RemoveUserRecipeRatingAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/user-recipes/{id}/rate");
        response.EnsureSuccessStatusCode();
    }

    public async Task<UserRecipeDto> ArchiveUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/archive", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> RestoreUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/restore", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();
        if (query.Page > 0) queryParams.Add($"page={query.Page}");
        if (query.PageSize > 0) queryParams.Add($"pageSize={query.PageSize}");

        var url = "/api/user-recipes/friends";
        if (queryParams.Any()) url += "?" + string.Join("&", queryParams);

        var response = await _httpClient.GetAsync(url);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipePagedResult>(_jsonOptions))!;
    }

    // User Friendships
    public async Task<FriendshipListDto> GetFriendshipsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<FriendshipListDto>("/api/friendships", _jsonOptions))
            ?? new FriendshipListDto();
    }

    public async Task<List<FriendProfileDto>> GetFriendsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<FriendProfileDto>>("/api/friendships/friends", _jsonOptions))
            ?? new List<FriendProfileDto>();
    }

    public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserFriendshipDto>($"/api/friendships/{id}", _jsonOptions);
    }

    public async Task<UserFriendshipDto> SendFriendRequestAsync(SendFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/friendships/request", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserFriendshipDto>(_jsonOptions))!;
    }

    public async Task<UserFriendshipDto> RespondToFriendRequestAsync(Guid id, RespondFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync($"/api/friendships/{id}/respond", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserFriendshipDto>(_jsonOptions))!;
    }

    public async Task RemoveFriendshipAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/friendships/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/friendships/search?query={Uri.EscapeDataString(query)}&limit={limit}";
        return (await _httpClient.GetFromJsonAsync<List<UserSearchResultDto>>(url, _jsonOptions))
            ?? new List<UserSearchResultDto>();
    }

    public async Task<FriendProfileDto?> GetUserProfileAsync(Guid userId)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<FriendProfileDto>($"/api/friendships/profile/{userId}", _jsonOptions);
    }

    // Activity Feed
    public async Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();

        if (query.Types != null && query.Types.Count > 0)
        {
            foreach (var type in query.Types)
                queryParams.Add($"Types={Uri.EscapeDataString(type)}");
        }

        if (query.UserIds != null && query.UserIds.Count > 0)
        {
            foreach (var friendId in query.UserIds)
                queryParams.Add($"friendIds={friendId}");
        }

        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = queryParams.Count > 0
            ? $"/api/feed?{string.Join("&", queryParams)}"
            : "/api/feed";

        return (await _httpClient.GetFromJsonAsync<ActivityFeedPagedResult>(url, _jsonOptions))
            ?? new ActivityFeedPagedResult();
    }

    public async Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/feed/my-activity?page={page}&pageSize={pageSize}";
        return (await _httpClient.GetFromJsonAsync<ActivityFeedPagedResult>(url, _jsonOptions))
            ?? new ActivityFeedPagedResult();
    }

    public async Task<ActivitySummaryDto> GetActivitySummaryAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<ActivitySummaryDto>("/api/feed/summary", _jsonOptions))
            ?? new ActivitySummaryDto();
    }

    public async Task<List<UserRatingDto>> GetUserRatingsAsync(Guid userId, int skip = 0, int take = 50)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/ratings/user/{userId}?skip={skip}&take={take}";
        return (await _httpClient.GetFromJsonAsync<List<UserRatingDto>>(url, _jsonOptions)) ?? new List<UserRatingDto>();
    }

    // Tags (Personal Recipe Organization)
    public async Task<List<TagDto>> GetMyTagsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<TagDto>>("/api/tags", _jsonOptions))
            ?? new List<TagDto>();
    }

    public async Task<TagDto?> GetTagAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        try
        {
            return await _httpClient.GetFromJsonAsync<TagDto>($"/api/tags/{id}", _jsonOptions);
        }
        catch (HttpRequestException)
        {
            return null;
        }
    }

    public async Task<TagDto> CreateTagAsync(CreateTagDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/tags", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<TagDto>(_jsonOptions))!;
    }

    public async Task<TagDto> UpdateTagAsync(Guid id, UpdateTagDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/tags/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<TagDto>(_jsonOptions))!;
    }

    public async Task DeleteTagAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/tags/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId)
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<TagReferenceDto>>($"/api/tags/recipe/{recipeId}", _jsonOptions))
            ?? new List<TagReferenceDto>();
    }

    public async Task SetRecipeTagsAsync(Guid recipeId, List<Guid> tagIds)
    {
        await AddAuthHeaderAsync();
        var dto = new UpdateRecipeTagsDto { TagIds = tagIds };
        var response = await _httpClient.PutAsJsonAsync($"/api/tags/recipe/{recipeId}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }

    // HelloFresh
    public async Task<HelloFreshRawResponse?> GetHelloFreshTestRawAsync()
    {
        return await _httpClient.GetFromJsonAsync<HelloFreshRawResponse>("/api/hellofresh/test-proxy", _jsonOptions);
    }

    public async Task<HelloFreshSyncResult> TriggerHelloFreshSyncAsync(bool force = false)
    {
        var url = force ? "/api/hellofresh/sync?force=true" : "/api/hellofresh/sync";
        var response = await _httpClient.PostAsync(url, null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HelloFreshSyncResult>(_jsonOptions))
            ?? new HelloFreshSyncResult { Message = "Unknown result" };
    }

    public async Task<HelloFreshSyncStatus?> GetHelloFreshSyncStatusAsync()
    {
        return await _httpClient.GetFromJsonAsync<HelloFreshSyncStatus>("/api/hellofresh/sync-status", _jsonOptions);
    }

    public async Task<List<string>> GetAvailableHelloFreshWeeksAsync()
    {
        return (await _httpClient.GetFromJsonAsync<List<string>>("/api/hellofresh/weeks", _jsonOptions))
            ?? new List<string>();
    }

    public async Task<List<string>> GetAvailableHelloFreshWeeksToFetchAsync()
    {
        return (await _httpClient.GetFromJsonAsync<List<string>>("/api/hellofresh/available-weeks", _jsonOptions))
            ?? new List<string>();
    }

    public async Task<HelloFreshSyncResult> SyncHelloFreshWeekAsync(string week)
    {
        var url = $"/api/hellofresh/sync-week?week={Uri.EscapeDataString(week)}";
        var response = await _httpClient.PostAsync(url, null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HelloFreshSyncResult>(_jsonOptions))
            ?? new HelloFreshSyncResult { Message = "Unknown result" };
    }
}


================================================================================
FILE END: \StorhaugenWebsite\ApiClient\ApiClient.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\ApiClient\IApiClient.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.ApiClient;

public interface IApiClient
{
    // User
    Task<UserDto?> GetMyProfileAsync();
    Task<UserDto> UpdateMyProfileAsync(UpdateUserDto dto);

    // Collections
    Task<List<CollectionDto>> GetMyCollectionsAsync();
    Task<CollectionDto?> GetCollectionAsync(Guid id);
    Task<CollectionDto?> GetCollectionByShareCodeAsync(string shareCode);
    Task<CollectionDto> CreateCollectionAsync(CreateCollectionDto dto);
    Task<CollectionDto> UpdateCollectionAsync(Guid id, UpdateCollectionDto dto);
    Task DeleteCollectionAsync(Guid id);
    Task<CollectionRecipesResult> GetCollectionRecipesAsync(Guid id, GetCollectionRecipesQuery? query = null);
    Task AddRecipeToCollectionAsync(Guid collectionId, AddRecipeToCollectionDto dto);
    Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId);
    Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId);
    Task AddCollectionMemberAsync(Guid collectionId, AddCollectionMemberDto dto);
    Task RemoveCollectionMemberAsync(Guid collectionId, Guid memberId);
    Task LeaveCollectionAsync(Guid collectionId);
    Task<List<CollectionDto>> GetFriendCollectionsAsync(Guid friendUserId);

    // Global Recipes
    Task<GlobalRecipePagedResult> BrowseGlobalRecipesAsync(BrowseGlobalRecipesQuery query);
    Task<GlobalRecipeDto?> GetGlobalRecipeAsync(Guid id);
    Task<List<GlobalRecipeDto>> SearchGlobalRecipesAsync(string query, int limit = 20);
    Task DeleteGlobalRecipeAsync(Guid id);

    // Storage
    Task<UploadImageResultDto> UploadImageAsync(byte[] imageData, string fileName);
    Task DeleteImageAsync(string fileName);

    // User Recipes (user-centric recipe management)
    Task<UserRecipePagedResult> GetMyUserRecipesAsync(GetUserRecipesQuery query);
    Task<UserRecipeDto?> GetUserRecipeAsync(Guid id);
    Task<UserRecipeDto> CreateUserRecipeAsync(CreateUserRecipeDto dto);
    Task<UserRecipeDto> UpdateUserRecipeAsync(Guid id, UpdateUserRecipeDto dto);
    Task DeleteUserRecipeAsync(Guid id);
    Task<PublishRecipeResultDto> PublishUserRecipeAsync(Guid id);
    Task<UserRecipeDto> DetachUserRecipeAsync(Guid id);
    Task<UserRecipeDto> RateUserRecipeAsync(Guid id, decimal rating, string? comment = null);
    Task RemoveUserRecipeRatingAsync(Guid id);
    Task<UserRecipeDto> ArchiveUserRecipeAsync(Guid id);
    Task<UserRecipeDto> RestoreUserRecipeAsync(Guid id);
    Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery query);

    // User Friendships
    Task<FriendshipListDto> GetFriendshipsAsync();
    Task<List<FriendProfileDto>> GetFriendsAsync();
    Task<UserFriendshipDto?> GetFriendshipAsync(Guid id);
    Task<UserFriendshipDto> SendFriendRequestAsync(SendFriendRequestDto dto);
    Task<UserFriendshipDto> RespondToFriendRequestAsync(Guid id, RespondFriendRequestDto action);
    Task RemoveFriendshipAsync(Guid id);
    Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20);
    Task<FriendProfileDto?> GetUserProfileAsync(Guid userId);

    // Activity Feed
    Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery query);
    Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20);
    Task<ActivitySummaryDto> GetActivitySummaryAsync();

    // Tags (personal recipe organization)
    Task<List<TagDto>> GetMyTagsAsync();
    Task<TagDto?> GetTagAsync(Guid id);
    Task<TagDto> CreateTagAsync(CreateTagDto dto);
    Task<TagDto> UpdateTagAsync(Guid id, UpdateTagDto dto);
    Task DeleteTagAsync(Guid id);
    Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId);
    Task SetRecipeTagsAsync(Guid recipeId, List<Guid> tagIds);

    // Ratings
    Task<List<UserRatingDto>> GetUserRatingsAsync(Guid userId, int skip = 0, int take = 50);

    // HelloFresh
    Task<HelloFreshRawResponse?> GetHelloFreshTestRawAsync();
    Task<HelloFreshSyncResult> TriggerHelloFreshSyncAsync(bool force = false);
    Task<HelloFreshSyncResult> SyncHelloFreshWeekAsync(string week);
    Task<HelloFreshSyncStatus?> GetHelloFreshSyncStatusAsync();
    Task<List<string>> GetAvailableHelloFreshWeeksAsync();
    Task<List<string>> GetAvailableHelloFreshWeeksToFetchAsync();
}


================================================================================
FILE END: \StorhaugenWebsite\ApiClient\IApiClient.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\ActivityFeed.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.Extensions
@inject IActivityFeedService FeedService
@inject IUserColorService UserColorService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<div class="activity-feed">
    <XFade IsLoading="@_isLoading" FirstLoadOnly="true" FadeMs="220">
        <Skeleton>
            <RecipeSkeleton Amount="5" Height="84px" DisableImage LineAmount="0" />
        </Skeleton>
        <ChildContent>

            @if (!_feedItems.Any())
            {
                <div class="empty-state">
                    <MudIcon Icon="@Icons.Material.Rounded.RssFeed" Size="Size.Large" Color="Color.Default" />
                    <MudText Typo="Typo.h6" Class="mt-2">Ingen aktivitet ennå</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        Legg til venner for å se hva de lager!
                    </MudText>
                    <MudButton Variant="Variant.Outlined" Color="Color.Primary" Href="friends" Class="mt-3">
                        Finn venner
                    </MudButton>
                </div>
            }
            else
            {
                <div class="d-flex flex-column gap-3">
                    @foreach (var item in _feedItems)
                    {
                        <MudPaper Class="@(IsItemClickable(item) ? "activity-card" : "activity-card non-clickable")"
                                  Elevation="0"
                                  @onclick="() => NavigateToRecipe(item)">

                            @if (!string.IsNullOrEmpty(item.RecipeImageUrl))
                            {
                                <div class="activity-image-layer">
                                    <img src="@item.RecipeImageUrl" alt="@item.RecipeName" loading="lazy" />
                                </div>
                            }

                            <div class="activity-content-layer">
                                <div class="d-flex gap-3 align-start">
                                    <MudAvatar Size="Size.Medium" Variant="Variant.Filled" Class="flex-shrink-0"
                                               Style="@($"background-color: {UserColorService.GetUserColor(item.UserDisplayName)}; color: white;")">
                                        @(item.UserDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                                    </MudAvatar>

                                    <div class="activity-text-container">
                                        <div class="d-flex align-center gap-2 flex-wrap mb-0">
                                            <MudText Typo="Typo.body2" Class="font-weight-bold user-name-text">
                                                @item.UserDisplayName
                                            </MudText>
                                            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="time-text">
                                                @GetTimeAgo(item.CreatedAt)
                                            </MudText>
                                        </div>

                                        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="action-text mb-1 d-block">
                                            @GetActivityDescription(item)
                                        </MudText>
                                    </div>
                                </div>

                                @if (!string.IsNullOrEmpty(item.RecipeName))
                                {
                                    <div class="recipe-row">
                                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" Class="recipe-icon" />
                                        <span class="recipe-name text-truncate">@item.RecipeName</span>
                                        @if (item.RatingScore.HasValue)
                                        {
                                            <span class="rating-dot" style="background-color: @(((double)item.RatingScore.Value).ToRatingColorHex())"></span>
                                            <span class="rating-val" style="color: @(((double)item.RatingScore.Value).ToRatingColorHex())">@item.RatingScore.Value.ToString("0.0")</span>
                                        }
                                    </div>
                                }
                            </div>
                        </MudPaper>
                    }
                </div>

                @if (_hasMorePages)
                {
                    <div class="d-flex justify-center mt-4">
                        <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="LoadMore" Disabled="_isLoadingMore">
                            @if (_isLoadingMore)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            }
                            Last inn mer
                        </MudButton>
                    </div>
                }
            }
        </ChildContent>
    </XFade>
</div>

<style>
    .user-name-text { font-size: 0.95rem; line-height: 1.2; }
    .time-text { font-size: 0.75rem; opacity: 0.8; }
    .action-text { font-size: 0.8rem; line-height: 1.2; }

    .recipe-row { display:flex; align-items:center; gap:6px; margin-top:8px; color: var(--mud-palette-text-primary); }
    .recipe-icon { font-size:14px; opacity:0.7; flex-shrink:0; }
    .recipe-name { font-weight:600; font-size:0.9rem; }
    .text-truncate { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .rating-dot { width:6px; height:6px; border-radius:50%; margin-left:2px; flex-shrink:0; }
    .rating-val { font-weight:700; font-size:0.8rem; flex-shrink:0; }

    .activity-text-container { flex:1; min-width:0; }
    .activity-content-layer { position:relative; padding:12px 16px; background: linear-gradient(to right, var(--mud-palette-surface) 60%, transparent 100%); }
</style>

@code {
    [Parameter] public bool ShowOnlyMyActivity { get; set; } = false;
    [Parameter] public int PageSize { get; set; } = 20;

    private readonly List<ActivityFeedItemDto> _feedItems = new();
    private bool _isLoading = true;

    private bool _isLoadingMore;
    private bool _hasMorePages;
    private int _currentPage = 1;

    private int _loadVersion;

    protected override Task OnInitializedAsync() => ReloadFeed(resetPage: true);

    private async Task ReloadFeed(bool resetPage)
    {
        var v = ++_loadVersion;

        if (resetPage)
            _currentPage = 1;

        _isLoading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            ActivityFeedPagedResult result =
                ShowOnlyMyActivity
                    ? await FeedService.GetMyActivityAsync(_currentPage, PageSize)
                    : await FeedService.GetFeedAsync(new ActivityFeedQuery { Page = _currentPage, PageSize = PageSize });

            if (v != _loadVersion) return;

            _feedItems.Clear();
            _feedItems.AddRange(DeduplicateRatings(result.Items));
            _hasMorePages = result.HasMore;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste aktivitetsfeed: {ex.Message}", Severity.Error);
        }
        finally
        {
            if (v == _loadVersion)
            {
                _isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadMore()
    {
        if (_isLoadingMore) return;

        _isLoadingMore = true;
        _currentPage++;
        StateHasChanged();

        try
        {
            ActivityFeedPagedResult result =
                ShowOnlyMyActivity
                    ? await FeedService.GetMyActivityAsync(_currentPage, PageSize)
                    : await FeedService.GetFeedAsync(new ActivityFeedQuery { Page = _currentPage, PageSize = PageSize });

            _feedItems.AddRange(result.Items);
            var deduped = DeduplicateRatings(_feedItems.ToList());

            _feedItems.Clear();
            _feedItems.AddRange(deduped);

            _hasMorePages = result.HasMore;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste mer: {ex.Message}", Severity.Error);
            _currentPage--;
        }
        finally
        {
            _isLoadingMore = false;
            StateHasChanged();
        }
    }

    private bool IsItemClickable(ActivityFeedItemDto item) => item.TargetType == "global_recipe";

    private void NavigateToRecipe(ActivityFeedItemDto item)
    {
        if (item.TargetType == "global_recipe")
            Navigation.NavigateTo($"browse/{item.TargetId}");
        else
            Snackbar.Add("Oppskriften er ikke tilgjengelig for visning", Severity.Info);
    }

    private string GetActivityDescription(ActivityFeedItemDto item) => item.ActivityType switch
    {
        "rated" => "ga en vurdering",
        "added" => "la til en ny oppskrift",
        "published" => "publiserte en oppskrift",
        "joined_collection" => "ble med i en samling",
        "friend_added" => $"ble venn med {item.UserDisplayName}",
        _ => item.ActivityType
    };

    private string GetTimeAgo(DateTime dateTime)
    {
        var diff = DateTime.UtcNow - dateTime;
        if (diff.TotalMinutes < 1) return "akkurat nå";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}t";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d";
        return dateTime.ToString("dd.MM");
    }

    private List<ActivityFeedItemDto> DeduplicateRatings(List<ActivityFeedItemDto> items)
    {
        var result = new List<ActivityFeedItemDto>();
        var seen = new HashSet<string>();

        foreach (var item in items)
        {
            if (item.ActivityType == "rated")
            {
                var key = $"{item.UserId}_{item.TargetId}";
                if (seen.Add(key)) result.Add(item);
            }
            else
            {
                result.Add(item);
            }
        }

        return result;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\ActivityFeed.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\AddMemberToCollectionDialog.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.ApiClient
@inject ICollectionStateService CollectionState
@inject IApiClient ApiClient
@inject ISnackbar Snackbar

<MudDialog>
    <TitleContent>
        <div class="d-flex align-center gap-2">
            <MudIcon Icon="@Icons.Material.Rounded.GroupAdd" Color="Color.Primary" />
            <MudText Typo="Typo.h6">Legg til i samling</MudText>
        </div>
    </TitleContent>
    <DialogContent>
        @if (_isProcessing)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                <MudText Typo="Typo.body1" Class="mt-4">Legger til...</MudText>
            </div>
        }
        else if (AvailableCollections.Any())
        {
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
                Velg hvilken samling du vil legge @UserDisplayName til:
            </MudText>
            <MudList T="CollectionDto" Class="py-0">
                @foreach (var collection in AvailableCollections)
                {
                    <MudListItem OnClick="@(() => AddToCollection(collection))">
                        <div class="d-flex align-center gap-3">
                            <MudIcon Icon="@Icons.Material.Rounded.FolderShared" Color="Color.Primary" />
                            <div>
                                <MudText Typo="Typo.body1">@collection.Name</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @collection.MemberCount medlemmer
                                </MudText>
                            </div>
                        </div>
                    </MudListItem>
                }
            </MudList>
        }
        else
        {
            <MudText Typo="Typo.body1" Color="Color.Secondary" Class="pa-4 text-center">
                Du har ingen samlinger du kan legge til medlemmer i.
            </MudText>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel" Color="Color.Default">Avbryt</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public List<CollectionDto> AvailableCollections { get; set; } = new();

    [Parameter]
    public string UserShareId { get; set; } = "";

    [Parameter]
    public string UserDisplayName { get; set; } = "";

    private bool _isProcessing = false;

    private async Task AddToCollection(CollectionDto collection)
    {
        _isProcessing = true;
        StateHasChanged();

        try
        {
            var dto = new AddCollectionMemberDto
            {
                UserIdentifier = UserShareId
            };

            await ApiClient.AddCollectionMemberAsync(collection.Id, dto);
            Snackbar.Add($"{UserDisplayName} lagt til i {collection.Name}!", Severity.Success);
            MudDialog.Close(DialogResult.Ok(collection));
        }
        catch (Exception ex)
        {
            if (ex.Message.Contains("already"))
                Snackbar.Add("Brukeren er allerede medlem.", Severity.Warning);
            else
                Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
            _isProcessing = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\AddMemberToCollectionDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\AddToCollectionDialog.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject ICollectionStateService CollectionState
@inject ISnackbar Snackbar

<MudDialog>
    <TitleContent>
        <div class="d-flex align-center gap-2">
            <MudIcon Icon="@Icons.Material.Rounded.FolderShared" Color="Color.Primary" />
            <MudText Typo="Typo.h6">Legg til i samling</MudText>
        </div>
    </TitleContent>
    <DialogContent>
        @if (_isProcessing)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                <MudText Typo="Typo.body1" Class="mt-4">Legger til...</MudText>
            </div>
        }
        else if (AvailableCollections.Any())
        {
            <MudList T="CollectionDto" Class="py-0">
                @foreach (var collection in AvailableCollections)
                {
                    <MudListItem OnClick="@(() => AddToCollection(collection))">
                        <div class="d-flex align-center gap-3">
                            <MudIcon Icon="@Icons.Material.Rounded.Folder" Color="Color.Primary" />
                            <div>
                                <MudText Typo="Typo.body1">@collection.Name</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @collection.RecipeCount oppskrifter
                                </MudText>
                            </div>
                        </div>
                    </MudListItem>
                }
            </MudList>
        }
        else
        {
            <MudText Typo="Typo.body1" Color="Color.Secondary" Class="pa-4 text-center">
                Ingen tilgjengelige samlinger
            </MudText>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel" Color="Color.Default">Avbryt</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public List<CollectionDto> AvailableCollections { get; set; } = new();

    [Parameter]
    public Guid RecipeId { get; set; }

    private bool _isProcessing = false;

    private async Task AddToCollection(CollectionDto collection)
    {
        _isProcessing = true;
        StateHasChanged();

        try
        {
            await CollectionState.AddRecipeToCollectionAsync(collection.Id, RecipeId);
            Snackbar.Add($"Lagt til i {collection.Name}", Severity.Success);
            MudDialog.Close(DialogResult.Ok(collection));
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
            _isProcessing = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\AddToCollectionDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\CollectionRecipesList.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<div style="margin-bottom: 16px; border-top: 1px solid var(--mud-palette-divider); padding-top: 12px;">
    <div class="d-flex justify-space-between align-center mb-3">
        <p class="form-section-title" style="margin: 0;">
            @Title
            @if (_totalCount > 0)
            {
                <span>(@_totalCount)</span>
            }
        </p>
    </div>

    @* Search & Sort *@
    <div class="d-flex gap-2 mb-3">
        <MudTextField @bind-Value="_searchQuery"
                      Placeholder="Søk i samlingen..."
                      Variant="Variant.Outlined"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Rounded.Search"
                      Immediate="true"
                      DebounceInterval="300"
                      OnDebounceIntervalElapsed="HandleSearchDebounce"
                      Class="flex-grow-1 search-field"
                      Margin="Margin.Dense" />

        <MudSelect T="string"
                   Value="_sortBy"
                   ValueChanged="HandleSortChanged"
                   AnchorOrigin="Origin.BottomRight"
                   Variant="Variant.Outlined"
                   Margin="Margin.Dense"
                   Class="sort-select"
                   Style="width: 160px;"
                   AdornmentIcon="@Icons.Material.Rounded.Sort">
            <MudSelectItem Value="@("added")">Sist lagt til</MudSelectItem>
            <MudSelectItem Value="@("date")">Nyeste</MudSelectItem>
            <MudSelectItem Value="@("rating")">Høyest snitt</MudSelectItem>
            <MudSelectItem Value="@("name")">Navn (A-Å)</MudSelectItem>
        </MudSelect>
    </div>

    @if (_isLoading && !_recipes.Any())
    {
        <div class="d-flex justify-center my-6">
            <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
        </div>
    }
    else if (!_recipes.Any())
    {
        <div class="text-center pa-4">
            <MudIcon Icon="@Icons.Material.Rounded.MenuBook" Size="Size.Large" Color="Color.Default" Style="opacity: 0.5;" />
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2">
                Ingen oppskrifter i denne samlingen
            </MudText>
        </div>
    }
    else
    {
        <div class="d-flex flex-column gap-3">
            @foreach (var recipe in _recipes)
            {
                <div class="food-card animate-in" @onclick="() => OpenRecipe(recipe.Id)">
                    @* Image Section (Right Side) *@
                    @if (recipe.ImageUrls.Any())
                    {
                        <img src="@recipe.ImageUrls.First()" class="food-card-image" />
                    }
                    else
                    {
                        <div class="food-card-placeholder">
                            <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Large" Style="opacity:0.3;" />
                        </div>
                    }

                    @* Content Section (Left Side) *@
                    <div class="food-card-content">

                        @* Top Row: Title & Average Badge *@
                        <div class="d-flex justify-space-between align-start">
                            <div style="min-width: 0; padding-right: 8px;">
                                <div class="d-flex align-center gap-1 mb-1">
                                    @if (recipe.IsHellofresh)
                                    {
                                        <MudIcon Icon="@Icons.Material.Rounded.LocalDining"
                                                 Size="Size.Small"
                                                 Color="Color.Success"
                                                 Title="HelloFresh"
                                                 Style="flex-shrink: 0; font-size: 14px;" />
                                    }
                                    <h3 class="food-card-title text-truncate">@recipe.Name</h3>
                                </div>
                                <div class="d-flex align-center gap-1">
                                    <MudIcon Icon="@Icons.Material.Rounded.Person" Size="Size.Small" Style="font-size: 12px; opacity: 0.6;" />
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="text-truncate" Style="font-size: 0.75rem;">
                                        @recipe.UserDisplayName
                                    </MudText>
                                </div>
                            </div>

                            @if (recipe.AverageRating > 0)
                            {
                                <div class="d-flex flex-column align-end" style="flex-shrink: 0;">
                                    <span class="rating-badge" style="color: @GetScoreColor(recipe.AverageRating);">
                                        <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" Style="font-size: 14px; margin-right:2px;" />
                                        @recipe.AverageRating.ToString("0.0")
                                    </span>
                                </div>
                            }
                        </div>

                        @* Metadata Row *@
                        @if (recipe.PrepTimeMinutes.HasValue || !string.IsNullOrEmpty(recipe.Difficulty) || recipe.Servings.HasValue)
                        {
                            <div class="d-flex align-center flex-wrap mt-2 gap-2">
                                @if (recipe.PrepTimeMinutes.HasValue)
                                {
                                    <span class="meta-chip">
                                        <MudIcon Icon="@Icons.Material.Rounded.AccessTime" Size="Size.Small" />
                                        @recipe.PrepTimeMinutes min
                                    </span>
                                }
                                @if (!string.IsNullOrEmpty(recipe.Difficulty))
                                {
                                    <span class="meta-chip @GetDifficultyClass(recipe.Difficulty)">
                                        <MudIcon Icon="@GetDifficultyIcon(recipe.Difficulty)" Size="Size.Small" />
                                        @GetDifficultyLabel(recipe.Difficulty)
                                    </span>
                                }
                                @if (recipe.Servings.HasValue)
                                {
                                    <span class="meta-chip">
                                        <MudIcon Icon="@Icons.Material.Rounded.Group" Size="Size.Small" />
                                        @recipe.Servings
                                    </span>
                                }
                            </div>
                        }
                    </div>
                </div>
            }
        </div>

        @if (_hasMore)
        {
            <div class="d-flex justify-center mt-4">
                <MudButton Variant="Variant.Outlined" OnClick="LoadMore" Disabled="_isLoading">
                    @if (_isLoading)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    }
                    Vis flere
                </MudButton>
            </div>
        }
    }
</div>

@code {
    [Parameter] public Guid CollectionId { get; set; }
    [Parameter] public string Title { get; set; } = "Oppskrifter";
    [Parameter] public int PageSize { get; set; } = 50;

    private Guid _lastCollectionId;
    private bool _isLoading;

    private readonly List<UserRecipeDto> _recipes = new();
    private int _page = 1;
    private int _totalCount = 0;
    private bool _hasMore = false;

    private string _searchQuery = "";
    private string _sortBy = "added";

    protected override async Task OnParametersSetAsync()
    {
        if (CollectionId != Guid.Empty && CollectionId != _lastCollectionId)
        {
            _lastCollectionId = CollectionId;
            await ReloadAsync();
        }
    }

    private async Task HandleSearchDebounce(string value)
    {
        _searchQuery = value;
        await ReloadAsync();
    }

    private async Task HandleSortChanged(string value)
    {
        _sortBy = value;
        await ReloadAsync();
    }

    private async Task ReloadAsync()
    {
        _page = 1;
        _recipes.Clear();
        await LoadPageAsync(append: false);
    }

    private async Task LoadMore()
    {
        if (!_hasMore) return;
        _page++;
        await LoadPageAsync(append: true);
    }

    private async Task LoadPageAsync(bool append)
    {
        _isLoading = true;
        try
        {
            var query = new GetCollectionRecipesQuery
            {
                Page = _page,
                PageSize = PageSize,
                SortBy = _sortBy,
                SortDescending = true,
                Search = string.IsNullOrWhiteSpace(_searchQuery) ? null : _searchQuery.Trim()
            };

            var result = await ApiClient.GetCollectionRecipesAsync(CollectionId, query);

            if (append) _recipes.AddRange(result.Recipes);
            else
            {
                _recipes.Clear();
                _recipes.AddRange(result.Recipes);
            }

            _totalCount = result.TotalCount;
            _hasMore = _recipes.Count < _totalCount;
        }
        catch (Exception ex)
        {
            Snackbar.Add("Kunne ikke laste oppskrifter", Severity.Error);
            Console.WriteLine(ex);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private void OpenRecipe(Guid recipeId) => Navigation.NavigateTo($"food/{recipeId}");

    private string GetScoreColor(double score)
    {
        if (score >= 8) return "#4CAF50";
        if (score >= 6) return "#FFC107";
        return "#F44336";
    }

    private string GetDifficultyIcon(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
        "medium" or "middels" => Icons.Material.Rounded.Psychology,
        "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
        _ => Icons.Material.Rounded.HelpOutline
    };

    private string GetDifficultyLabel(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" => "Lett",
        "medium" => "Middels",
        "hard" => "Vanskelig",
        _ => difficulty ?? ""
    };

    private string GetDifficultyClass(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => "difficulty-easy",
        "medium" or "middels" => "difficulty-medium",
        "hard" or "vanskelig" => "difficulty-hard",
        _ => ""
    };
}


================================================================================
FILE END: \StorhaugenWebsite\Components\CollectionRecipesList.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\EditRecipeDialog.razor
================================================================================
@using MudBlazor
@using Microsoft.AspNetCore.Components.Forms
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.ApiClient
@inject IUserRecipeService RecipeService
@inject IApiClient ApiClient
@inject ISnackbar Snackbar

<MudDialog Style="max-width: 600px;">
    <TitleContent>
        <div class="d-flex align-center gap-2">
            <MudIcon Icon="@Icons.Material.Rounded.Edit" Color="Color.Primary" />
            <MudText Typo="Typo.h6">Rediger oppskrift</MudText>
        </div>
    </TitleContent>
    <DialogContent>
        @if (_isSaving)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                <MudText Typo="Typo.body1" Class="mt-4">Lagrer endringer...</MudText>
            </div>
        }
        else if (Recipe != null)
        {
            @* Show restrictions alert for HelloFresh or published recipes *@
            @if (Recipe.IsHellofresh)
            {
                <MudAlert Severity="Severity.Info" Dense="true" Class="mb-4">
                    <MudText Typo="Typo.body2">
                        Dette er en HelloFresh-oppskrift. Du kan endre navn, beskrivelse og bilder, men metadata (tilberedningstid, porsjoner, etc.) kommer fra HelloFresh.
                    </MudText>
                </MudAlert>
            }
            @if (Recipe.IsPublished)
            {
                <MudAlert Severity="Severity.Warning" Dense="true" Class="mb-4">
                    <MudText Typo="Typo.body2">
                        Denne oppskriften er publisert. Du kan kun redigere notater og synlighet. For andre endringer, slett den publiserte versjonen først.
                    </MudText>
                </MudAlert>
            }

            <div class="d-flex flex-column gap-4">
                @* Name *@
                <MudTextField @bind-Value="_name"
                              Label="Navn"
                              Variant="Variant.Outlined"
                              Disabled="@Recipe.IsPublished"
                              Style="--mud-default-borderradius: 12px;" />

                @* Description *@
                <MudTextField @bind-Value="_description"
                              Label="Beskrivelse"
                              Variant="Variant.Outlined"
                              Lines="4"
                              Disabled="@Recipe.IsPublished"
                              Style="--mud-default-borderradius: 12px;" />

                @* Images section *@
                @if (!Recipe.IsPublished)
                {
                    <div class="form-section-inline">
                        <MudText Typo="Typo.subtitle2" Class="mb-2">Bilder</MudText>
                        @if (_imageUrls.Any())
                        {
                            <div class="image-preview-grid mb-2">
                                @for (int i = 0; i < _imageUrls.Count; i++)
                                {
                                    var index = i;
                                    <div class="image-preview-item">
                                        <img src="@_imageUrls[index]" />
                                        <button class="image-preview-remove" @onclick="@(() => RemoveImage(index))">
                                            <MudIcon Icon="@Icons.Material.Rounded.Close" Size="Size.Small" />
                                        </button>
                                    </div>
                                }
                            </div>
                        }
                        <MudFileUpload T="IReadOnlyList<IBrowserFile>" FilesChanged="OnImagesSelected" Accept="image/*" MaximumFileCount="5">
                            <ActivatorContent>
                                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Rounded.AddPhotoAlternate" Size="Size.Small" Style="border-radius: 8px;">
                                    Legg til bilde
                                </MudButton>
                            </ActivatorContent>
                        </MudFileUpload>
                    </div>
                }

                @* Metadata section - only for non-HelloFresh, non-published recipes *@
                @if (!Recipe.IsHellofresh && !Recipe.IsPublished)
                {
                    <MudExpansionPanels Elevation="0">
                        <MudExpansionPanel Text="Tilleggsinfo" Style="background: var(--mud-palette-background); border-radius: 12px;">
                            <div class="d-flex flex-wrap gap-3">
                                <MudNumericField T="int?" @bind-Value="_prepTimeMinutes"
                                                 Label="Tilberedningstid (min)"
                                                 Variant="Variant.Outlined"
                                                 Min="1" Max="300"
                                                 Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;"
                                                 Adornment="Adornment.Start"
                                                 AdornmentIcon="@Icons.Material.Rounded.AccessTime" />

                                <MudNumericField T="int?" @bind-Value="_cookTimeMinutes"
                                                 Label="Steketid (min)"
                                                 Variant="Variant.Outlined"
                                                 Min="1" Max="300"
                                                 Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;"
                                                 Adornment="Adornment.Start"
                                                 AdornmentIcon="@Icons.Material.Rounded.LocalFireDepartment" />
                            </div>

                            <div class="d-flex flex-wrap gap-3 mt-3">
                                <MudNumericField T="int?" @bind-Value="_servings"
                                                 Label="Porsjoner"
                                                 Variant="Variant.Outlined"
                                                 Min="1" Max="20"
                                                 Style="flex: 1; min-width: 100px; --mud-default-borderradius: 10px;"
                                                 Adornment="Adornment.Start"
                                                 AdornmentIcon="@Icons.Material.Rounded.People" />

                                <MudSelect T="string" @bind-Value="_difficulty"
                                           Label="Vanskelighetsgrad"
                                           Variant="Variant.Outlined"
                                           Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;"
                                           AnchorOrigin="Origin.BottomCenter">
                                    <MudSelectItem Value="@((string?)null)">Ikke valgt</MudSelectItem>
                                    <MudSelectItem Value="@("easy")">Lett</MudSelectItem>
                                    <MudSelectItem Value="@("medium")">Middels</MudSelectItem>
                                    <MudSelectItem Value="@("hard")">Vanskelig</MudSelectItem>
                                </MudSelect>
                            </div>

                            <MudTextField @bind-Value="_cuisine"
                                          Label="Kjøkken / Type"
                                          Variant="Variant.Outlined"
                                          Placeholder="f.eks. Italiensk, Asiatisk..."
                                          Class="mt-3"
                                          Style="--mud-default-borderradius: 10px;" />
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }

                @* Visibility - always editable *@
                <MudSelect T="string" @bind-Value="_visibility"
                           Label="Synlighet"
                           Variant="Variant.Outlined"
                           Style="--mud-default-borderradius: 12px;"
                           AnchorOrigin="Origin.BottomCenter">
                    <MudSelectItem Value="@("private")">Privat (Kun deg)</MudSelectItem>
                    <MudSelectItem Value="@("friends")">Venner</MudSelectItem>
                    <MudSelectItem Value="@("public")">Offentlig</MudSelectItem>
                </MudSelect>
            </div>
        }
    </DialogContent>
    <DialogActions>
        @if (!_isSaving)
        {
            <MudButton OnClick="Cancel" Color="Color.Default">Avbryt</MudButton>
            <MudButton OnClick="Save" Color="Color.Primary" Variant="Variant.Filled">
                Lagre
            </MudButton>
        }
    </DialogActions>
</MudDialog>

<style>
    .form-section-inline {
        background: var(--mud-palette-background-grey);
        border-radius: 12px;
        padding: 12px;
    }

    .image-preview-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 8px;
    }

    .image-preview-item {
        position: relative;
        aspect-ratio: 1;
        border-radius: 8px;
        overflow: hidden;
    }

    .image-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .image-preview-remove {
        position: absolute;
        top: 4px;
        right: 4px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
    }

    .image-preview-remove:hover {
        background: rgba(0, 0, 0, 0.8);
    }
</style>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public UserRecipeDto? Recipe { get; set; }

    private bool _isSaving = false;

    // Form fields
    private string? _name;
    private string? _description;
    private List<string> _imageUrls = new();
    private List<byte[]> _newImageData = new();
    private List<string> _newImageNames = new();
    private int? _prepTimeMinutes;
    private int? _cookTimeMinutes;
    private int? _servings;
    private string? _difficulty;
    private string? _cuisine;
    private string _visibility = "private";

    protected override void OnInitialized()
    {
        if (Recipe != null)
        {
            _name = Recipe.Name;
            _description = Recipe.Description;
            _imageUrls = new List<string>(Recipe.ImageUrls);
            _prepTimeMinutes = Recipe.PrepTimeMinutes;
            _cookTimeMinutes = Recipe.CookTimeMinutes;
            _servings = Recipe.Servings;
            _difficulty = Recipe.Difficulty;
            _cuisine = Recipe.Cuisine;
            _visibility = Recipe.Visibility;
        }
    }

    private void RemoveImage(int index)
    {
        if (index >= 0 && index < _imageUrls.Count)
        {
            _imageUrls.RemoveAt(index);
        }
    }

    private async Task OnImagesSelected(IReadOnlyList<IBrowserFile> files)
    {
        foreach (var file in files)
        {
            if (_imageUrls.Count + _newImageData.Count >= 5) break;

            try
            {
                var fileToRead = await file.RequestImageFileAsync("image/jpeg", 1200, 1200);
                using var stream = fileToRead.OpenReadStream(30 * 1024 * 1024);
                using var ms = new MemoryStream();
                await stream.CopyToAsync(ms);
                var buffer = ms.ToArray();

                // Add preview URL
                _imageUrls.Add($"data:image/jpeg;base64,{Convert.ToBase64String(buffer)}");
                _newImageData.Add(buffer);
                _newImageNames.Add(file.Name);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Kunne ikke laste bilde: {ex.Message}", Severity.Error);
            }
        }
        StateHasChanged();
    }

    private async Task Save()
    {
        if (Recipe == null) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            // Upload new images first
            var finalImageUrls = new List<string>();

            foreach (var url in _imageUrls)
            {
                // Keep existing URLs, upload new ones
                if (url.StartsWith("data:"))
                {
                    var index = _imageUrls.IndexOf(url) - (_imageUrls.Count - _newImageData.Count);
                    if (index >= 0 && index < _newImageData.Count)
                    {
                        var uploadResult = await ApiClient.UploadImageAsync(_newImageData[index], _newImageNames[index]);
                        finalImageUrls.Add(uploadResult.Url);
                    }
                }
                else
                {
                    finalImageUrls.Add(url);
                }
            }

            var dto = new UpdateUserRecipeDto
            {
                Name = _name,
                Description = _description,
                ImageUrls = finalImageUrls,
                Visibility = _visibility
            };

            // Add metadata only for non-HelloFresh, non-published recipes
            if (!Recipe.IsHellofresh && !Recipe.IsPublished)
            {
                dto.PrepTimeMinutes = _prepTimeMinutes;
                dto.CookTimeMinutes = _cookTimeMinutes;
                dto.Servings = _servings;
                dto.Difficulty = _difficulty;
                dto.Cuisine = _cuisine;
            }

            var updatedRecipe = await RecipeService.UpdateRecipeAsync(Recipe.Id, dto);
            Snackbar.Add("Oppskriften ble oppdatert!", Severity.Success);
            MudDialog.Close(DialogResult.Ok(updatedRecipe));
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke lagre: {ex.Message}", Severity.Error);
            _isSaving = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\EditRecipeDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\HelloFreshRecipeDetails.razor
================================================================================
@using StorhaugenWebsite.Shared.DTOs
@using System.Text.Json

<div class="hf-recipe-details">

    @* --- Nutrition Info --- *@
    @if (NutritionItems.Any())
    {
        <div class="hf-section">
            <h3 class="hf-section-title">
                <MudIcon Icon="@Icons.Material.Rounded.LocalFireDepartment" Size="Size.Small" />
                Nringsinformasjon
            </h3>
            <div class="hf-nutrition-grid">
                @foreach (var item in NutritionItems)
                {
                    <div class="hf-nutrition-item">
                        <span class="hf-nutrition-value">@item.Amount</span>
                        <span class="hf-nutrition-label">@item.Name</span>
                    </div>
                }
            </div>
        </div>
    }

    @* --- Ingredients --- *@
    @if (Ingredients.Any())
    {
        <div class="hf-section">
            <h3 class="hf-section-title">
                <MudIcon Icon="@Icons.Material.Rounded.ShoppingCart" Size="Size.Small" />
                Ingredienser
            </h3>
            <div class="hf-ingredients-list">
                @foreach (var ingredient in Ingredients)
                {
                    <div class="hf-ingredient-item">
                        @if (!string.IsNullOrEmpty(ingredient.Image))
                        {
                            <img src="@GetIngredientImageUrl(ingredient.Image)" alt="@ingredient.Name" class="hf-ingredient-image" />
                        }
                        else
                        {
                            <div class="hf-ingredient-placeholder">
                                <MudIcon Icon="@Icons.Material.Rounded.Egg" Size="Size.Small" />
                            </div>
                        }
                        <div class="hf-ingredient-info">
                            <span class="hf-ingredient-name">@ingredient.Name</span>
                            @if (!string.IsNullOrEmpty(ingredient.Amount) || !string.IsNullOrEmpty(ingredient.Unit))
                            {
                                <span class="hf-ingredient-amount">@ingredient.Amount @ingredient.Unit</span>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    }
</div>

<style>
    .hf-recipe-details {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .hf-quick-info {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }

    .hf-info-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: var(--mud-palette-surface);
        border-radius: 12px;
        border: 1px solid var(--mud-palette-lines-default);
    }

    .hf-info-content {
        display: flex;
        flex-direction: column;
    }

    .hf-info-label {
        font-size: 0.75rem;
        color: var(--mud-palette-text-secondary);
    }

    .hf-info-value {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--mud-palette-text-primary);
    }

    .hf-section {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 16px;
    }

    .hf-section-title {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 12px;
        color: var(--mud-palette-text-primary);
    }

    .hf-nutrition-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
    }

    .hf-nutrition-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        text-align: center;
    }

    .hf-nutrition-value {
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--mud-palette-primary);
    }

    .hf-nutrition-label {
        font-size: 0.65rem;
        color: var(--mud-palette-text-secondary);
        text-transform: uppercase;
        margin-top: 2px;
    }

    .hf-ingredients-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .hf-ingredient-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
    }

    .hf-ingredient-image {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        object-fit: cover;
        background: white;
    }

    .hf-ingredient-placeholder {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        background: var(--mud-palette-divider);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-disabled);
    }

    .hf-ingredient-info {
        display: flex;
        flex-direction: column;
    }

    .hf-ingredient-name {
        font-weight: 500;
        color: var(--mud-palette-text-primary);
    }

    .hf-ingredient-amount {
        font-size: 0.8rem;
        color: var(--mud-palette-text-secondary);
    }

    .hf-attribution {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px;
        background: rgba(var(--mud-palette-primary-rgb), 0.05);
        border-radius: 12px;
        color: var(--mud-palette-primary);
        font-size: 0.9rem;
    }

    @@media (max-width: 600px) {
        .hf-quick-info {
            grid-template-columns: 1fr;
        }

        .hf-nutrition-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }
</style>

@code {
    [Parameter, EditorRequired]
    public GlobalRecipeDto Recipe { get; set; } = default!;

    private record IngredientInfo(string Name, string? Amount, string? Unit, string? Image);
    private record NutritionInfo(string Name, string Amount);

    private List<IngredientInfo> Ingredients { get; set; } = new();
    private List<NutritionInfo> NutritionItems { get; set; } = new();

    protected override void OnParametersSet()
    {
        ParseIngredients();
        ParseNutrition();
    }

    private void ParseIngredients()
    {
        Ingredients.Clear();

        if (Recipe.Ingredients == null) return;

        try
        {
            if (Recipe.Ingredients is JsonElement jsonElement)
            {
                if (jsonElement.ValueKind == JsonValueKind.Array)
                {
                    foreach (var item in jsonElement.EnumerateArray())
                    {
                        var name = item.TryGetProperty("name", out var n) ? n.GetString() : "";
                        var amount = item.TryGetProperty("amount", out var a) ? a.ToString() : null;
                        var unit = item.TryGetProperty("unit", out var u) ? u.GetString() : null;
                        var image = item.TryGetProperty("image", out var i) ? i.GetString() : null;

                        if (!string.IsNullOrEmpty(name))
                        {
                            Ingredients.Add(new IngredientInfo(name!, amount, unit, image));
                        }
                    }
                }
            }
            else if (Recipe.Ingredients is IEnumerable<object> list)
            {
                foreach (var item in list)
                {
                    var json = JsonSerializer.Serialize(item);
                    var element = JsonDocument.Parse(json).RootElement;

                    var name = element.TryGetProperty("name", out var n) ? n.GetString() : "";
                    var amount = element.TryGetProperty("amount", out var a) ? a.ToString() : null;
                    var unit = element.TryGetProperty("unit", out var u) ? u.GetString() : null;
                    var image = element.TryGetProperty("image", out var i) ? i.GetString() : null;

                    if (!string.IsNullOrEmpty(name))
                    {
                        Ingredients.Add(new IngredientInfo(name!, amount, unit, image));
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing ingredients: {ex.Message}");
        }
    }

    private void ParseNutrition()
    {
        NutritionItems.Clear();

        if (Recipe.NutritionData == null) return;

        try
        {
            if (Recipe.NutritionData is JsonElement jsonElement)
            {
                if (jsonElement.ValueKind == JsonValueKind.Object)
                {
                    foreach (var prop in jsonElement.EnumerateObject())
                    {
                        var amount = prop.Value.ToString();
                        var name = GetNutritionDisplayName(prop.Name);
                        NutritionItems.Add(new NutritionInfo(name, amount));
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing nutrition: {ex.Message}");
        }
    }

    private string GetNutritionDisplayName(string key)
    {
        return key.ToLower() switch
        {
            "kalorier" => "kcal",
            "energi (kj)" => "kJ",
            "fett" => "Fett",
            "mettet fett" => "M. fett",
            "karbohydrater" => "Karb.",
            "sukker" => "Sukker",
            "protein" => "Protein",
            "natrium" => "Natrium",
            _ => key.Length > 8 ? key.Substring(0, 6) + ".." : key
        };
    }

    private string GetIngredientImageUrl(string imagePath)
    {
        if (string.IsNullOrEmpty(imagePath)) return "";
        if (imagePath.StartsWith("http")) return imagePath;
        return $"https://d3hvwccx09j84u.cloudfront.net/0,0{imagePath}";
    }

    private string GetDifficultyIcon(string difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
            "medium" or "middels" => Icons.Material.Rounded.Psychology,
            "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
            _ => Icons.Material.Rounded.HelpOutline
        };
    }

    private string GetDifficultyLabel(string difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" => "Lett",
            "medium" => "Middels",
            "hard" => "Vanskelig",
            _ => difficulty ?? ""
        };
    }

    private Color GetTagColor(string tag)
    {
        var tagLower = tag.ToLower();
        if (tagLower.Contains("rask") || tagLower.Contains("quick")) return Color.Success;
        if (tagLower.Contains("barnevennlig") || tagLower.Contains("family") || tagLower.Contains("child")) return Color.Info;
        if (tagLower.Contains("vegetar")) return Color.Tertiary;
        if (tagLower.Contains("comfort")) return Color.Warning;
        return Color.Default;
    }

    private string GetWeekDisplayText(string week)
    {
        // Convert "2026-W02" to "Uke 2, 2026"
        if (string.IsNullOrEmpty(week)) return "";

        try
        {
            var parts = week.Split("-W");
            if (parts.Length == 2)
            {
                var year = parts[0];
                var weekNum = int.Parse(parts[1]);
                return $"Uke {weekNum}, {year}";
            }
        }
        catch { }

        return week;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\HelloFreshRecipeDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\InviteMemberDialog.razor
================================================================================
@*
    Dialog for inviting members to a collection.
*@
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using System.ComponentModel.DataAnnotations
@inject IApiClient ApiClient
@inject IUserFriendshipService FriendshipService
@inject IUserColorService UserColorService
@inject ISnackbar Snackbar

<MudDialog>
    <DialogContent>
        <div class="invite-dialog">
            <MudText Typo="Typo.h6" Class="mb-2">Inviter medlem til @CollectionName</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                Velg en venn eller søk etter brukere.
            </MudText>

            @* --- Search Bar --- *@
            <MudTextField @bind-Value="_searchQuery"
                          Placeholder="Søk etter navn eller ID..."
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Rounded.Search"
                          Immediate="true"
                          DebounceInterval="400"
                          OnDebounceIntervalElapsed="PerformSearch"
                          Class="mb-3"
                          Margin="Margin.Dense"
                          Clearable="true"
                          OnClearButtonClick="@(() => { _searchQuery = string.Empty; _searchResults.Clear(); })" />

            @* --- Search Results --- *@
            @if (!string.IsNullOrWhiteSpace(_searchQuery))
            {
                @if (_isSearching)
                {
                    <div class="d-flex justify-center py-3">
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    </div>
                }
                else if (_searchResults.Any())
                {
                    <div class="friend-list mb-3">
                        @foreach (var user in _searchResults)
                        {
                            <div class="friend-item" @onclick="@(() => InviteUser(user.Id, user.DisplayName))">
                                <MudAvatar Size="Size.Small" Style="@($"background-color: {UserColorService.GetUserColor(user.DisplayName)}; color: white;")">
                                    @(user.DisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                                </MudAvatar>
                                <div class="friend-info">
                                    <span class="friend-name">@user.DisplayName</span>
                                    <span class="friend-id">ID: @user.ShareId</span>
                                </div>
                                <MudIcon Icon="@Icons.Material.Rounded.PersonAdd" Size="Size.Small" Color="Color.Primary" />
                            </div>
                        }
                    </div>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="text-center py-2">
                        Ingen brukere funnet
                    </MudText>
                }
            }
            else
            {
                @* --- Friends List --- *@
                @if (_isLoadingFriends)
                {
                    <div class="d-flex justify-center py-3">
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    </div>
                }
                else if (_friends.Any())
                {
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">Venner</MudText>
                    <div class="friend-list mb-3">
                        @foreach (var friend in _friends)
                        {
                            <div class="friend-item" @onclick="@(() => InviteUser(friend.FriendUserId, friend.FriendDisplayName))">
                                <MudAvatar Size="Size.Small" Style="@($"background-color: {UserColorService.GetUserColor(friend.FriendDisplayName)}; color: white;")">
                                    @(friend.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                                </MudAvatar>
                                <div class="friend-info">
                                    <span class="friend-name">@friend.FriendDisplayName</span>
                                </div>
                                <MudIcon Icon="@Icons.Material.Rounded.PersonAdd" Size="Size.Small" Color="Color.Primary" />
                            </div>
                        }
                    </div>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="text-center py-2 mb-2">
                        Du har ingen venner ennå
                    </MudText>
                }

                @* --- Manual Entry Fallback --- *@
                <MudExpansionPanels Class="mt-2" Elevation="0">
                    <MudExpansionPanel Text="Inviter med e-post eller Dele-ID" Dense="true" Style="background: transparent;">
                        <MudTabs Rounded="true" Centered="true" Class="mb-3" @bind-ActivePanelIndex="_activeTab">
                            <MudTabPanel Text="E-post" Icon="@Icons.Material.Rounded.Email">
                                <MudForm @ref="_emailForm" @bind-IsValid="_emailIsValid" Class="mt-3">
                                    <MudTextField @bind-Value="_email"
                                                  Label="E-postadresse"
                                                  Variant="Variant.Outlined"
                                                  Required="true"
                                                  RequiredError="E-post er påkrevd"
                                                  Validation="@(new EmailAddressAttribute() { ErrorMessage = "Vennligst skriv inn en gyldig e-postadresse" })"
                                                  Adornment="Adornment.Start"
                                                  AdornmentIcon="@Icons.Material.Rounded.Email"
                                                  HelperText="f.eks. venn@example.com"
                                                  Immediate="true"
                                                  Margin="Margin.Dense" />
                                </MudForm>
                            </MudTabPanel>
                            <MudTabPanel Text="Dele-ID" Icon="@Icons.Material.Rounded.Tag">
                                <MudForm @ref="_shareIdForm" @bind-IsValid="_shareIdIsValid" Class="mt-3">
                                    <MudTextField @bind-Value="_shareId"
                                                  Label="Dele-ID"
                                                  Variant="Variant.Outlined"
                                                  Required="true"
                                                  RequiredError="Dele-ID er påkrevd"
                                                  Adornment="Adornment.Start"
                                                  AdornmentIcon="@Icons.Material.Rounded.Tag"
                                                  HelperText="f.eks. ABC123XYZ"
                                                  Immediate="true"
                                                  Margin="Margin.Dense"
                                                  Style="text-transform: uppercase; font-family: monospace; letter-spacing: 1px;" />
                                </MudForm>
                            </MudTabPanel>
                        </MudTabs>

                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   FullWidth="true"
                                   OnClick="SendInvite"
                                   Disabled="_isSending || !IsCurrentFormValid()">
                            @if (_isSending)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Sender...</span>
                            }
                            else
                            {
                                <span>Send invitasjon</span>
                            }
                        </MudButton>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            }

            @if (!string.IsNullOrEmpty(_errorMessage))
            {
                <MudAlert Severity="Severity.Error" Class="mt-3" Dense="true" ShowCloseIcon="true" CloseIconClicked="@(() => _errorMessage = null)">
                    @_errorMessage
                </MudAlert>
            }

            @if (!string.IsNullOrEmpty(_successMessage))
            {
                <MudAlert Severity="Severity.Success" Class="mt-3" Dense="true">
                    @_successMessage
                </MudAlert>
            }
        </div>
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel" Disabled="_isSending">Lukk</MudButton>
    </DialogActions>
</MudDialog>

<style>
    .invite-dialog {
        padding: 8px 0;
        min-width: 300px;
    }

    .friend-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 250px;
        overflow-y: auto;
    }

    .friend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.15s ease;
    }

    .friend-item:hover {
        background: var(--mud-palette-action-default-hover);
    }

    .friend-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
    }

    .friend-name {
        font-weight: 500;
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .friend-id {
        font-size: 0.75rem;
        color: var(--mud-palette-text-secondary);
    }
</style>

@code {
    [CascadingParameter]
    IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public Guid CollectionId { get; set; }

    [Parameter]
    public string CollectionName { get; set; } = "";

    private MudForm? _emailForm;
    private MudForm? _shareIdForm;
    private bool _emailIsValid = false;
    private bool _shareIdIsValid = false;
    private bool _isSending = false;
    private int _activeTab = 0;
    private string _email = "";
    private string _shareId = "";
    private string? _errorMessage;
    private string? _successMessage;

    // Friend search
    private string _searchQuery = "";
    private List<UserFriendshipDto> _friends = new();
    private List<UserSearchResultDto> _searchResults = new();
    private bool _isLoadingFriends = true;
    private bool _isSearching = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadFriends();
    }

    private async Task LoadFriends()
    {
        _isLoadingFriends = true;
        try
        {
            var friendships = await FriendshipService.GetFriendshipsAsync();
            _friends = friendships.Friends ?? new();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading friends: {ex.Message}");
        }
        finally
        {
            _isLoadingFriends = false;
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery))
        {
            _searchResults.Clear();
            return;
        }

        _isSearching = true;
        StateHasChanged();

        try
        {
            _searchResults = await FriendshipService.SearchUsersAsync(_searchQuery);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Search error: {ex.Message}");
        }
        finally
        {
            _isSearching = false;
            StateHasChanged();
        }
    }

    private async Task InviteUser(Guid userId, string? displayName)
    {
        _errorMessage = null;
        _successMessage = null;
        _isSending = true;
        StateHasChanged();

        try
        {
            // Use userId directly to add member
            var dto = new AddCollectionMemberDto { UserIdentifier = userId.ToString() };
            await ApiClient.AddCollectionMemberAsync(CollectionId, dto);

            _successMessage = $"{displayName ?? "Bruker"} lagt til!";
            Snackbar.Add("Medlem lagt til!", Severity.Success);

            // Remove from lists to prevent re-inviting
            _friends.RemoveAll(f => f.FriendUserId == userId);
            _searchResults.RemoveAll(s => s.Id == userId);

            StateHasChanged();
        }
        catch (HttpRequestException ex)
        {
            if (ex.StatusCode == System.Net.HttpStatusCode.BadRequest)
            {
                _errorMessage = "Denne brukeren er allerede medlem av samlingen";
            }
            else if (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                _errorMessage = "Bruker ikke funnet";
            }
            else
            {
                _errorMessage = $"Kunne ikke legge til medlem: {ex.Message}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"En uventet feil oppstod: {ex.Message}";
        }
        finally
        {
            _isSending = false;
            StateHasChanged();
        }
    }

    private bool IsCurrentFormValid()
    {
        return _activeTab == 0 ? _emailIsValid : _shareIdIsValid;
    }

    private async Task SendInvite()
    {
        _errorMessage = null;
        _successMessage = null;

        // Validate the active form
        if (_activeTab == 0)
        {
            await _emailForm!.Validate();
            if (!_emailIsValid || string.IsNullOrWhiteSpace(_email))
            {
                _errorMessage = "Vennligst skriv inn en gyldig e-postadresse";
                return;
            }
        }
        else
        {
            await _shareIdForm!.Validate();
            if (!_shareIdIsValid || string.IsNullOrWhiteSpace(_shareId))
            {
                _errorMessage = "Vennligst skriv inn en Dele-ID";
                return;
            }
        }

        _isSending = true;
        StateHasChanged();

        try
        {
            var userIdentifier = _activeTab == 0 ? _email.Trim() : _shareId.Trim().ToUpperInvariant();
            var dto = new AddCollectionMemberDto
            {
                UserIdentifier = userIdentifier
            };
            await ApiClient.AddCollectionMemberAsync(CollectionId, dto);

            var inviteTarget = _activeTab == 0 ? _email : $"bruker med ID {_shareId.ToUpperInvariant()}";
            _successMessage = $"Medlem lagt til: {inviteTarget}!";
            Snackbar.Add("Medlem lagt til!", Severity.Success);

            // Clear the form for another invite
            _email = "";
            _shareId = "";
            _emailForm?.ResetAsync();
            _shareIdForm?.ResetAsync();

            // Close dialog after a short delay
            await Task.Delay(1500);
            MudDialog?.Close(DialogResult.Ok(true));
        }
        catch (HttpRequestException ex)
        {
            if (ex.StatusCode == System.Net.HttpStatusCode.BadRequest)
            {
                _errorMessage = "Denne brukeren er allerede medlem av samlingen";
            }
            else if (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                _errorMessage = _activeTab == 1 ? "Bruker med denne Dele-ID ble ikke funnet" : "Samling ikke funnet";
            }
            else
            {
                _errorMessage = $"Kunne ikke legge til medlem: {ex.Message}";
            }
            Console.WriteLine($"Error adding member: {ex}");
        }
        catch (Exception ex)
        {
            _errorMessage = $"En uventet feil oppstod: {ex.Message}";
            Console.WriteLine($"Error adding member: {ex}");
        }
        finally
        {
            _isSending = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog?.Close(DialogResult.Cancel());
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\InviteMemberDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\PublishRecipeDialog.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IUserRecipeService RecipeService
@inject ISnackbar Snackbar

<MudDialog>
    <TitleContent>
        <div class="d-flex align-center gap-2">
            <MudIcon Icon="@Icons.Material.Rounded.Publish" Color="Color.Primary" />
            <MudText Typo="Typo.h6">Publiser oppskrift</MudText>
        </div>
    </TitleContent>
    <DialogContent>
        @if (_isPublishing)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                <MudText Typo="Typo.body1" Class="mt-4">Publiserer oppskrift...</MudText>
            </div>
        }
        else if (_publishResult != null)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudIcon Icon="@Icons.Material.Rounded.CheckCircle" Color="Color.Success" Size="Size.Large" />
                <MudText Typo="Typo.h6" Class="mt-3">Publisert!</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2 text-center">
                    @_publishResult.Message
                </MudText>
            </div>
        }
        else
        {
            <MudText Typo="Typo.body1" Class="mb-4">
                Ved å publisere denne oppskriften blir den tilgjengelig for alle brukere i den globale oppskriftsdatabasen.
            </MudText>

            <MudAlert Severity="Severity.Info" Dense="true" Class="mb-4">
                <MudText Typo="Typo.body2">
                    Din oppskrift vil fortsatt være lenket til den publiserte versjonen.
                    Du kan når som helst "koble fra" for å gjøre lokale endringer.
                </MudText>
            </MudAlert>

            @if (Recipe != null)
            {
                <MudPaper Class="pa-3" Elevation="1">
                    <div class="d-flex gap-3">
                        @if (Recipe.ImageUrls.Any())
                        {
                            <MudImage Src="@Recipe.ImageUrls.First()"
                                     Alt="@Recipe.Name"
                                     Width="80"
                                     Height="80"
                                     ObjectFit="ObjectFit.Cover"
                                     Class="rounded" />
                        }
                        <div>
                            <MudText Typo="Typo.subtitle1">@Recipe.Name</MudText>
                            @if (!string.IsNullOrEmpty(Recipe.Description))
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                                    @(Recipe.Description.Length > 100 ? Recipe.Description.Substring(0, 100) + "..." : Recipe.Description)
                                </MudText>
                            }
                        </div>
                    </div>
                </MudPaper>
            }
        }
    </DialogContent>
    <DialogActions>
        @if (_publishResult != null)
        {
            <MudButton OnClick="Close" Color="Color.Primary" Variant="Variant.Filled">
                Lukk
            </MudButton>
        }
        else if (!_isPublishing)
        {
            <MudButton OnClick="Cancel" Color="Color.Default">Avbryt</MudButton>
            <MudButton OnClick="Publish" Color="Color.Primary" Variant="Variant.Filled">
                Publiser
            </MudButton>
        }
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public UserRecipeDto? Recipe { get; set; }

    private bool _isPublishing = false;
    private PublishRecipeResultDto? _publishResult;

    private async Task Publish()
    {
        if (Recipe == null) return;

        _isPublishing = true;
        StateHasChanged();

        try
        {
            _publishResult = await RecipeService.PublishRecipeAsync(Recipe.Id);
            Snackbar.Add("Oppskriften ble publisert!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke publisere: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isPublishing = false;
        }

        StateHasChanged();
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    private void Close()
    {
        MudDialog.Close(DialogResult.Ok(_publishResult));
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\PublishRecipeDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\RecipeSkeleton.razor
================================================================================
@using MudBlazor

<div class="@OuterClass" style="@OuterStyle">
    @for (var i = 0; i < Amount; i++)
    {
        <div class="skeleton-card d-flex justify-space-between @Class" style="height: @Height; @Style">

            @* Left Side: Content *@
            <div class="d-flex flex-column justify-start flex-grow-1 py-1 pr-2" style="min-width: 0;">

                @* Line 1: Title *@
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="16px" Width="65%" Class="mb-2 rounded" />

                @* Line 2: Metadata *@
                <div class="d-flex gap-2 @(LineAmount > 0 ? "mb-2" : "")">
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="12px" Width="40px" Class="rounded" />
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="12px" Width="50px" Class="rounded" />
                </div>

                @* Line 3+: Dynamic Lines based on LineAmount *@
                @for (int line = 0; line < LineAmount; line++)
                {
                    var width = line % 2 == 0 ? "30%" : "45%";
                    var margin = line < LineAmount - 1 ? "mb-2" : "";

                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="10px" Width="@width" Class="@($"rounded {margin}")" />
                }
            </div>

            @* Right Side: Image (Hidden if DisableImage is true) *@
            @if (!DisableImage)
            {
                <div style="flex-shrink: 0; height: 100%; aspect-ratio: 1/1;">
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100%" Width="100%" Class="rounded" />
                </div>
            }

        </div>
    }
</div>

<style>
    .skeleton-card {
        background-color: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 12px;
        overflow: hidden;
    }
</style>

@code {
    [Parameter] public int Amount { get; set; } = 5;
    [Parameter] public int LineAmount { get; set; } = 1;
    [Parameter] public bool DisableImage { get; set; } = true;

    [Parameter] public string OuterClass { get; set; } = "d-flex flex-column gap-3";
    [Parameter] public string OuterStyle { get; set; } = "";
    [Parameter] public string Height { get; set; } = "96px";
    [Parameter] public string Class { get; set; } = "";
    [Parameter] public string Style { get; set; } = "";
}

================================================================================
FILE END: \StorhaugenWebsite\Components\RecipeSkeleton.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
================================================================================
@using MudBlazor

<MudPaper Class="pa-3" Elevation="0" Style="background: var(--mud-palette-background-grey);">
    <MudText Typo="Typo.subtitle2" Class="mb-2">Synlighet</MudText>

    <MudRadioGroup @bind-Value="Visibility" T="string">
        <div class="d-flex flex-column gap-2">
            <MudPaper Class="@(Visibility == "private" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("private")"
                     @onclick="@(() => SetVisibility("private"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("private")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Privat</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Bare du kan se denne oppskriften</MudText>
                    </div>
                </div>
            </MudPaper>

            <MudPaper Class="@(Visibility == "friends" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("friends")"
                     @onclick="@(() => SetVisibility("friends"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("friends")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Venner</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Synlig for vennene dine</MudText>
                    </div>
                </div>
            </MudPaper>

            <MudPaper Class="@(Visibility == "public" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("public")"
                     @onclick="@(() => SetVisibility("public"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("public")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Offentlig</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Alle kan se denne oppskriften</MudText>
                    </div>
                </div>
            </MudPaper>
        </div>
    </MudRadioGroup>
</MudPaper>

@code {
    [Parameter]
    public string Visibility { get; set; } = "private";

    [Parameter]
    public EventCallback<string> VisibilityChanged { get; set; }

    private async Task SetVisibility(string value)
    {
        Visibility = value;
        await VisibilityChanged.InvokeAsync(value);
    }

    private string GetItemStyle(string value)
    {
        var baseStyle = "cursor: pointer; border: 1px solid transparent; border-radius: 8px;";
        if (Visibility == value)
        {
            return baseStyle + " border-color: var(--mud-palette-primary);";
        }
        return baseStyle;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\XFade.razor
================================================================================
<div class="xfade @(_isLoadedClass ? "loaded" : "loading")">
    @if (_showSkeleton && Skeleton is not null)
    {
        <div class="xfade-skeleton" aria-hidden="true">
            @Skeleton
        </div>
    }

    <div class="xfade-content" aria-busy="@IsLoading">
        @if (_renderContent)
        {
            @ChildContent
        }
    </div>
</div>

@code {
    [Parameter] public bool IsLoading { get; set; }

    // Default behavior:
    // - show skeleton + crossfade only for the FIRST load
    // - on later reloads: keep content visible (no fade-out)
    [Parameter] public bool FirstLoadOnly { get; set; } = true;

    // If true: also crossfade on later reloads (content fades out)
    [Parameter] public bool CrossfadeOnReload { get; set; } = false;

    // Must match your CSS duration (the loaded transition)
    [Parameter] public int FadeMs { get; set; } = 220;

    [Parameter] public RenderFragment? Skeleton { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }

    private bool _renderContent;
    private bool _showSkeleton = true;
    private bool _isLoadedClass;
    private bool _hasLoadedOnce;

    // guards so "FirstLoadOnly" doesn't accidentally flicker skeleton on reload
    private bool _ignoreThisCycle;
    private bool _armedForTransition;
    private int _token;

    protected override void OnParametersSet()
    {
        if (IsLoading)
        {
            // If we already have content and we only want skeleton on first load,
            // ignore this cycle entirely (no fade out / no skeleton).
            if (_hasLoadedOnce && FirstLoadOnly && !CrossfadeOnReload && _renderContent)
            {
                _ignoreThisCycle = true;
                return;
            }

            _ignoreThisCycle = false;
            _armedForTransition = true;
            _token++;

            _showSkeleton = true;
            _isLoadedClass = false; // "loading"
            return;
        }

        // IsLoading == false
        if (_ignoreThisCycle)
        {
            _ignoreThisCycle = false;
            return;
        }

        // If we never entered a loading state that we manage, do nothing.
        if (!_armedForTransition && _hasLoadedOnce)
            return;

        _armedForTransition = false;
        _hasLoadedOnce = true;

        // Ensure content is mounted, then flip to loaded on next tick so transitions fire
        _renderContent = true;
        _showSkeleton = true;
        _isLoadedClass = false;

        var t = ++_token;
        _ = RunTransitionAsync(t);
    }

    private async Task RunTransitionAsync(int t)
    {
        // Let the browser paint "loading + content present" once
        await Task.Delay(1);
        if (t != _token) return;

        _isLoadedClass = true; // -> "loaded"
        await InvokeAsync(StateHasChanged);

        await Task.Delay(FadeMs);
        if (t != _token) return;

        _showSkeleton = false; // remove after fade
        await InvokeAsync(StateHasChanged);
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\XFade.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\AppConfig.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    // AppConfig is now simplified - no more email whitelist
    // Authorization is handled by the backend API based on household membership
    public static class AppConfig
    {
        // Keep this empty for now - configuration can be added later if needed
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Models\AppConfig.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\DeviceSettings.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class DeviceSettings
    {
        public string Theme { get; set; } = "Dark";
        public string ViewMode { get; set; } = "list";
        public string SortBy { get; set; } = "date";
        public bool SortDescending { get; set; } = true;
        public List<Guid> CookbookCollectionFilters { get; set; } = new();
        public bool CookbookPersonalFilterActive { get; set; } = false;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\DeviceSettings.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\FoodItem.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class FoodItem
    {
        public string Id { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;

        public bool IsHelloFresh { get; set; } = false;

        public string? Description { get; set; }
        public List<string> ImageUrls { get; set; } = new();
        public Dictionary<string, decimal?> Ratings { get; set; } = new();
        public DateTime DateAdded { get; set; } = DateTime.UtcNow;
        public string AddedBy { get; set; } = string.Empty;
        public bool IsArchived { get; set; } = false;
        public DateTime? ArchivedDate { get; set; }
        public string? ArchivedBy { get; set; }

        // Multi-tenant fields
        public Guid? GlobalRecipeId { get; set; }
        public string? GlobalRecipeName { get; set; }
        public bool IsForked { get; set; }
        public string? PersonalNotes { get; set; }

        // Recipe metadata (from HelloFresh or manual)
        public int? PrepTimeMinutes { get; set; }
        public int? CookTimeMinutes { get; set; }
        public int? Servings { get; set; }
        public string? Difficulty { get; set; }
        public string? Cuisine { get; set; }
        public object? Ingredients { get; set; }

        // Public sharing
        public bool IsPublic { get; set; }

        public double AverageRating
        {
            get
            {
                var validRatings = Ratings.Values.Where(r => r.HasValue).Select(r => r!.Value).ToList();
                return validRatings.Count > 0 ? (double)validRatings.Average() : 0;
            }
        }

        public decimal GetRatingForPerson(string person)
        {
            return Ratings.TryGetValue(person, out var rating) ? rating ?? 0m : 0m;
        }

        // Helper property to check if this recipe is linked to a global recipe
        public bool IsLinkedToGlobal => GlobalRecipeId.HasValue && !IsForked;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\FoodItem.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\ThemeColors.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class ThemeColors
    {
        public string? Primary { get; set; }
        public string? Info { get; set; }
        public string? AppbarBackground { get; set; }
        public string? Surface { get; set; }
        public string? Background { get; set; }
        public string? BackgroundGrey { get; set; }
        public string? Divider { get; set; }
        public string? TextPrimary { get; set; }
        public string? TextSecondary { get; set; }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\ThemeColors.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\AddFood.razor
================================================================================
@page "/add"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IAuthService AuthService
@inject IFoodService FoodService
@inject IUserRecipeService RecipeService
@inject ICollectionStateService CollectionState
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IOcrService OcrService
@inject IJSRuntime JSRuntime
@attribute [Authorize]

@* --- 1. LANDSCAPE BLOCKER --- *@
<div id="landscape-blocker">
    <MudIcon Icon="@Icons.Material.Rounded.ScreenLockPortrait" Style="font-size: 64px; margin-bottom: 20px; color: #E07A2E;" />
    <h2 style="font-family: 'Fraunces', serif;">Vennligst snu telefonen</h2>
    <p style="opacity: 0.7; max-width: 300px; margin-top: 10px;">Storhaugen Eats er designet for å brukes i portrettmodus.</p>
</div>

@* --- 2. CAMERA OVERLAY UI --- *@
@if (_showCameraOverlay)
{
    <div class="camera-overlay">
        <video @ref="_videoElement" autoplay playsinline muted class="camera-video"></video>
        <div class="camera-guide-container @GetOverlayClass()">
            <div class="camera-guide-box">
                @if (_currentStep == ScanStep.Front)
                {
                    <div class="logo-hint-zone">
                        <svg width="60" height="80" viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" fill="#fff">
                            <path d="M50 0 C25 0 5 20 5 45 C5 70 25 90 50 90 C75 90 95 70 95 45 C95 35 90 15 80 5" fill="#9ACD32" />
                            <path d="M80 5 C85 0 95 0 95 10 C95 5 85 5 80 5 Z" fill="#76a11e" />
                            <text x="50" y="105" font-family="Arial, sans-serif" font-weight="900" font-size="14" text-anchor="middle" letter-spacing="1">HELLO</text>
                            <text x="50" y="118" font-family="Arial, sans-serif" font-weight="900" font-size="14" text-anchor="middle" letter-spacing="1">FRESH</text>
                        </svg>
                    </div>
                    <div class="text-hint-zone"><span class="text-label">TITTEL HER</span></div>
                }
                <div class="scan-line"></div>
            </div>
            <div class="camera-instruction-pill">
                <MudIcon Icon="@GetStepIcon()" Size="Size.Small" Class="mr-2" Style="color: #00E676;" />
                <span class="step-text">@GetStepTitle()</span>
            </div>
            <p class="camera-guide-text">@GetInstructionText()</p>
        </div>
        <div class="camera-controls">
            <MudIconButton Icon="@Icons.Material.Rounded.Close" Color="Color.Surface" Size="Size.Large" OnClick="StopCamera" />
            <button class="camera-shutter @(_isProcessingOcr ? "processing" : "")" disabled="@_isProcessingOcr" @onclick="CaptureCameraImage"></button>
            <div class="step-counter">@((int)_currentStep + 1) / 3</div>
        </div>
    </div>
}

<div class="app-content-container">
    <div class="d-flex justify-space-between align-center mb-4">
        <div>
            <h1 class="page-title" style="margin-bottom: 4px; font-size: 24px; font-weight: 700;">Legg til måltid</h1>
            <p class="page-subtitle" style="color: var(--mud-palette-text-secondary);">
                @(_fromDraft ? "Tilpass kopiert oppskrift" : "Gi kveldens middag en vurdering")
            </p>
        </div>
    </div>

    @* HelloFresh toggle removed - users should browse and add HelloFresh recipes from the Browse section *@

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="mb-4" ShowCloseIcon="true" CloseIconClicked="@(() => _errorMessage = null)">@_errorMessage</MudAlert>
    }

    <div class="form-section">
        <div class="d-flex justify-space-between align-center">
            <p class="form-section-title">Måltidsdetaljer</p>
            @if (_isHelloFresh && _isProcessingOcr)
            {
                <MudChip Size="Size.Small" Color="Color.Success" T="string" Variant="Variant.Text" Icon="@Icons.Material.Rounded.AutoAwesome">Analyserer...</MudChip>
            }
        </div>

        <MudTextField @bind-Value="_newFood.Name"
                      Label="@(_isHelloFresh ? "Navn på rett" : "Hva spiste vi?")"
                      Variant="Variant.Outlined"
                      Placeholder="@(_isHelloFresh ? "Skann forside for å fylle ut..." : "f.eks. Bestemors lasagne")"
                      Required="true"
                      Class="mb-4"
                      Style="--mud-default-borderradius: 12px;" />

        <MudTextField @bind-Value="_newFood.Description"
                      Label="Beskrivelse"
                      Variant="Variant.Outlined"
                      Lines="4"
                      Placeholder="Beskriv retten..."
                      Style="--mud-default-borderradius: 12px;" />

        @* Collapsible structured ingredients section *@
        <MudExpansionPanels Class="mt-4" Elevation="0">
            <MudExpansionPanel Text="@GetIngredientsTitle()" Icon="@Icons.Material.Rounded.ShoppingCart" Style="background: var(--mud-palette-background); border-radius: 12px;">
                <div class="d-flex flex-column gap-2">
                    @for (int i = 0; i < _structuredIngredients.Count; i++)
                    {
                        var index = i;
                        <div class="d-flex gap-2 align-center">
                            <MudTextField @bind-Value="_structuredIngredients[index].Name"
                                          Label="Ingrediens"
                                          Variant="Variant.Outlined"
                                          Size="Size.Small"
                                          Style="flex: 2; --mud-default-borderradius: 8px;" />
                            <MudTextField @bind-Value="_structuredIngredients[index].Amount"
                                          Label="Mengde"
                                          Variant="Variant.Outlined"
                                          Size="Size.Small"
                                          Style="flex: 1; --mud-default-borderradius: 8px;" />
                            <MudSelect T="string" @bind-Value="_structuredIngredients[index].Unit"
                                       Label="Enhet"
                                       Variant="Variant.Outlined"
                                       Dense="true"
                                       Style="flex: 1; --mud-default-borderradius: 8px;">
                                <MudSelectItem Value="@("")">-</MudSelectItem>
                                <MudSelectItem Value="@("stk")">stk</MudSelectItem>
                                <MudSelectItem Value="@("g")">g</MudSelectItem>
                                <MudSelectItem Value="@("kg")">kg</MudSelectItem>
                                <MudSelectItem Value="@("dl")">dl</MudSelectItem>
                                <MudSelectItem Value="@("l")">l</MudSelectItem>
                                <MudSelectItem Value="@("ss")">ss</MudSelectItem>
                                <MudSelectItem Value="@("ts")">ts</MudSelectItem>
                                <MudSelectItem Value="@("fedd")">fedd</MudSelectItem>
                            </MudSelect>
                            <MudIconButton Icon="@Icons.Material.Rounded.Delete"
                                           Size="Size.Small"
                                           Color="Color.Error"
                                           OnClick="@(() => RemoveIngredient(index))" />
                        </div>
                    }
                    <MudButton Variant="Variant.Text"
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Rounded.Add"
                               Size="Size.Small"
                               OnClick="AddIngredient"
                               Class="mt-2">
                        Legg til ingrediens
                    </MudButton>
                </div>
            </MudExpansionPanel>
        </MudExpansionPanels>

        @* Collapsible metadata section *@
        <MudExpansionPanels Class="mt-4" Elevation="0">
            <MudExpansionPanel Text="Tilleggsinfo" Style="background: var(--mud-palette-background); border-radius: 12px;">
                <div class="d-flex flex-wrap gap-3">
                    <MudNumericField T="int?" @bind-Value="_newFood.PrepTimeMinutes"
                                     Label="Tilberedningstid (min)"
                                     Variant="Variant.Outlined"
                                     Min="1" Max="300"
                                     Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;"
                                     Adornment="Adornment.Start"
                                     AdornmentIcon="@Icons.Material.Rounded.AccessTime" />

                    <MudNumericField T="int?" @bind-Value="_newFood.Servings"
                                     Label="Porsjoner"
                                     Variant="Variant.Outlined"
                                     Min="1" Max="20"
                                     Style="flex: 1; min-width: 100px; --mud-default-borderradius: 10px;"
                                     Adornment="Adornment.Start"
                                     AdornmentIcon="@Icons.Material.Rounded.People" />
                </div>

                <div class="d-flex flex-wrap gap-3 mt-3">
                    <MudSelect T="string" @bind-Value="_newFood.Difficulty"
                               Label="Vanskelighetsgrad"
                               Variant="Variant.Outlined"
                               Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;"
                               AnchorOrigin="Origin.BottomCenter">
                        <MudSelectItem Value="@((string?)null)">Ikke valgt</MudSelectItem>
                        <MudSelectItem Value="@("easy")">Lett</MudSelectItem>
                        <MudSelectItem Value="@("medium")">Middels</MudSelectItem>
                        <MudSelectItem Value="@("hard")">Vanskelig</MudSelectItem>
                    </MudSelect>

                    <MudTextField @bind-Value="_newFood.Cuisine"
                                  Label="Kjøkken / Type"
                                  Variant="Variant.Outlined"
                                  Placeholder="f.eks. Italiensk, Asiatisk..."
                                  Style="flex: 1; min-width: 140px; --mud-default-borderradius: 10px;" />
                </div>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </div>

    <div class="form-section">
        <p class="form-section-title">Bilder</p>

        @if (_imagePreviewUrls.Any())
        {
            <div class="image-preview-grid">
                @for (int i = 0; i < _imagePreviewUrls.Count; i++)
                {
                    var index = i;
                    <div class="image-preview-item">
                        <img src="@_imagePreviewUrls[index]" />
                        <button class="image-preview-remove" @onclick="@(() => RemoveImage(index))">
                            <MudIcon Icon="@Icons.Material.Rounded.Close" Size="Size.Small" />
                        </button>
                    </div>
                }
            </div>
        }

        <div class="d-flex gap-3 w-100">
            @if (_isHelloFresh)
            {
                <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Rounded.DocumentScanner" Size="Size.Large" OnClick="StartCamera" Class="flex-1" Style="border-radius: 12px; height: 56px;">Skann</MudButton>
            }
            else
            {
                <MudFileUpload T="IReadOnlyList<IBrowserFile>" @ref="@_fileUpload" FilesChanged="OnImagesSelected" Accept="image/*" MaximumFileCount="5" Class="flex-1" @attributes="@(new Dictionary<string, object> { { "capture", "environment" } })">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Rounded.CameraAlt" Size="Size.Large" FullWidth="true" Style="border-radius: 12px; height: 56px;">Ta bilde</MudButton>
                    </ActivatorContent>
                </MudFileUpload>
            }
            <input type="file" id="galleryInput" accept="image/*, .heic" multiple style="display: none;" @onchange="OnGalleryFileSelected" />
            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Rounded.PhotoLibrary" Size="Size.Large" OnClick="TriggerGalleryClick" Class="flex-1" Style="border-radius: 12px; height: 56px; border-style: dashed; border-width: 2px;">Galleri</MudButton>
        </div>
    </div>

    @* --- PRIVACY & COLLECTION SELECTION --- *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center">
            <p class="form-section-title mb-0">Deling</p>
            <MudSwitch T="bool"
                       Value="@_shareWithCollection"
                       ValueChanged="OnShareCollectionToggled"
                       Color="Color.Primary"
                       Label="Legg til i samling" />
        </div>

        @if (_shareWithCollection)
        {
            <div class="mt-3 animate-in">
                @if (CollectionState.UserCollections.Any())
                {
                    <MudSelect T="Guid?"
                               Label="Velg samling"
                               Value="@_selectedCollectionId"
                               ValueChanged="OnCollectionSelectionChanged"
                               Variant="Variant.Outlined">
                        @foreach (var collection in CollectionState.UserCollections)
                        {
                            <MudSelectItem Value="@((Guid?)collection.Id)">@collection.Name</MudSelectItem>
                        }
                    </MudSelect>

                    @* Quick create new collection *@
                    <div class="mt-2">
                        @if (_showCreateCollection)
                        {
                            <div class="d-flex gap-2 align-center">
                                <MudTextField @bind-Value="_newCollectionName"
                                              Label="Navn på samling"
                                              Variant="Variant.Outlined"
                                              Size="Size.Small"
                                              Style="flex: 1; --mud-default-borderradius: 8px;" />
                                <MudIconButton Icon="@Icons.Material.Rounded.Check"
                                               Color="Color.Success"
                                               Size="Size.Small"
                                               OnClick="CreateNewCollection" />
                                <MudIconButton Icon="@Icons.Material.Rounded.Close"
                                               Color="Color.Default"
                                               Size="Size.Small"
                                               OnClick="CancelCreateCollection" />
                            </div>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Text" Color="Color.Primary" Size="Size.Small"
                                       StartIcon="@Icons.Material.Rounded.Add"
                                       OnClick="ShowCreateCollectionDialog">
                                Opprett ny samling
                            </MudButton>
                        }
                    </div>
                }
                else
                {
                    @if (_showCreateCollection)
                    {
                        <div class="d-flex gap-2 align-center mt-2">
                            <MudTextField @bind-Value="_newCollectionName"
                                          Label="Navn på samling"
                                          Variant="Variant.Outlined"
                                          Size="Size.Small"
                                          Style="flex: 1; --mud-default-borderradius: 8px;" />
                            <MudIconButton Icon="@Icons.Material.Rounded.Check"
                                           Color="Color.Success"
                                           Size="Size.Small"
                                           OnClick="CreateNewCollection" />
                            <MudIconButton Icon="@Icons.Material.Rounded.Close"
                                           Color="Color.Default"
                                           Size="Size.Small"
                                           OnClick="CancelCreateCollection" />
                        </div>
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Info" Dense="true" Class="mt-2">
                            Du har ingen samlinger enda.
                            <MudButton Variant="Variant.Text" Color="Color.Primary" Size="Size.Small"
                                       OnClick="ShowCreateCollectionDialog">
                                Opprett en samling
                            </MudButton>
                        </MudAlert>
                    }
                }
            </div>
        }

        <div class="mt-4 d-flex justify-space-between align-center">
            <MudText Typo="Typo.body2">Gjør offentlig (Publiser)</MudText>
            <MudSwitch @bind-Value="_isPublic" Color="Color.Tertiary" />
        </div>
        @if (_isPublic)
        {
            <MudText Typo="Typo.caption" Color="Color.Secondary">Oppskriften blir søkbar for hele fellesskapet.</MudText>
        }
    </div>

    @* --- RATINGS SECTION --- *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-4">
            <p class="form-section-title mb-0">Hvordan smakte det?</p>
            <MudSwitch T="bool" @bind-Value="_ratingEnabled" Color="Color.Primary" Label="Gi vurdering" />
        </div>

        @if (_ratingEnabled)
        {
            <div class="d-flex flex-column gap-3">
                @foreach (var member in _currentRatingMembers)
                {
                    var isMe = member.DisplayName == _currentUserName;
                    bool included = IsMemberIncluded(member.UserId);
                    decimal rating = GetMemberRating(member.UserId);

                    <div class="d-flex align-center gap-2 pa-2" style="background: var(--mud-palette-background); border-radius: 12px; transition: opacity 0.2s; opacity: @(included ? 1 : 0.6);">

                        @* Avatar *@
                        <MudAvatar Size="Size.Medium" Style="@($"background: {GetMemberColor(member.DisplayName)}")">
                            @(string.IsNullOrEmpty(member.DisplayName) ? '?' : member.DisplayName[0])
                        </MudAvatar>

                        @* Name & Slider *@
                        <div class="flex-grow-1 ml-2">
                            <div class="d-flex justify-space-between">
                                <MudText Typo="Typo.body2" Style="font-weight: 600;">@member.DisplayName</MudText>
                                @if (included)
                                {
                                    <span style="font-size: 0.8rem; font-weight: 700; color: @GetRatingTextColor((int)rating);">@rating.ToString("0.0")/10</span>
                                }
                            </div>

                            <MudSlider T="decimal"
                                       Value="rating"
                                       ValueChanged="@((decimal v) => SetMemberRating(member.UserId, v))"
                                       Min="0" Max="10" Step="0.1M"
                                       Color="Color.Primary"
                                       Disabled="@(!included)"
                                       Class="my-0" />
                        </div>

                        @* Toggle *@
                        <MudSwitch T="bool"
                                   Value="included"
                                   ValueChanged="@((bool v) => SetMemberIncluded(member.UserId, v))"
                                   Color="Color.Success"
                                   UnCheckedColor="Color.Default"
                                   Size="Size.Medium"
                                   Class="ml-1" />
                    </div>
                }
            </div>
        }
    </div>

    <div class="form-section" style="border:none; background:transparent; padding:0;">
        <MudButton Variant="Variant.Filled"
                   Color="@(_isHelloFresh ? Color.Success : Color.Primary)"
                   Size="Size.Large"
                   FullWidth="true"
                   OnClick="SubmitFood"
                   Disabled="_isSubmitting"
                   Style="border-radius: 14px; padding: 14px; height: 56px;">
            @if (_isSubmitting)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" Color="Color.Surface" />
                <span>Lagrer...</span>
            }
            else
            {
                <MudIcon Icon="@Icons.Material.Rounded.Check" Class="mr-2" />
                <span>Lagre måltid</span>
            }
        </MudButton>
    </div>
</div>

@code {
    #region State Variables
    private FoodItem _newFood = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private bool _isSubmitting = false;
    private bool _fromDraft = false;
    private string? _errorMessage;
    private List<string> _imagePreviewUrls = new();
    private List<byte[]> _imageData = new();
    private List<string> _imageNames = new();
    private List<string> _draftImageUrls = new();

    private bool _ratingEnabled = true;
    private string _currentUserName = "";
    private bool _isHelloFresh = false;

    // Collection & Privacy State
    private bool _shareWithCollection = false;
    private bool _isPublic = false;
    private Guid? _selectedCollectionId;
    private string _newCollectionName = "";
    private bool _showCreateCollection = false;

    // Member list for rating (Filtered based on selection)
    private List<CollectionMemberDto> _currentRatingMembers = new();

    // Structured ingredients
    private List<IngredientEntry> _structuredIngredients = new();
    public class IngredientEntry { public string Name { get; set; } = ""; public string Amount { get; set; } = ""; public string Unit { get; set; } = ""; }
    #endregion

    #region Camera & OCR State
    private ElementReference _videoElement;
    private bool _showCameraOverlay = false;
    private bool _isProcessingOcr = false;
    private enum ScanStep { Front, Ingredients, Back, Finished }
    private ScanStep _currentStep = ScanStep.Front;
    public class ProcessedImage { public string Name { get; set; } = ""; public string Data { get; set; } = ""; }
    #endregion

    #region Ratings State
    private Dictionary<Guid, decimal> _memberRatings = new();
    private Dictionary<Guid, bool> _memberIncluded = new();
    #endregion

    protected override async Task OnInitializedAsync()
    {
        await CollectionState.InitializeAsync();
        _currentUserName = AuthService.CurrentUserName ?? "Unknown";

        // Auto-select first collection if available
        if (CollectionState.UserCollections.Any())
        {
            _shareWithCollection = true;
            _selectedCollectionId = CollectionState.UserCollections.First().Id;
        }
        else
        {
            _shareWithCollection = false;
        }

        await UpdateRatingMemberListAsync();

        if (FoodService.DraftRecipe != null)
        {
            LoadDraft(FoodService.DraftRecipe);
        }
    }

    private async Task OnShareCollectionToggled(bool toggled)
    {
        _shareWithCollection = toggled;

        if (_shareWithCollection && _selectedCollectionId == null && CollectionState.UserCollections.Any())
        {
            _selectedCollectionId = CollectionState.UserCollections.First().Id;
        }

        await UpdateRatingMemberListAsync();
    }

    private async Task OnCollectionSelectionChanged(Guid? collectionId)
    {
        _selectedCollectionId = collectionId;
        await UpdateRatingMemberListAsync();
    }

    private async Task UpdateRatingMemberListAsync()
    {
        if (_shareWithCollection && _selectedCollectionId.HasValue)
        {
            // Get members of the selected collection
            try
            {
                _currentRatingMembers = await CollectionState.GetCollectionMembersAsync(_selectedCollectionId.Value);
            }
            catch
            {
                _currentRatingMembers = new List<CollectionMemberDto>();
            }
        }
        else
        {
            // If private, only show current user
            _currentRatingMembers = new List<CollectionMemberDto>();

            // Try to get current user info from any collection they belong to
            foreach (var collection in CollectionState.UserCollections)
            {
                try
                {
                    var members = await CollectionState.GetCollectionMembersAsync(collection.Id);
                    var myMemberInfo = members.FirstOrDefault(m => m.DisplayName == _currentUserName);
                    if (myMemberInfo != null)
                    {
                        _currentRatingMembers.Add(myMemberInfo);
                        break;
                    }
                }
                catch { /* Continue to next collection */ }
            }
        }

        // Initialize dictionaries for new members
        foreach (var member in _currentRatingMembers)
        {
            if (!_memberIncluded.ContainsKey(member.UserId)) _memberIncluded[member.UserId] = true;
            if (!_memberRatings.ContainsKey(member.UserId)) _memberRatings[member.UserId] = 5m;
        }
    }

    private void LoadDraft(FoodItem draft)
    {
        _newFood.Name = draft.Name;
        _newFood.Description = draft.Description;
        _newFood.PrepTimeMinutes = draft.PrepTimeMinutes;
        _newFood.CookTimeMinutes = draft.CookTimeMinutes;
        _newFood.Servings = draft.Servings;
        _newFood.Difficulty = draft.Difficulty;
        _newFood.Cuisine = draft.Cuisine;
        _newFood.Ingredients = draft.Ingredients;
        _newFood.GlobalRecipeId = draft.GlobalRecipeId;
        _newFood.IsHelloFresh = draft.IsHelloFresh;
        _isHelloFresh = draft.IsHelloFresh;
        _fromDraft = true;
        if (draft.ImageUrls != null)
        {
            _imagePreviewUrls.AddRange(draft.ImageUrls);
            _draftImageUrls.AddRange(draft.ImageUrls);
        }
        FoodService.DraftRecipe = null;
    }

    private void SetFoodType(bool isHelloFresh) => _isHelloFresh = isHelloFresh;

    #region Dictionary Helpers
    private bool IsMemberIncluded(Guid userId) => _memberIncluded.ContainsKey(userId) && _memberIncluded[userId];
    private decimal GetMemberRating(Guid userId) => _memberRatings.ContainsKey(userId) ? _memberRatings[userId] : 5m;
    private void SetMemberIncluded(Guid userId, bool value) => _memberIncluded[userId] = value;
    private void SetMemberRating(Guid userId, decimal value) => _memberRatings[userId] = value;
    #endregion

    #region Submission Logic
    private async Task SubmitFood()
    {
        if (string.IsNullOrWhiteSpace(_newFood.Name))
        {
            _errorMessage = "Navn mangler.";
            return;
        }
        _isSubmitting = true;
        try
        {
            var urls = new List<string>(_draftImageUrls);
            for (int i = 0; i < _imageData.Count; i++)
                urls.Add(await FoodService.UploadImageAsync(_imageData[i], _imageNames[i]));

            var ratingsToSend = new Dictionary<Guid, decimal>();
            if (_ratingEnabled)
            {
                foreach (var member in _currentRatingMembers)
                {
                    if (IsMemberIncluded(member.UserId))
                    {
                        ratingsToSend[member.UserId] = GetMemberRating(member.UserId);
                    }
                }
            }

            // Determine Visibility - only "private" or "public" now (no more "household")
            string finalVisibility = _isPublic ? "public" : "private";

            // Use structured ingredients if any are filled in, otherwise use existing (from draft/OCR)
            var finalIngredients = BuildIngredientsJson() ?? _newFood.Ingredients;

            var createDto = new CreateUserRecipeDto
            {
                Name = _newFood.Name,
                Description = _newFood.Description,
                ImageUrls = urls,
                PersonalNotes = _newFood.PersonalNotes,
                GlobalRecipeId = _newFood.GlobalRecipeId,
                Visibility = finalVisibility,
                MemberRatings = ratingsToSend,
                // Metadata fields
                PrepTimeMinutes = _newFood.PrepTimeMinutes,
                Servings = _newFood.Servings,
                Difficulty = _newFood.Difficulty,
                Cuisine = _newFood.Cuisine,
                Ingredients = finalIngredients
            };

            var createdRecipe = await RecipeService.CreateRecipeAsync(createDto);

            // If sharing with a collection, add the recipe to that collection
            if (_shareWithCollection && _selectedCollectionId.HasValue && createdRecipe != null)
            {
                await CollectionState.AddRecipeToCollectionAsync(_selectedCollectionId.Value, createdRecipe.Id);
            }

            RecipeService.InvalidateCache();
            Navigation.NavigateTo("");
        }
        catch (Exception ex) { _errorMessage = ex.Message; }
        finally { _isSubmitting = false; }
    }
    #endregion

    #region Image & OCR
    private async Task TriggerGalleryClick() => await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('galleryInput').click()");

    private async Task OnGalleryFileSelected()
    {
        try
        {
            _isSubmitting = true;
            if (_isHelloFresh) _isProcessingOcr = true;
            StateHasChanged();

            var images = await JSRuntime.InvokeAsync<List<ProcessedImage>>("imageTools.processInputFile", "galleryInput");
            if (images == null || images.Count == 0) return;

            bool ingredientsFound = false;

            for (int i = 0; i < images.Count; i++)
            {
                var img = images[i];
                if (_imageData.Count < 5)
                {
                    var base64Pure = img.Data.Split(',')[1];
                    _imageData.Add(Convert.FromBase64String(base64Pure));
                    _imagePreviewUrls.Add(img.Data);
                    _imageNames.Add(img.Name);
                }

                if (_isHelloFresh)
                {
                    if (i == 0 && string.IsNullOrWhiteSpace(_newFood.Name))
                    {
                        Snackbar.Add("Analyserer forside...", Severity.Info);
                        await TryAutoFillTitle(img.Data);
                    }
                    if (!ingredientsFound && string.IsNullOrWhiteSpace(_newFood.Description))
                    {
                        if (i == 0 && !string.IsNullOrWhiteSpace(_newFood.Name)) continue;
                        Snackbar.Add($"Ser etter ingredienser (Bilde {i + 1})...", Severity.Info);
                        ingredientsFound = await TryExtractIngredients(img.Data);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Feil i galleri-opplasting: {ex.Message}");
            Snackbar.Add("Noe gikk galt med bildebehandlingen.", Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            _isProcessingOcr = false;
            StateHasChanged();
        }
    }

    private async Task TryAutoFillTitle(string dataUrl)
    {
        try
        {
            var rawText = await OcrService.RecognizeTextAsync(dataUrl);
            if (!string.IsNullOrWhiteSpace(rawText))
            {
                var lines = rawText.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines)
                {
                    var cleanLine = line.Trim();
                    cleanLine = System.Text.RegularExpressions.Regex.Replace(cleanLine, @"\b(HELLO|FRESH|OPPSKRIFT|RECIPE)\b", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    cleanLine = System.Text.RegularExpressions.Regex.Replace(cleanLine, @"^[^a-zA-ZæøåÆØÅ0-9]+", "").Trim();

                    if (cleanLine.Length > 5 && cleanLine.Length < 60 && cleanLine.Any(char.IsLetter))
                    {
                        _newFood.Name = char.ToUpper(cleanLine[0]) + cleanLine.Substring(1);
                        Snackbar.Add($"Tittel funnet: {_newFood.Name}", Severity.Success);
                        await InvokeAsync(StateHasChanged);
                        break;
                    }
                }
            }
        }
        catch (Exception ex) { Console.WriteLine($"Title OCR Error: {ex}"); }
    }

    private async Task<bool> TryExtractIngredients(string dataUrl)
    {
        try
        {
            var rawText = await OcrService.RecognizeTextAsync(dataUrl);
            if (string.IsNullOrWhiteSpace(rawText)) return false;

            var rawLines = rawText.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
            var flattenedList = new List<string>();

            foreach (var line in rawLines)
            {
                var columns = System.Text.RegularExpressions.Regex.Split(line, @"\s{3,}");
                foreach (var col in columns)
                {
                    var trimmed = System.Text.RegularExpressions.Regex.Replace(col.Trim(), @"^[^a-zA-ZæøåÆØÅ0-9]+", "").Trim();
                    if (trimmed.Length > 2) flattenedList.Add(trimmed);
                }
            }

            var cleanIngredients = new List<string>();
            int foodConfidence = 0;
            var commonFoodWords = new HashSet<string>(StringComparer.OrdinalIgnoreCase) {
                "gulrot", "potet", "løk", "hvitløk", "tomat", "agurk", "salat", "kylling", "kjøtt", "biff", "svin", "fisk", "laks", "torsk",
                "ris", "pasta", "nudler", "saus", "fløte", "rømme", "ost", "smør", "olje", "krydder", "salt", "pepper"
            };

            foreach (var currentLine in flattenedList)
            {
                if (currentLine.Split(' ').Any(word => commonFoodWords.Contains(word.Trim(',', '.')))) foodConfidence++;

                bool isContinuation = cleanIngredients.Count > 0 && (char.IsLower(currentLine[0]) || currentLine.StartsWith("("));
                if (isContinuation)
                {
                    int lastIdx = cleanIngredients.Count - 1;
                    cleanIngredients[lastIdx] = cleanIngredients[lastIdx] + " " + currentLine;
                }
                else
                {
                    cleanIngredients.Add(char.ToUpper(currentLine[0]) + currentLine.Substring(1));
                }
            }

            if (foodConfidence >= 2 || (cleanIngredients.Count >= 4 && cleanIngredients.All(i => i.Length < 50)))
            {
                cleanIngredients = cleanIngredients.Distinct().ToList();
                if (cleanIngredients.Count > 0)
                {
                    _newFood.Description = "Ingredienser:\n" + string.Join("\n", cleanIngredients);
                    await InvokeAsync(StateHasChanged);
                    return true;
                }
            }
            return false;
        }
        catch (Exception ex) { Console.WriteLine($"Ingredient OCR Error: {ex.Message}"); return false; }
    }

    private async Task StartCamera()
    {
        _currentStep = ScanStep.Front;
        _showCameraOverlay = true;
        await Task.Delay(100);
        try { await JSRuntime.InvokeVoidAsync("cameraInterop.start", _videoElement); }
        catch (Exception) { Snackbar.Add("Kunne ikke starte kamera.", Severity.Error); _showCameraOverlay = false; }
    }
    private async Task StopCamera() { await JSRuntime.InvokeVoidAsync("cameraInterop.stop", _videoElement); _showCameraOverlay = false; }

    private async Task CaptureCameraImage()
    {
        if (_isProcessingOcr) return;
        _isProcessingOcr = true;
        StateHasChanged();
        try
        {
            var base64Data = await JSRuntime.InvokeAsync<string>("cameraInterop.capture", _videoElement);
            var cleanBase64 = base64Data.Contains(",") ? base64Data.Split(',')[1] : base64Data;
            _imagePreviewUrls.Add(base64Data);
            _imageData.Add(Convert.FromBase64String(cleanBase64));

            if (_currentStep == ScanStep.Front)
            {
                _imageNames.Add("hf_front.jpg");
                Snackbar.Add("Forside fanget! Analyserer...", Severity.Info);
                await TryAutoFillTitle(base64Data);
                _currentStep = ScanStep.Ingredients;
            }
            else if (_currentStep == ScanStep.Ingredients)
            {
                _imageNames.Add("hf_ingr.jpg");
                Snackbar.Add("Ingredienser fanget!", Severity.Info);
                await TryExtractIngredients(base64Data);
                _currentStep = ScanStep.Back;
            }
            else if (_currentStep == ScanStep.Back)
            {
                _imageNames.Add("hf_back.jpg");
                Snackbar.Add("Ferdig!", Severity.Success);
                await StopCamera();
                _currentStep = ScanStep.Finished;
            }
        }
        catch { Snackbar.Add("Feil ved bildeopptak.", Severity.Error); }
        finally { _isProcessingOcr = false; StateHasChanged(); }
    }

    private async Task OnImagesSelected(IReadOnlyList<IBrowserFile> files)
    {
        foreach (var file in files)
        {
            if (_imageData.Count >= 5) break;
            var fileToRead = await file.RequestImageFileAsync("image/jpeg", 1200, 1200);
            using var stream = fileToRead.OpenReadStream(30 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var buffer = ms.ToArray();
            _imagePreviewUrls.Add($"data:image/jpeg;base64,{Convert.ToBase64String(buffer)}");
            _imageData.Add(buffer);
            _imageNames.Add(file.Name);
        }
    }
    private void RemoveImage(int index)
    {
        if (index < _draftImageUrls.Count) { _draftImageUrls.RemoveAt(index); _imagePreviewUrls.RemoveAt(index); }
        else
        {
            var newIdx = index - _draftImageUrls.Count;
            if (newIdx >= 0 && newIdx < _imageData.Count) { _imageData.RemoveAt(newIdx); _imageNames.RemoveAt(newIdx); _imagePreviewUrls.RemoveAt(index); }
        }
    }
    #endregion

    #region Collection Methods
    private void ShowCreateCollectionDialog()
    {
        _showCreateCollection = true;
        _newCollectionName = "";
    }

    private async Task CreateNewCollection()
    {
        if (string.IsNullOrWhiteSpace(_newCollectionName))
        {
            Snackbar.Add("Samlingsnavn kan ikke være tomt.", Severity.Warning);
            return;
        }

        try
        {
            var newCollection = await CollectionState.CreateCollectionAsync(_newCollectionName);
            _selectedCollectionId = newCollection.Id;
            _shareWithCollection = true;
            _showCreateCollection = false;
            _newCollectionName = "";
            await UpdateRatingMemberListAsync();
            Snackbar.Add($"Samlingen '{newCollection.Name}' ble opprettet!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke opprette samling: {ex.Message}", Severity.Error);
        }
    }

    private void CancelCreateCollection()
    {
        _showCreateCollection = false;
        _newCollectionName = "";
    }
    #endregion

    #region Helpers
    private string GetMemberColor(string? n) => string.IsNullOrEmpty(n) ? "grey" : $"hsl({Math.Abs(n.GetHashCode() % 360)}, 45%, 45%)";
    private string GetRatingBackground(int r) => r >= 8 ? "rgba(45,90,69,0.15)" : r >= 5 ? "rgba(212,160,23,0.15)" : "rgba(196,69,54,0.15)";
    private string GetRatingTextColor(int r) => r >= 8 ? "#2D5A45" : r >= 5 ? "#A17D00" : "#C44536";
    private string GetOverlayClass() => _currentStep switch { ScanStep.Front => "step-landscape", ScanStep.Ingredients => "step-portrait-tall", _ => "step-portrait-normal" };
    private string GetStepTitle() => _currentStep switch { ScanStep.Front => "1: FORSIDE (SNU)", ScanStep.Ingredients => "2: INGREDIENSER", ScanStep.Back => "3: FREMGANGSMÅTE", _ => "" };
    private string GetInstructionText() => _currentStep == ScanStep.Front ? "Hold telefonen vannrett." : "Hold telefonen loddrett.";
    private string GetStepIcon() => _currentStep == ScanStep.Front ? Icons.Material.Rounded.ScreenRotation : Icons.Material.Rounded.CropPortrait;
    #endregion

    #region Ingredients Helpers
    private void AddIngredient() => _structuredIngredients.Add(new IngredientEntry());
    private void RemoveIngredient(int index)
    {
        if (index >= 0 && index < _structuredIngredients.Count)
            _structuredIngredients.RemoveAt(index);
    }
    private string GetIngredientsTitle() => _structuredIngredients.Count > 0
        ? $"Ingredienser ({_structuredIngredients.Count})"
        : "Ingredienser (valgfritt)";

    private object? BuildIngredientsJson()
    {
        var validIngredients = _structuredIngredients
            .Where(i => !string.IsNullOrWhiteSpace(i.Name))
            .Select(i => new { name = i.Name, amount = i.Amount, unit = i.Unit })
            .ToList();
        return validIngredients.Any() ? validIngredients : null;
    }
    #endregion

}

================================================================================
FILE END: \StorhaugenWebsite\Pages\AddFood.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Archived.razor
================================================================================
@page "/archived"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.Services
@inject IAuthService AuthService
@inject IFoodService FoodService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@attribute [Authorize]

<div class="d-flex align-center gap-3 mb-6">
    <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Arkiv</h1>
    @if (_archivedItems.Any())
    {
        <p class="page-subtitle" style="margin: 0;">@_archivedItems.Count arkiverte mltider</p>
    }
</div>

@if (_isLoading)
{
    <div class="d-flex flex-column gap-2">
        @for (int i = 0; i < 3; i++)
        {
            <div class="skeleton-card">
                <div class="skeleton-content" style="display: flex; gap: 12px;">
                    <div style="width: 60px; height: 60px; border-radius: 12px; background: var(--mud-palette-divider-light);"></div>
                    <div style="flex: 1;">
                        <div class="skeleton-text title" style="margin-bottom: 8px;"></div>
                        <div class="skeleton-text subtitle"></div>
                    </div>
                </div>
            </div>
        }
    </div>
}
else if (!_archivedItems.Any())
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.Inventory2" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Ingen arkiverte mltider</h2>
        <p class="empty-state-text">Arkiverte mltider vil vises her</p>
    </div>
}
else
{
    <div class="d-flex flex-column gap-2">
        @{
            var index = 0;
        }
        @foreach (var food in _archivedItems.OrderByDescending(f => f.ArchivedDate))
        {
            var currentFood = food;
            var delay = index++;
            <div class="food-list-item animate-in animate-delay-@Math.Min(delay, 4)" style="opacity: 0.85;">
                @if (currentFood.ImageUrls.Any())
                {
                    <img src="@currentFood.ImageUrls.First()"
                         alt="@currentFood.Name"
                         class="food-list-image"
                         style="filter: grayscale(40%);" />
                }
                else
                {
                    <div class="food-list-placeholder">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" />
                    </div>
                }
                <div class="food-list-content" @onclick="@(() => ViewFood(currentFood))">
                    <h3 class="food-list-title">@currentFood.Name</h3>
                    <p class="food-list-date">
                        Arkivert @(currentFood.ArchivedDate?.ToString("dd. MMM yyyy") ?? "")
                        @if (!string.IsNullOrEmpty(currentFood.ArchivedBy))
                        {
                            <span> av @currentFood.ArchivedBy</span>
                        }
                    </p>
                </div>
                <div class="d-flex gap-1 align-center">
                    <MudIconButton Icon="@Icons.Material.Rounded.Visibility"
                                   Size="Size.Small"
                                   OnClick="@(() => ViewFood(currentFood))" />
                    <MudIconButton Icon="@Icons.Material.Rounded.Restore"
                                   Size="Size.Small"
                                   Color="Color.Primary"
                                   OnClick="@(() => RestoreFood(currentFood))" />
                </div>
            </div>
        }
    </div>
}

@code {
    private List<FoodItem> _archivedItems = new();
    private bool _isLoading = false; // Default to false, let logic handle it

    protected override async Task OnInitializedAsync()
    {
        await LoadArchivedItems();
    }

    private async Task LoadArchivedItems()
    {
        _isLoading = true;
        try
        {
            var allItems = await FoodService.GetAllFoodsAsync(includeArchived: true);
            _archivedItems = allItems.Where(f => f.IsArchived).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading archived items: {ex.Message}");
            // Optionally show snackbar error here if it wasn't expected
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void ViewFood(FoodItem food)
    {
        Navigation.NavigateTo($"food/{food.Id}");
    }

    private async Task RestoreFood(FoodItem food)
    {
        try
        {
            await FoodService.RestoreFoodAsync(food.Id);
            _archivedItems.Remove(food);
            Snackbar.Add($"'{food.Name}' gjenopprettet!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Archived.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Browse.razor
================================================================================
@page "/browse"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Components
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Shared.Extensions
@inject IApiClient ApiClient
@inject IUserRecipeService RecipeService
@inject NavigationManager Navigation
@inject IDeviceStateService DeviceState
@inject ISnackbar Snackbar
@attribute [Authorize]

@* --- Search & Filters --- *@
<div class="d-flex flex-column gap-3 mb-4">
    <MudTextField @bind-Value="_searchQuery"
                  Label="Søk etter oppskrifter"
                  Variant="Variant.Outlined"
                  Adornment="Adornment.Start"
                  AdornmentIcon="@Icons.Material.Rounded.Search"
                  OnKeyUp="OnSearchKeyUp"
                  Immediate="false"
                  DebounceInterval="500"
                  Class="search-field" />

    <div class="d-flex justify-space-between align-center flex-wrap gap-2">
        <div class="d-flex gap-2">
            <MudChip T="string"
                     Color="@(_sourceMode == "community" ? Color.Primary : Color.Default)"
                     OnClick="@(() => SetSourceMode("community"))"
                     Icon="@Icons.Material.Rounded.People">
                Fellesskapet
            </MudChip>
            <MudChip T="string"
                     Color="@(_sourceMode == "hellofresh" ? Color.Success : Color.Default)"
                     OnClick="@(() => SetSourceMode("hellofresh"))"
                     Icon="@Icons.Material.Rounded.LocalDining">
                HelloFresh
            </MudChip>
        </div>
    </div>

    @* --- Compact controls row for HelloFresh: Week selector + Sort --- *@
    @if (_sourceMode == "hellofresh")
    {
        <div class="hellofresh-controls-row">
            @* Swipeable Week Selector *@
            <div class="week-selector-swipeable">
                <div class="week-chips-scroll" @ref="_weekScrollContainer">
                    @foreach (var weekOption in GetAllWeekOptions())
                    {
                        <MudChip T="string"
                                 Size="Size.Small"
                                 Color="@(GetSelectedWeek() == weekOption.Week ? Color.Success : Color.Default)"
                                 Variant="@(GetSelectedWeek() == weekOption.Week ? Variant.Filled : Variant.Outlined)"
                                 OnClick="@(() => SelectWeek(weekOption.Week))"
                                 Class="week-chip-compact">
                            @weekOption.ShortLabel
                        </MudChip>
                    }
                </div>

                @if (!string.IsNullOrEmpty(_selectedWeek))
                {
                    <MudIconButton Icon="@Icons.Material.Rounded.FilterAltOff"
                                   Size="Size.Small"
                                   OnClick="ClearWeekFilter"
                                   Title="Vis alle uker"
                                   Class="week-clear-btn" />
                }
            </div>

            @* Sorting dropdown - always inline *@
            <MudSelect T="string" @bind-Value="_sortBy" Variant="Variant.Outlined" Margin="Margin.Dense"
                       Class="sort-select-inline" Dense="true">
                <MudSelectItem Value="@("popular")">Populære</MudSelectItem>
                <MudSelectItem Value="@("preptime")">Tid</MudSelectItem>
                <MudSelectItem Value="@("difficulty")">Nivå</MudSelectItem>
                <MudSelectItem Value="@("newest")">Nyeste</MudSelectItem>
            </MudSelect>
        </div>
    }
</div>

@* --- Content (XFade) ---
   This page should "instantly" switch content on filter changes:
   - We DO want skeleton on reloads (CrossfadeOnReload)
   - We make entering loading state instant via .browse-xfade overrides (no fade-out linger)
*@
<div class="browse-xfade">
    <XFade IsLoading="@_isLoading"
           FirstLoadOnly="false"
           CrossfadeOnReload="true"
           FadeMs="220">
        <Skeleton>
            <RecipeSkeleton Amount="6" Height="109.11px" />
        </Skeleton>

        <ChildContent>
            @if (!_recipes.Any())
            {
                <div class="empty-state">
                    <div class="empty-state-icon">
                        <MudIcon Icon="@(_sourceMode == "community" ? Icons.Material.Rounded.People : Icons.Material.Rounded.SearchOff)" Size="Size.Large" />
                    </div>
                    <h2 class="empty-state-title">Ingen oppskrifter funnet</h2>
                    <p class="empty-state-text">
                        @(_sourceMode == "community" ? "Bli den første til å dele en oppskrift!" : "Prøv et annet søk eller velg en annen uke.")
                    </p>
                </div>
            }
            else
            {
                <div class="d-flex flex-column gap-4">
                    @foreach (var recipe in _recipes)
                    {
                        <div class="food-card" @onclick="() => OpenRecipeDetail(recipe)">

                            @* --- Image section - HelloFresh recipes don't show images (images are broken), community recipes show their images --- *@
                            @if (!recipe.IsHellofresh)
                            {
                                @if (GetImageUrl(recipe) != null)
                                {
                                    <img src="@GetImageUrl(recipe)" alt="@recipe.Name" class="food-card-image" />
                                }
                                else
                                {
                                    <div class="food-card-placeholder">
                                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Large" />
                                    </div>
                                }
                            }

                            @* --- Text Content --- *@
                            <div class="food-card-content">
                                <div class="d-flex justify-space-between align-start gap-3">
                                    <div class="d-flex align-center gap-2" style="min-width: 0;">
                                        @if (recipe.IsHellofresh)
                                        {
                                            <MudIcon Icon="@Icons.Material.Rounded.LocalDining" Size="Size.Small" Color="Color.Success" Title="HelloFresh" Style="flex-shrink: 0;" />
                                        }
                                        else
                                        {
                                            <MudIcon Icon="@Icons.Material.Rounded.Cloud" Size="Size.Small" Color="Color.Info" Title="Fellesskapet" Style="flex-shrink: 0;" />
                                        }
                                        <h3 class="food-card-title">@recipe.Name</h3>
                                    </div>

                                    @if (recipe.AverageRating > 0)
                                    {
                                        <div class="d-flex flex-column align-end" style="flex-shrink: 0;">
                                            <span class="rating-badge" style="color:@recipe.AverageRating.ToRatingColorHex();">
                                                <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                                                @recipe.AverageRating.ToString("0.0")
                                            </span>
                                            @if (recipe.TotalRatings > 0)
                                            {
                                                <span class="rating-count-badge">
                                                    <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" Style="font-size: 10px;" />
                                                    @recipe.TotalRatings
                                                </span>
                                            }
                                        </div>
                                    }
                                </div>

                                @if (!recipe.IsHellofresh && !string.IsNullOrEmpty(recipe.CreatedByUserName))
                                {
                                    <div class="d-flex align-center gap-1">
                                        <MudIcon Icon="@Icons.Material.Rounded.Person" Size="Size.Small" Style="font-size: 12px; opacity: 0.6;" />
                                        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="text-truncate" Style="font-size: 0.75rem;">
                                            @recipe.CreatedByUserName
                                        </MudText>
                                    </div>
                                }

                                @* Recipe metadata chips - Show for both HelloFresh and Community *@
                                <div class="food-card-meta mt-2 d-flex gap-2 align-center flex-wrap">
                                    @if (recipe.PrepTimeMinutes.HasValue)
                                    {
                                        <span class="meta-chip">
                                            <MudIcon Icon="@Icons.Material.Rounded.AccessTime" Size="Size.Small" />
                                            @recipe.PrepTimeMinutes min
                                        </span>
                                    }
                                    @if (!string.IsNullOrEmpty(recipe.Difficulty))
                                    {
                                        <span class="meta-chip @GetDifficultyClass(recipe.Difficulty)">
                                            <MudIcon Icon="@GetDifficultyIcon(recipe.Difficulty)" Size="Size.Small" />
                                            @GetDifficultyLabel(recipe.Difficulty)
                                        </span>
                                    }
                                </div>
                            </div>
                        </div>
                    }
                </div>

                @* --- Pagination --- *@
                @if (_totalPages > 1)
                {
                    <div class="d-flex justify-center align-center gap-2 mt-4">
                        <MudIconButton Icon="@Icons.Material.Rounded.ChevronLeft" OnClick="PreviousPage" Disabled="@(_currentPage <= 1)" Size="Size.Small" />
                        <MudText Typo="Typo.body2">Side @_currentPage av @_totalPages</MudText>
                        <MudIconButton Icon="@Icons.Material.Rounded.ChevronRight" OnClick="NextPage" Disabled="@(_currentPage >= _totalPages)" Size="Size.Small" />
                    </div>
                }
            }
        </ChildContent>
    </XFade>
</div>

<style>
    .search-field { max-width: 100%; }

    .food-card-content { padding: 16px; }

    .rating-badge {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        flex-shrink: 0;
    }

    .rating-high {
        background: rgba(76, 175, 80, 0.1);
        color: #2e7d32;
    }

    .rating-hellofresh {
        background: rgba(154, 205, 50, 0.15);
        color: #6B8E23;
    }

    .empty-state {
        text-align: center;
        padding: 60px 20px;
    }

    .empty-state-icon {
        font-size: 4rem;
        color: var(--mud-palette-text-secondary);
        margin-bottom: 16px;
    }

    .skeleton-card {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        overflow: hidden;
        height: 280px;
    }

    .skeleton-image {
        width: 100%;
        height: 180px;
        background: linear-gradient(90deg, var(--mud-palette-background-grey) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-background-grey) 75%);
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
    }

    .skeleton-content { padding: 16px; }

    .skeleton-text {
        background: linear-gradient(90deg, var(--mud-palette-background-grey) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-background-grey) 75%);
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .skeleton-text.title { height: 20px; width: 60%; }
    .skeleton-text.subtitle { height: 14px; width: 40%; }

    @@keyframes shimmer {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }

    /* HelloFresh controls row - always inline */
    .hellofresh-controls-row {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
    }

    /* Swipeable Week Selector */
    .week-selector-swipeable {
        display: flex;
        align-items: center;
        gap: 4px;
        flex: 1;
        min-width: 0;
        background: var(--mud-palette-surface);
        padding: 4px 6px;
        border-radius: 8px;
        border: 1px solid var(--mud-palette-lines-default);
    }

    .week-chips-scroll {
        display: flex;
        gap: 4px;
        overflow-x: auto;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        -ms-overflow-style: none;
        flex: 1;
        min-width: 0;
    }

    .week-chips-scroll::-webkit-scrollbar {
        display: none;
    }

    .week-chip-compact {
        font-size: 0.7rem !important;
        height: 24px !important;
        padding: 0 8px !important;
        flex-shrink: 0;
    }

    .week-clear-btn {
        padding: 4px !important;
        min-width: 28px !important;
        width: 28px !important;
        height: 28px !important;
        flex-shrink: 0;
        color: var(--mud-palette-text-secondary);
    }

    .sort-select-inline {
        min-width: 100px !important;
        max-width: 130px;
        flex-shrink: 0;
        font-size: 0.8rem;
    }

    /* Make filter switches feel instant:
       when entering loading state, don't let old content fade out / skeleton fade in. */
    .browse-xfade .xfade.loading .xfade-content,
    .browse-xfade .xfade.loading .xfade-skeleton {
        transition-duration: 0ms !important;
        transition-delay: 0ms !important;
    }

    /* Responsive improvements */
    @@media (max-width: 600px) {
        .food-card-content { padding: 12px; }
        .food-card-title { font-size: 1rem; }
        .meta-chip { font-size: 0.7rem; padding: 3px 6px; }
    }
</style>

@code {
    private List<GlobalRecipeDto> _recipes = new();

    private bool _isLoading = true;
    private bool _isProcessing = false;

    private string _searchQuery = "";
    private string _sourceMode = "hellofresh"; // Default to HelloFresh
    private string _sortBy = "popular";

    private int _currentPage = 1;
    private int _pageSize = 20;
    private int _totalPages = 0;

    // HelloFresh week selection
    private string? _selectedWeek;
    private ElementReference _weekScrollContainer;

    // prevents out-of-order renders if user clicks filters quickly
    private int _loadVersion;

    protected override async Task OnInitializedAsync()
    {
        await LoadRecipes();
    }

    private async Task SetSourceMode(string mode)
    {
        if (_sourceMode == mode) return;

        _sourceMode = mode;
        _currentPage = 1;
        _selectedWeek = null;
        _sortBy = mode == "hellofresh" ? "popular" : "newest";

        await LoadRecipes();
    }

    // Week selector methods
    private record WeekOption(string Week, string Label, string ShortLabel);

    private List<WeekOption> GetAllWeekOptions()
    {
        var options = new List<WeekOption>();
        var today = DateTime.UtcNow;

        // Generate weeks from -4 to +4 (9 weeks total)
        for (int offset = -4; offset <= 4; offset++)
        {
            var targetDate = today.AddDays(offset * 7);
            var week = GetIsoWeekString(targetDate);
            var shortLabel = GetWeekShortLabel(offset, targetDate);
            options.Add(new WeekOption(week, shortLabel, shortLabel));
        }

        return options;
    }

    private string GetWeekShortLabel(int offsetFromCurrent, DateTime date)
    {
        var weekNum = GetWeekNumber(date);
        return offsetFromCurrent switch
        {
            0 => "Denne",
            -1 => "Forrige",
            1 => "Neste",
            _ => $"Uke {weekNum}"
        };
    }

    private int GetWeekNumber(DateTime date)
    {
        var culture = System.Globalization.CultureInfo.CurrentCulture;
        var calendar = culture.Calendar;
        return calendar.GetWeekOfYear(date, System.Globalization.CalendarWeekRule.FirstFourDayWeek, DayOfWeek.Monday);
    }

    private string GetIsoWeekString(DateTime date)
    {
        var weekNumber = GetWeekNumber(date);
        return $"{date.Year}-W{weekNumber:D2}";
    }

    private string? GetSelectedWeek() => _selectedWeek;

    private async Task SelectWeek(string week)
    {
        _selectedWeek = _selectedWeek == week ? null : week;
        _currentPage = 1;
        await LoadRecipes();
    }

    private async Task ClearWeekFilter()
    {
        _selectedWeek = null;
        _currentPage = 1;
        await LoadRecipes();
    }

    private async Task LoadRecipes()
    {
        var v = ++_loadVersion;

        _isLoading = true;
        await InvokeAsync(StateHasChanged); // show skeleton immediately

        try
        {
            if (_sourceMode == "community")
            {
                var query = new BrowseGlobalRecipesQuery
                {
                    Search = string.IsNullOrWhiteSpace(_searchQuery) ? null : _searchQuery,
                    SortBy = _sortBy,
                    Page = 1,
                    PageSize = 200,
                    HellofreshOnly = false
                };

                var result = await ApiClient.BrowseGlobalRecipesAsync(query);
                if (v != _loadVersion) return;

                var communityRecipes = result.Recipes.Where(r => !r.IsHellofresh).ToList();

                var totalCommunityCount = communityRecipes.Count;
                _totalPages = (int)Math.Ceiling(totalCommunityCount / (double)_pageSize);

                _recipes = communityRecipes
                    .Skip((_currentPage - 1) * _pageSize)
                    .Take(_pageSize)
                    .ToList();
            }
            else
            {
                var query = new BrowseGlobalRecipesQuery
                {
                    Search = string.IsNullOrWhiteSpace(_searchQuery) ? null : _searchQuery,
                    SortBy = _sortBy,
                    Page = _currentPage,
                    PageSize = _pageSize,
                    HellofreshOnly = true,
                    HellofreshWeek = _selectedWeek
                };

                var result = await ApiClient.BrowseGlobalRecipesAsync(query);
                if (v != _loadVersion) return;

                _recipes = result.Recipes;
                _totalPages = result.TotalPages;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading recipes: {ex.Message}");
            Snackbar.Add("Kunne ikke laste oppskrifter", Severity.Error);
        }
        finally
        {
            if (v == _loadVersion)
            {
                _isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            _currentPage = 1;
            await LoadRecipes();
        }
    }

    private async Task PreviousPage()
    {
        if (_currentPage > 1)
        {
            _currentPage--;
            await LoadRecipes();
        }
    }

    private async Task NextPage()
    {
        if (_currentPage < _totalPages)
        {
            _currentPage++;
            await LoadRecipes();
        }
    }

    private void OpenRecipeDetail(GlobalRecipeDto recipe)
    {
        Navigation.NavigateTo($"browse/{recipe.Id}");
    }

    private string? GetImageUrl(GlobalRecipeDto recipe)
    {
        if (!string.IsNullOrEmpty(recipe.ImageUrl)) return recipe.ImageUrl;
        return recipe.ImageUrls?.FirstOrDefault();
    }

    private async Task AddToMyList(GlobalRecipeDto recipe)
    {
        _isProcessing = true;
        try
        {
            // Don't copy images for HelloFresh recipes (they're broken/copyrighted)
            var imageUrls = recipe.IsHellofresh ? new List<string>() : (recipe.ImageUrls ?? new List<string>());

            var dto = new CreateUserRecipeDto
            {
                Name = recipe.Name,
                Description = recipe.Description,
                ImageUrls = imageUrls,
                GlobalRecipeId = recipe.Id,
                PrepTimeMinutes = recipe.PrepTimeMinutes,
                Servings = recipe.Servings,
                Difficulty = recipe.Difficulty,
                Cuisine = recipe.Cuisine,
                Tags = recipe.Tags,
                Ingredients = recipe.Ingredients,
                Visibility = "private"
            };

            await RecipeService.CreateRecipeAsync(dto);
            Snackbar.Add($"'{recipe.Name}' lagt til i din kokebok!", Severity.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error adding recipe: {ex.Message}");
            Snackbar.Add("Klarte ikke å legge til oppskrift", Severity.Error);
        }
        finally
        {
            _isProcessing = false;
        }
    }

    private string GetDifficultyIcon(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
        "medium" or "middels" => Icons.Material.Rounded.Psychology,
        "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
        _ => Icons.Material.Rounded.HelpOutline
    };

    private string GetDifficultyLabel(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" => "Lett",
        "medium" => "Middels",
        "hard" => "Vanskelig",
        _ => difficulty ?? ""
    };

    private string GetDifficultyClass(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => "difficulty-easy",
        "medium" or "middels" => "difficulty-medium",
        "hard" or "vanskelig" => "difficulty-hard",
        _ => ""
    };
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\Browse.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\BrowseDetails.razor
================================================================================
@page "/browse/{Id:guid}"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IApiClient ApiClient
@inject IUserRecipeService RecipeService
@inject IFoodService FoodService
@inject IAuthService AuthService
@inject IDialogService DialogService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="GoBack">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="p-4 d-flex justify-center">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_recipe == null)
{
    <div class="empty-state">
        <MudIcon Icon="@Icons.Material.Rounded.Error" Size="Size.Large" />
        <h2>Oppskrift ikke funnet</h2>
    </div>
}
else
{
    @* --- Header Image --- *@
    @if (!string.IsNullOrEmpty(GetImageUrl()) && !_recipe.IsHellofresh)
    {
        <img src="@GetImageUrl()" class="detail-hero-image" />
    }

    <div>
        <div class="d-flex justify-space-between align-start gap-3">
            <h1 class="detail-title">@_recipe.Name</h1>
            @if (_recipe.AverageRating > 0)
            {
                <div class="d-flex flex-column align-end">
                    <span class="rating-badge rating-high">
                        <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                        @_recipe.AverageRating.ToString("0.0")
                    </span>
                    @if (_recipe.TotalRatings > 0)
                    {
                        <span class="rating-count-badge">
                            <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" Style="font-size: 10px;" />
                            @_recipe.TotalRatings
                        </span>
                    }
                </div>
            }
        </div>

        @* --- Source Badge --- *@
        <div class="d-flex gap-2 mt-2 flex-wrap align-center">
            @if (_recipe.IsHellofresh)
            {
                <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.LocalDining" Color="Color.Success">
                    HelloFresh
                </MudChip>
            }
            else
            {
                <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.Cloud" Color="Color.Info">
                    Delt av @(_recipe.CreatedByUserName ?? "Fellesskapet")
                </MudChip>
            }
            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="align-self-center">• @_recipe.CreatedAt.ToString("dd. MMM yyyy")</MudText>

            @* --- Owner Actions Menu --- *@
            @if (IsOwner)
            {
                <div class="ml-auto">
                    <MudMenu Icon="@Icons.Material.Rounded.MoreVert" Size="Size.Small" AnchorOrigin="Origin.BottomRight">
                        <MudMenuItem Icon="@Icons.Material.Rounded.Delete" IconColor="Color.Error" OnClick="DeletePublishedRecipe">
                            Slett fra fellesskapet
                        </MudMenuItem>
                    </MudMenu>
                </div>
            }
        </div>

        @* --- Quick Info Row --- *@
        @if (_recipe.PrepTimeMinutes.HasValue || _recipe.CookTimeMinutes.HasValue || !string.IsNullOrEmpty(_recipe.Difficulty) || _recipe.Servings.HasValue || !string.IsNullOrEmpty(_recipe.Cuisine))
        {
            <div class="quick-info-row mt-4">
                @if (_recipe.PrepTimeMinutes.HasValue)
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.AccessTime" Size="Size.Small" Color="Color.Primary" />
                        <span>@_recipe.PrepTimeMinutes min forberedelse</span>
                    </div>
                }
                @if (!string.IsNullOrEmpty(_recipe.Difficulty))
                {
                    <div class="quick-info-item @GetDifficultyClass(_recipe.Difficulty)">
                        <MudIcon Icon="@GetDifficultyIcon(_recipe.Difficulty)" Size="Size.Small" />
                        <span>@GetDifficultyLabel(_recipe.Difficulty)</span>
                    </div>
                }
                @if (_recipe.Servings.HasValue)
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.Group" Size="Size.Small" Color="Color.Tertiary" />
                        <span>@_recipe.Servings porsjoner</span>
                    </div>
                }
                @if (!string.IsNullOrEmpty(_recipe.Cuisine))
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" Color="Color.Info" />
                        <span>@_recipe.Cuisine</span>
                    </div>
                }
            </div>
        }

        @if (!string.IsNullOrEmpty(_recipe.Description))
        {
            <p class="detail-description mt-4">@_recipe.Description</p>
        }

        @* --- Recipe Tags --- *@
        @if (_recipe.Tags.Any())
        {
            <div class="d-flex flex-wrap gap-2 mt-3">
                @foreach (var tag in _recipe.Tags)
                {
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Default">@tag</MudChip>
                }
            </div>
        }

        @* --- HelloFresh Recipe Details (Ingredients & Nutrition) --- *@
        @if (_recipe.IsHellofresh)
        {
            <div class="mt-6">
                <HelloFreshRecipeDetails Recipe="_recipe" />
            </div>
        }
        else if (HasIngredients())
        {
            @* Community Recipe Ingredients *@
            <MudExpansionPanels Class="mt-4" MultiExpansion="true">
                <MudExpansionPanel Text="Ingredienser" Icon="@Icons.Material.Rounded.ShoppingCart" IsInitiallyExpanded="true">
                    <div class="ingredients-list">
                        @foreach (var ingredient in GetIngredients())
                        {
                            <div class="ingredient-item">
                                <div class="ingredient-placeholder">
                                    <MudIcon Icon="@Icons.Material.Rounded.Egg" Size="Size.Small" />
                                </div>
                                <div class="ingredient-info">
                                    <span class="ingredient-name">@ingredient.Name</span>
                                    @if (!string.IsNullOrEmpty(ingredient.Amount) || !string.IsNullOrEmpty(ingredient.Unit))
                                    {
                                        <span class="ingredient-amount">@ingredient.Amount @ingredient.Unit</span>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </MudExpansionPanel>
            </MudExpansionPanels>
        }

        <div class="action-buttons mt-6">
            @* --- Primary Action: Add to my cookbook --- *@
            <MudButton Variant="Variant.Filled"
                       Color="@(_recipe.IsHellofresh ? Color.Success : Color.Primary)"
                       FullWidth="true"
                       Size="Size.Large"
                       StartIcon="@Icons.Material.Rounded.Add"
                       OnClick="AddToMyList"
                       Disabled="_isProcessing"
                       Style="border-radius: 12px; height: 52px;">
                @if (_isProcessing)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Legger til...</span>
                }
                else
                {
                    <span>Legg til</span>
                }
            </MudButton>

            @* --- Secondary: Copy and customize --- *@
            <MudButton Variant="Variant.Outlined"
                       Color="Color.Default"
                       FullWidth="true"
                       Class="mt-3"
                       StartIcon="@Icons.Material.Rounded.Edit"
                       OnClick="CustomizeAndAdd"
                       Style="border-radius: 12px;">
                Kopier og endre
            </MudButton>
        </div>
    </div>
}

<style>
    .detail-hero-image {
        width: 100%;
        height: 250px;
        object-fit: cover;
        border-radius: 24px;
        margin-bottom: 16px;
    }

    .detail-hero-placeholder {
        width: 100%;
        height: 250px;
        background: var(--mud-palette-background-grey);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0 0 24px 24px;
        color: var(--mud-palette-text-disabled);
    }

    .detail-content {
        padding: 24px;
    }

    .detail-title {
        font-size: 1.75rem;
        font-weight: 700;
        line-height: 1.2;
        margin: 0;
    }

    .detail-description {
        color: var(--mud-palette-text-secondary);
        line-height: 1.6;
    }

    .action-card {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 16px;
    }

    .action-title {
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 4px;
    }

    .action-desc {
        font-size: 0.85rem;
        color: var(--mud-palette-text-secondary);
        margin-bottom: 0;
    }

    .rating-count {
        font-size: 0.7rem;
        color: var(--mud-palette-text-secondary);
        margin-top: 2px;
    }

    .quick-info-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
    }

    .quick-info-item {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        font-size: 0.85rem;
    }

    .quick-info-item.difficulty-easy {
        background: rgba(76, 175, 80, 0.1);
        color: #2e7d32;
    }

    .quick-info-item.difficulty-medium {
        background: rgba(255, 152, 0, 0.1);
        color: #e65100;
    }

    .quick-info-item.difficulty-hard {
        background: rgba(244, 67, 54, 0.1);
        color: #c62828;
    }

    .ingredients-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .ingredient-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
    }

    .ingredient-placeholder {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        background: var(--mud-palette-divider);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-disabled);
    }

    .ingredient-info {
        display: flex;
        flex-direction: column;
    }

    .ingredient-name {
        font-weight: 500;
        color: var(--mud-palette-text-primary);
    }

    .ingredient-amount {
        font-size: 0.8rem;
        color: var(--mud-palette-text-secondary);
    }
</style>

@code {
    [Parameter] public Guid Id { get; set; }

    private GlobalRecipeDto? _recipe;
    private bool _isLoading = true;
    private bool _isProcessing = false;
    private Guid _currentUserId;

    private bool IsOwner => _recipe?.CreatedByUserId == _currentUserId && _currentUserId != Guid.Empty;

    private async Task GoBack()
    {
        await JSRuntime.InvokeVoidAsync("history.back");
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var user = await ApiClient.GetMyProfileAsync();
            if (user != null) _currentUserId = user.Id;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading user profile: {ex.Message}");
        }
        await LoadData();
    }

    private async Task DeletePublishedRecipe()
    {
        if (_recipe == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Slett fra fellesskapet?",
            "Dette fjerner oppskriften fra fellesskapet. Din lokale kopi beholdes.",
            yesText: "Slett", cancelText: "Avbryt");

        if (confirm == true)
        {
            _isProcessing = true;
            try
            {
                await ApiClient.DeleteGlobalRecipeAsync(_recipe.Id);
                Snackbar.Add("Oppskrift slettet fra fellesskapet", Severity.Success);
                Navigation.NavigateTo("browse");
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
            }
            finally
            {
                _isProcessing = false;
            }
        }
    }

    private async Task LoadData()
    {
        _isLoading = true;
        try
        {
            _recipe = await ApiClient.GetGlobalRecipeAsync(Id);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Snackbar.Add("Feil ved lasting av oppskrift", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private string? GetImageUrl()
    {
        if (_recipe == null) return null;
        if (!string.IsNullOrEmpty(_recipe.ImageUrl)) return _recipe.ImageUrl;
        return _recipe.ImageUrls?.FirstOrDefault();
    }

    // Add to my list using UserRecipes API
    private async Task AddToMyList()
    {
        if (_recipe == null) return;

        _isProcessing = true;
        try
        {
            // Don't copy images for HelloFresh recipes (they're broken/copyrighted)
            var imageUrls = _recipe.IsHellofresh ? new List<string>() : (_recipe.ImageUrls ?? new List<string>());

            var dto = new CreateUserRecipeDto
            {
                Name = _recipe.Name,
                Description = _recipe.Description,
                ImageUrls = imageUrls,
                GlobalRecipeId = _recipe.Id,
                PrepTimeMinutes = _recipe.PrepTimeMinutes,
                Servings = _recipe.Servings,
                Difficulty = _recipe.Difficulty,
                Cuisine = _recipe.Cuisine,
                Tags = _recipe.Tags,
                Ingredients = _recipe.Ingredients,
                Visibility = "private"
            };

            await RecipeService.CreateRecipeAsync(dto);
            Snackbar.Add($"'{_recipe.Name}' lagt til i din kokebok!", Severity.Success);
            Navigation.NavigateTo("");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
            Snackbar.Add("Kunne ikke lagre oppskrift", Severity.Error);
        }
        finally
        {
            _isProcessing = false;
        }
    }

    // Copy and customize - creates independent copy NOT linked to HelloFresh
    private void CustomizeAndAdd()
    {
        if (_recipe == null) return;

        // Don't copy images for HelloFresh recipes (they're broken/copyrighted)
        var imageUrls = _recipe.IsHellofresh ? new List<string>() : (_recipe.ImageUrls ?? new List<string>());

        FoodService.DraftRecipe = new StorhaugenWebsite.Models.FoodItem
        {
            Name = _recipe.Name,
            Description = _recipe.Description,
            ImageUrls = imageUrls,
            // Don't link to GlobalRecipe so it's fully editable
            GlobalRecipeId = null,
            // Not a HelloFresh recipe - it's a personal copy
            IsHelloFresh = false,
            PrepTimeMinutes = _recipe.PrepTimeMinutes,
            CookTimeMinutes = _recipe.CookTimeMinutes,
            Servings = _recipe.Servings,
            Difficulty = _recipe.Difficulty,
            Cuisine = _recipe.Cuisine,
            Ingredients = _recipe.Ingredients
        };

        Navigation.NavigateTo("add");
    }

    // Difficulty helpers
    private string GetDifficultyIcon(string? difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
            "medium" or "middels" => Icons.Material.Rounded.Psychology,
            "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
            _ => Icons.Material.Rounded.HelpOutline
        };
    }

    private string GetDifficultyLabel(string? difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" => "Lett",
            "medium" => "Middels",
            "hard" => "Vanskelig",
            _ => difficulty ?? ""
        };
    }

    private string GetDifficultyClass(string? difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" or "lett" => "difficulty-easy",
            "medium" or "middels" => "difficulty-medium",
            "hard" or "vanskelig" => "difficulty-hard",
            _ => ""
        };
    }

    // Ingredient helpers
    private record IngredientInfo(string Name, string? Amount, string? Unit);

    private bool HasIngredients()
    {
        if (_recipe?.Ingredients == null) return false;
        if (_recipe.Ingredients is System.Text.Json.JsonElement jsonElement)
        {
            return jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array && jsonElement.GetArrayLength() > 0;
        }
        return false;
    }

    private List<IngredientInfo> GetIngredients()
    {
        var items = new List<IngredientInfo>();
        if (_recipe?.Ingredients == null) return items;

        try
        {
            if (_recipe.Ingredients is System.Text.Json.JsonElement jsonElement && jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var item in jsonElement.EnumerateArray())
                {
                    var name = item.TryGetProperty("name", out var n) ? n.GetString() : "";
                    var amount = item.TryGetProperty("amount", out var a) ? a.ToString() : null;
                    var unit = item.TryGetProperty("unit", out var u) ? u.GetString() : null;

                    if (!string.IsNullOrEmpty(name))
                    {
                        items.Add(new IngredientInfo(name!, amount, unit));
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing ingredients: {ex.Message}");
        }
        return items;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\BrowseDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\CollectionDetails.razor
================================================================================
@page "/collections/{Id:guid}"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IApiClient ApiClient
@inject ICollectionStateService CollectionState
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="@(() => Navigation.NavigateTo("collections"))">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_collection == null)
{
    <div class="empty-state pa-8 text-center">
        <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" Color="Color.Default" />
        <MudText Typo="Typo.h6" Class="mt-3">Fant ikke samlingen</MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="collections">
            Tilbake til samlinger
        </MudButton>
    </div>
}
else
{
    @* Header *@
    <div class="collection-header mb-4">
        <div class="d-flex align-center gap-3 mb-2">
            <div class="collection-icon-large">
                <MudIcon Icon="@GetVisibilityIcon(_collection.Visibility)" Size="Size.Large" />
            </div>
            <div class="flex-grow-1">
                <div class="d-flex align-center gap-2">
                    <h1 class="page-title" style="margin: 0;">@_collection.Name</h1>
                    @if (_collection.IsOwner)
                    {
                        <MudIconButton Icon="@Icons.Material.Rounded.Edit"
                                       Size="Size.Small"
                                       OnClick="ShowEditDialog" />
                    }
                </div>

                @if (!string.IsNullOrEmpty(_collection.Description))
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">@_collection.Description</MudText>
                }
            </div>
        </div>

        <div class="d-flex flex-wrap gap-2 mt-3">
            <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.Restaurant">
                @_collection.RecipeCount oppskrifter
            </MudChip>
            <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.People">
                @_collection.MemberCount medlemmer
            </MudChip>
            <MudChip T="string" Size="Size.Small" Color="@GetVisibilityColor(_collection.Visibility)" Icon="@GetVisibilityIcon(_collection.Visibility)">
                @GetVisibilityText(_collection.Visibility)
            </MudChip>
        </div>
    </div>

    @* Share Section *@
    @if (_collection.IsOwner && _collection.Visibility != "private" && !string.IsNullOrEmpty(_collection.ShareCode))
    {
        <div class="form-section">
            <p class="form-section-title">Del samlingen</p>

            <div class="share-link-box">
                <div class="d-flex align-center justify-space-between">
                    <div>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Delekode</MudText>
                        <MudText Typo="Typo.h6" Style="font-family: monospace; letter-spacing: 2px;">
                            @_collection.ShareCode
                        </MudText>
                    </div>

                    <div class="d-flex gap-2">
                        <MudIconButton Icon="@Icons.Material.Rounded.ContentCopy"
                                       Color="Color.Primary"
                                       OnClick="CopyShareCode"
                                       Title="Kopier kode" />
                        <MudIconButton Icon="@Icons.Material.Rounded.Share"
                                       Color="Color.Primary"
                                       OnClick="CopyShareLink"
                                       Title="Kopier lenke" />
                    </div>
                </div>
            </div>

            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-2">
                @if (_collection.Visibility == "public")
                {
                    <span>Alle med denne lenken kan se samlingen</span>
                }
                else
                {
                    <span>Kun dine venner kan se samlingen med denne lenken</span>
                }
            </MudText>
        </div>
    }

    @* Visibility Settings *@
    @if (_collection.IsOwner)
    {
        <div class="form-section">
            <p class="form-section-title">Innstillinger</p>

            <MudSelect T="string"
                       Value="@_collection.Visibility"
                       ValueChanged="UpdateVisibility"
                       Label="Synlighet"
                       Variant="Variant.Outlined"
                       ToStringFunc="@(v => GetVisibilityText(v))"
                       Class="mb-3 privacy-settings-select">
                <MudSelectItem Value="@("private")">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Small" />
                        <div>
                            <div>Privat</div>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">Kun medlemmer kan se</MudText>
                        </div>
                    </div>
                </MudSelectItem>

                <MudSelectItem Value="@("friends")">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" />
                        <div>
                            <div>Venner</div>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">Dine venner kan se</MudText>
                        </div>
                    </div>
                </MudSelectItem>

                <MudSelectItem Value="@("public")">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" />
                        <div>
                            <div>Offentlig</div>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">Alle kan se</MudText>
                        </div>
                    </div>
                </MudSelectItem>
            </MudSelect>
        </div>
    }

    @* Members Section *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-3">
            <p class="form-section-title" style="margin: 0;">Medlemmer (@_collection.MemberCount)</p>

            @if (_collection.IsOwner)
            {
                <MudButton Variant="Variant.Text"
                           Color="Color.Primary"
                           Size="Size.Small"
                           StartIcon="@Icons.Material.Rounded.PersonAdd"
                           OnClick="ShowInviteDialog">
                    Inviter
                </MudButton>
            }
        </div>

        <div class="d-flex flex-column gap-2">
            @foreach (var member in _collection.Members.OrderByDescending(m => m.IsOwner))
            {
                <div class="member-row">
                    <MudAvatar Size="Size.Medium" Style="@($"background: {GetMemberColor(member.DisplayName)}")">
                        @(string.IsNullOrEmpty(member.DisplayName) ? '?' : member.DisplayName[0])
                    </MudAvatar>

                    <div class="flex-grow-1">
                        <MudText Typo="Typo.body1" Style="font-weight: 500;">@member.DisplayName</MudText>
                        @if (member.IsOwner)
                        {
                            <MudText Typo="Typo.caption" Color="Color.Primary">Eier</MudText>
                        }
                    </div>

                    @if (_collection.IsOwner && !member.IsOwner)
                    {
                        <MudIconButton Icon="@Icons.Material.Rounded.PersonRemove"
                                       Size="Size.Small"
                                       Color="Color.Error"
                                       OnClick="() => RemoveMember(member)" />
                    }
                </div>
            }
        </div>
    </div>

    @* Recipes Section *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-2">
            <p class="form-section-title" style="margin: 0;">
                Oppskrifter (@_collection.RecipeCount)
            </p>

            <MudButton Variant="Variant.Text"
                       Color="Color.Primary"
                       Size="Size.Small"
                       EndIcon="@Icons.Material.Rounded.ArrowForward"
                       OnClick="OpenRecipes"
                       Style="text-transform: none;">
                Se alle
            </MudButton>
        </div>

        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Åpne full oppskriftsliste med søk og sortering.
        </MudText>
    </div>

    @* Danger Zone *@
    @if (_collection.IsOwner)
    {
        <div class="form-section">
            <p class="form-section-title" style="color: var(--mud-palette-error);">Faresone</p>

            <MudButton Variant="Variant.Outlined"
                       Color="Color.Error"
                       FullWidth="true"
                       StartIcon="@Icons.Material.Rounded.Delete"
                       OnClick="ConfirmDelete">
                Slett samling
            </MudButton>

            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-2">
                Oppskriftene slettes ikke, de fjernes bare fra samlingen
            </MudText>
        </div>
    }
    else
    {
        <div class="form-section">
            <MudButton Variant="Variant.Outlined"
                       Color="Color.Warning"
                       FullWidth="true"
                       StartIcon="@Icons.Material.Rounded.ExitToApp"
                       OnClick="LeaveCollection">
                Forlat samling
            </MudButton>
        </div>
    }
}

@* Edit Dialog *@
<MudDialog @bind-Visible="_showEditDialog" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Rediger samling</MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_editName"
                      Label="Navn"
                      Variant="Variant.Outlined"
                      Class="mb-3" />
        <MudTextField @bind-Value="_editDescription"
                      Label="Beskrivelse"
                      Variant="Variant.Outlined"
                      Lines="2" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showEditDialog = false">Avbryt</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveEdit">Lagre</MudButton>
    </DialogActions>
</MudDialog>

@* Invite Dialog *@
<MudDialog @bind-Visible="_showInviteDialog" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Inviter medlem</MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_inviteIdentifier"
                      Label="E-post eller Dele-ID"
                      Variant="Variant.Outlined"
                      Placeholder="navn@eksempel.no eller ABC123"
                      HelperText="Skriv inn personens e-post eller deres unike Dele-ID" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showInviteDialog = false">Avbryt</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="InviteMember" Disabled="@(string.IsNullOrWhiteSpace(_inviteIdentifier))">
            Inviter
        </MudButton>
    </DialogActions>
</MudDialog>

<style>
    .collection-header {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 20px;
    }

    .collection-icon-large {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        background: var(--mud-palette-primary);
        color: var(--mud-palette-primary-text);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .share-link-box {
        background: var(--mud-palette-background-grey);
        border-radius: 12px;
        padding: 16px;
    }

    .member-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: var(--mud-palette-background-grey);
        border-radius: 12px;
    }

    .privacy-settings-select .mud-select-input > div {
    height: 30px!important;
    }
</style>

@code {
    [Parameter] public Guid Id { get; set; }

    private CollectionDto? _collection;
    private bool _isLoading = true;

    private bool _showEditDialog;
    private string _editName = "";
    private string _editDescription = "";

    private bool _showInviteDialog;
    private string _inviteIdentifier = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadCollection();
    }

    private async Task LoadCollection()
    {
        _isLoading = true;
        try
        {
            _collection = await ApiClient.GetCollectionAsync(Id);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading collection: {ex.Message}");
            Snackbar.Add("Kunne ikke laste samling", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void OpenRecipes()
    {
        var returnUrl = Uri.EscapeDataString($"collections/{Id}");
        Navigation.NavigateTo($"collections/{Id}/recipes?returnUrl={returnUrl}");
    }

    private void ShowEditDialog()
    {
        if (_collection == null) return;

        _editName = _collection.Name;
        _editDescription = _collection.Description ?? "";
        _showEditDialog = true;
    }

    private async Task SaveEdit()
    {
        if (_collection == null) return;

        try
        {
            await ApiClient.UpdateCollectionAsync(_collection.Id, new UpdateCollectionDto
            {
                Name = _editName,
                Description = _editDescription
            });

            _showEditDialog = false;
            Snackbar.Add("Samling oppdatert", Severity.Success);

            await LoadCollection();
            await CollectionState.RefreshCollectionsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating collection: {ex.Message}");
            Snackbar.Add("Kunne ikke oppdatere samling", Severity.Error);
        }
    }

    private async Task UpdateVisibility(string newVisibility)
    {
        if (_collection == null) return;

        try
        {
            await ApiClient.UpdateCollectionAsync(_collection.Id, new UpdateCollectionDto
            {
                Visibility = newVisibility
            });

            Snackbar.Add($"Synlighet endret til {GetVisibilityText(newVisibility)}", Severity.Success);
            await LoadCollection();
            await CollectionState.RefreshCollectionsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating visibility: {ex.Message}");
            Snackbar.Add("Kunne ikke endre synlighet", Severity.Error);
        }
    }

    private void ShowInviteDialog()
    {
        _inviteIdentifier = "";
        _showInviteDialog = true;
    }

    private async Task InviteMember()
    {
        if (_collection == null || string.IsNullOrWhiteSpace(_inviteIdentifier)) return;

        try
        {
            await ApiClient.AddCollectionMemberAsync(_collection.Id, new AddCollectionMemberDto
            {
                UserIdentifier = _inviteIdentifier.Trim()
            });

            _showInviteDialog = false;
            Snackbar.Add("Medlem lagt til!", Severity.Success);

            await LoadCollection();
            await CollectionState.RefreshCollectionsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inviting member: {ex.Message}");
            Snackbar.Add("Kunne ikke legge til medlem. Sjekk at ID/e-post er riktig.", Severity.Error);
        }
    }

    private async Task RemoveMember(CollectionMemberDto member)
    {
        if (_collection == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Fjern medlem",
            $"Er du sikker pa at du vil fjerne {member.DisplayName} fra samlingen?",
            yesText: "Fjern",
            cancelText: "Avbryt");

        if (confirm != true) return;

        try
        {
            await ApiClient.RemoveCollectionMemberAsync(_collection.Id, member.UserId);
            Snackbar.Add("Medlem fjernet", Severity.Success);

            await LoadCollection();
            await CollectionState.RefreshCollectionsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing member: {ex.Message}");
            Snackbar.Add("Kunne ikke fjerne medlem", Severity.Error);
        }
    }

    private async Task ConfirmDelete()
    {
        if (_collection == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Slett samling",
            $"Er du sikker pa at du vil slette '{_collection.Name}'? Oppskriftene slettes ikke.",
            yesText: "Slett",
            cancelText: "Avbryt");

        if (confirm != true) return;

        try
        {
            await ApiClient.DeleteCollectionAsync(_collection.Id);
            Snackbar.Add("Samling slettet", Severity.Success);

            await CollectionState.RefreshCollectionsAsync();
            Navigation.NavigateTo("collections");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting collection: {ex.Message}");
            Snackbar.Add("Kunne ikke slette samling", Severity.Error);
        }
    }

    private async Task LeaveCollection()
    {
        if (_collection == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Forlat samling",
            $"Er du sikker pa at du vil forlate '{_collection.Name}'?",
            yesText: "Forlat",
            cancelText: "Avbryt");

        if (confirm != true) return;

        try
        {
            await ApiClient.LeaveCollectionAsync(_collection.Id);
            Snackbar.Add("Du har forlatt samlingen", Severity.Success);

            await CollectionState.RefreshCollectionsAsync();
            Navigation.NavigateTo("collections");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error leaving collection: {ex.Message}");
            Snackbar.Add("Kunne ikke forlate samling", Severity.Error);
        }
    }

    private async Task CopyShareCode()
    {
        if (string.IsNullOrEmpty(_collection?.ShareCode)) return;

        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", _collection.ShareCode);
            Snackbar.Add("Kode kopiert!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Kunne ikke kopiere", Severity.Error);
        }
    }

    private async Task CopyShareLink()
    {
        if (string.IsNullOrEmpty(_collection?.ShareCode)) return;

        try
        {
            var baseUrl = Navigation.BaseUri.TrimEnd('/');
            var shareUrl = $"{baseUrl}collections/shared/{_collection.ShareCode}";
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);

            Snackbar.Add("Lenke kopiert!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Kunne ikke kopiere", Severity.Error);
        }
    }

    private string GetVisibilityIcon(string visibility) => visibility switch
    {
        "public" => Icons.Material.Rounded.Public,
        "friends" => Icons.Material.Rounded.People,
        _ => Icons.Material.Rounded.Lock
    };

    private string GetVisibilityText(string visibility) => visibility switch
    {
        "public" => "Offentlig",
        "friends" => "Venner",
        _ => "Privat"
    };

    private Color GetVisibilityColor(string visibility) => visibility switch
    {
        "public" => Color.Success,
        "friends" => Color.Info,
        _ => Color.Default
    };

    private string GetMemberColor(string name)
    {
        var hue = Math.Abs(name.GetHashCode() % 360);
        return $"hsl({hue}, 45%, 45%)";
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\CollectionDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\CollectionRecipes.razor
================================================================================
@page "/collections/{CollectionId:guid}/recipes"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="GoBack">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_collection == null)
{
    <div class="empty-state pa-8 text-center">
        <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" Color="Color.Default" />
        <MudText Typo="Typo.h6" Class="mt-3">Fant ikke samlingen</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Samlingen finnes ikke, eller du har ikke tilgang til den.
        </MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="GoBack">
            Tilbake
        </MudButton>
    </div>
}
else
{
    <div class="collection-header mb-4">
        <div class="d-flex align-center gap-3 mb-2">
            <div class="collection-icon-large">
                <MudIcon Icon="@GetVisibilityIcon(_collection.Visibility)" Size="Size.Large" />
            </div>
            <div class="flex-grow-1">
                <h1 class="page-title" style="margin: 0;">@_collection.Name</h1>
                @if (!string.IsNullOrEmpty(_collection.Description))
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">@_collection.Description</MudText>
                }
            </div>
        </div>

        <div class="d-flex flex-wrap gap-2 mt-3">
            <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.Restaurant">
                @_collection.RecipeCount oppskrifter
            </MudChip>
            <MudChip T="string" Size="Size.Small" Color="@GetVisibilityColor(_collection.Visibility)" Icon="@GetVisibilityIcon(_collection.Visibility)">
                @GetVisibilityText(_collection.Visibility)
            </MudChip>
        </div>
    </div>

    <CollectionRecipesList CollectionId="_collection.Id" Title="Oppskrifter" PageSize="50" />
}

@code {
    [Parameter] public Guid CollectionId { get; set; }

    private CollectionDto? _collection;
    private bool _isLoading = true;
    private string _returnUrl = "collections";

    protected override async Task OnInitializedAsync()
    {
        var uri = new Uri(Navigation.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        _returnUrl = query["returnUrl"] ?? $"collections/{CollectionId}";

        await LoadCollection();
    }

    private async Task LoadCollection()
    {
        _isLoading = true;
        try
        {
            _collection = await ApiClient.GetCollectionAsync(CollectionId);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            Snackbar.Add("Kunne ikke laste samlingen", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void GoBack() => Navigation.NavigateTo(_returnUrl);

    private string GetVisibilityIcon(string visibility) => visibility switch
    {
        "public" => Icons.Material.Rounded.Public,
        "friends" => Icons.Material.Rounded.People,
        _ => Icons.Material.Rounded.Lock
    };

    private string GetVisibilityText(string visibility) => visibility switch
    {
        "public" => "Offentlig",
        "friends" => "Venner",
        _ => "Privat"
    };

    private Color GetVisibilityColor(string visibility) => visibility switch
    {
        "public" => Color.Success,
        "friends" => Color.Info,
        _ => Color.Default
    };
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\CollectionRecipes.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Collections.razor
================================================================================
@page "/collections"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IApiClient ApiClient
@inject ICollectionStateService CollectionState
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<div class="d-flex align-center justify-space-between mb-4">
    <h1 class="page-title" style="margin-bottom: 0;">Samlinger</h1>
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Rounded.Add"
               OnClick="ShowCreateDialog">
        Ny samling
    </MudButton>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (!_collections.Any())
{
    <div class="empty-state pa-8 text-center">
        <MudIcon Icon="@Icons.Material.Rounded.FolderOpen" Size="Size.Large" Color="Color.Default" />
        <MudText Typo="Typo.h6" Class="mt-3">Ingen samlinger enda</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Opprett en samling for a dele oppskrifter med andre
        </MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowCreateDialog">
            Opprett din forste samling
        </MudButton>
    </div>
}
else
{
    <div class="d-flex flex-column gap-3">
        @foreach (var collection in _collections)
        {
            <div class="collection-card clickable"
                 role="button"
                 tabindex="0"
                 @onclick="() => OpenCollection(collection.Id)">

                <div class="d-flex align-center gap-3">
                    <div class="collection-icon">
                        <MudIcon Icon="@GetVisibilityIcon(collection.Visibility)" Size="Size.Medium" />
                    </div>

                    <div class="flex-grow-1" style="min-width: 0;">
                        <div class="d-flex align-center gap-2">
                            <MudText Typo="Typo.subtitle1" Class="text-truncate" Style="font-weight: 600;">
                                @collection.Name
                            </MudText>

                            @if (collection.IsOwner)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">
                                    Eier
                                </MudChip>
                            }
                        </div>

                        @* Meta row: members + recipes (no button) *@
                        <div class="d-flex align-center gap-3 mt-1 collection-meta">
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small"
                                         Style="font-size: 14px; vertical-align: middle;" />
                                @collection.MemberCount medlemmer
                            </MudText>

                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small"
                                         Style="font-size: 14px; vertical-align: middle;" />
                                @collection.RecipeCount @(collection.RecipeCount == 1 ? "oppskrift" : "oppskrifter")
                            </MudText>
                        </div>
                    </div>

                    <MudIcon Icon="@Icons.Material.Rounded.ChevronRight" Class="collection-chevron" />
                </div>
            </div>
        }
    </div>
}

@* Create Collection Dialog *@
<MudDialog @bind-Visible="_showCreateDialog" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Opprett ny samling</MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_newCollectionName"
                      Label="Navn pa samlingen"
                      Variant="Variant.Outlined"
                      Class="mb-3"
                      Immediate="true" />
        <MudTextField @bind-Value="_newCollectionDescription"
                      Label="Beskrivelse (valgfritt)"
                      Variant="Variant.Outlined"
                      Lines="2"
                      Class="mb-3" />
        <MudSelect T="string" @bind-Value="_newCollectionVisibility" Label="Synlighet" Variant="Variant.Outlined"
                   ToStringFunc="@(v => GetVisibilityDisplayText(v))">
            <MudSelectItem Value="@("private")">
                <div class="d-flex align-center gap-2">
                    <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Small" />
                    <span>Privat - Kun medlemmer</span>
                </div>
            </MudSelectItem>
            <MudSelectItem Value="@("friends")">
                <div class="d-flex align-center gap-2">
                    <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" />
                    <span>Venner - Dine venner kan se</span>
                </div>
            </MudSelectItem>
            <MudSelectItem Value="@("public")">
                <div class="d-flex align-center gap-2">
                    <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" />
                    <span>Offentlig - Alle kan se</span>
                </div>
            </MudSelectItem>
        </MudSelect>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showCreateDialog = false">Avbryt</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateCollection" Disabled="@(string.IsNullOrWhiteSpace(_newCollectionName))">
            Opprett
        </MudButton>
    </DialogActions>
</MudDialog>

<style>
    .collection-card {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .collection-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

        .collection-card.clickable {
            cursor: pointer;
            transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
        }

            .collection-card.clickable:hover {
                transform: translateY(-1px);
                border-color: rgba(var(--mud-palette-primary-rgb), 0.35);
                box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            }

    .collection-meta .mud-icon-root {
        opacity: 0.75;
    }

    .collection-chevron {
        opacity: 0.6;
        font-size: 22px;
        flex-shrink: 0;
    }

    .collection-icon {
        width: 48px;
        height: 48px;
        border-radius: 12px;
        background: var(--mud-palette-primary);
        color: var(--mud-palette-primary-text);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .collection-recipes-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--mud-palette-divider);
    }
</style>

@code {
    private List<CollectionDto> _collections = new();
    private bool _isLoading = true;
    private bool _showCreateDialog = false;
    private string _newCollectionName = "";
    private string _newCollectionDescription = "";
    private string _newCollectionVisibility = "private";

    protected override async Task OnInitializedAsync()
    {
        await LoadCollections();
    }

    private async Task LoadCollections()
    {
        _isLoading = true;
        try
        {
            _collections = await ApiClient.GetMyCollectionsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading collections: {ex.Message}");
            Snackbar.Add("Kunne ikke laste samlinger", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void ShowCreateDialog()
    {
        _newCollectionName = "";
        _newCollectionDescription = "";
        _newCollectionVisibility = "private";
        _showCreateDialog = true;
    }

    private async Task CreateCollection()
    {
        if (string.IsNullOrWhiteSpace(_newCollectionName)) return;

        try
        {
            var dto = new CreateCollectionDto
            {
                Name = _newCollectionName,
                Description = _newCollectionDescription,
                Visibility = _newCollectionVisibility
            };
            var collection = await ApiClient.CreateCollectionAsync(dto);
            _showCreateDialog = false;
            Snackbar.Add("Samling opprettet!", Severity.Success);
            await CollectionState.RefreshCollectionsAsync();
            await LoadCollections();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating collection: {ex.Message}");
            Snackbar.Add("Kunne ikke opprette samling", Severity.Error);
        }
    }

    private void OpenCollection(Guid id)
    {
        Navigation.NavigateTo($"collections/{id}");
    }

    private string GetVisibilityIcon(string visibility) => visibility switch
    {
        "public" => Icons.Material.Rounded.Public,
        "friends" => Icons.Material.Rounded.People,
        _ => Icons.Material.Rounded.Lock
    };

    private string GetVisibilityDisplayText(string visibility) => visibility switch
    {
        "public" => "Offentlig - Alle kan se",
        "friends" => "Venner - Dine venner kan se",
        _ => "Privat - Kun medlemmer"
    };
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\Collections.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\CookBook.razor
================================================================================
@page "/cookbook"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Components
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.Extensions
@using StorhaugenWebsite.Models
@inject IUserRecipeService RecipeService
@inject ICollectionStateService CollectionState
@inject IUserFriendshipService FriendshipService
@inject IAuthService AuthService
@inject IUserColorService UserColorService
@inject IDeviceStateService DeviceState
@inject NavigationManager Navigation
@inject IApiClient ApiClient
@attribute [Authorize]
@implements IDisposable

<div class="cookbook-header d-flex flex-column gap-3 mb-4">

    @* Collection Selection *@
    @if (CollectionState.UserCollections.Any())
    {
        <div class="group-filter-section">
            <div class="horizontal-scroll-container">

                @* Personal pseudo-collection *@
                <div class="group-chip @(_personalActive ? "active" : "")" @onclick="TogglePersonal">
                    @if (_personalActive)
                    {
                        <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Class="mr-1" />
                    }
                    <span>Personlig</span>
                </div>

                @foreach (var collection in CollectionState.UserCollections)
                {
                    var isActive = CollectionState.IsCollectionActive(collection.Id);
                    <div class="group-chip @(isActive ? "active" : "")" @onclick="@(() => ToggleCollection(collection.Id))">
                        @if (isActive)
                        {
                            <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Class="mr-1" />
                        }
                        <span>@collection.Name</span>
                    </div>
                }
            </div>
        </div>
    }

    @* Search & Sort *@
    <div class="d-flex gap-2">
        <MudTextField @bind-Value="_searchQuery"
                      Placeholder="Søk..."
                      Variant="Variant.Outlined"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Rounded.Search"
                      Immediate="true"
                      DebounceInterval="300"
                      OnDebounceIntervalElapsed="OnSearchChanged"
                      Class="flex-grow-1 search-field"
                      Margin="Margin.Dense" />

        <MudSelect T="string"
                   @bind-Value="_sortBy"
                   AnchorOrigin="Origin.BottomRight"
                   Variant="Variant.Outlined"
                   Margin="Margin.Dense"
                   Class="sort-select"
                   Style="width: 140px;"
                   AdornmentIcon="@Icons.Material.Rounded.Sort">
            <MudSelectItem Value="@("date")">Nyeste</MudSelectItem>
            <MudSelectItem Value="@("rating")">Høyest snitt</MudSelectItem>
            <MudSelectItem Value="@("personal_rating")">Min vurdering</MudSelectItem>
            <MudSelectItem Value="@("name")">Navn (A-Å)</MudSelectItem>
        </MudSelect>
    </div>

    @* Tags *@
    @if (_tags.Any())
    {
        <div class="tag-filter-section mt-1">
            <div class="horizontal-scroll-container">
                @foreach (var tag in _tags)
                {
                    <MudChip T="string"
                             Variant="@(_activeTagIds.Contains(tag.Id) ? Variant.Filled : Variant.Outlined)"
                             Color="Color.Tertiary"
                             OnClick="@(() => ToggleTagFilter(tag.Id))"
                             Size="Size.Small"
                             Style="@(tag.Color != null ? $"--mud-palette-tertiary: {tag.Color};" : "")">
                        @tag.Name
                    </MudChip>
                }
            </div>
        </div>
    }
</div>

@* XFade wrapper (same behavior as Home/ActivityFeed: first-load-only crossfade) *@
<XFade IsLoading="@_isLoading" FirstLoadOnly="true" FadeMs="220">
    <Skeleton>
        <RecipeSkeleton Amount="6" Height="109.11px" />
    </Skeleton>

    <ChildContent>
        @if (!_recipes.Any())
        {
            <div class="empty-state pa-8 text-center">
                <MudIcon Icon="@Icons.Material.Rounded.MenuBook" Size="Size.Large" Color="Color.Default" />
                <MudText Typo="Typo.h6" Class="mt-3">Ingen oppskrifter funnet</MudText>
                <MudButton Variant="Variant.Text" Color="Color.Primary" Href="add">Legg til ny oppskrift</MudButton>
            </div>
        }
        else
        {
            <div class="d-flex flex-column gap-3">
                @foreach (var recipe in _sortedRecipes)
                {
                    var imgUrl = recipe.ImageUrls?.FirstOrDefault(u => !string.IsNullOrWhiteSpace(u));

                    <div class="food-card" @key="recipe.Id" @onclick="() => OpenRecipe(recipe.Id)">
                        @* Image Section (Right Side) *@
                        @if (!string.IsNullOrEmpty(imgUrl))
                        {
                            <img src="@imgUrl" class="food-card-image" loading="lazy" />
                        }
                        else
                        {
                            <div class="food-card-placeholder">
                                <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Large" Style="opacity:0.3;" />
                            </div>
                        }

                        @* Content Section (Left Side) *@
                        <div class="food-card-content">

                            @* Top Row *@
                            <div class="d-flex justify-space-between align-start">
                                <div style="min-width: 0; padding-right: 8px;">
                                    <div class="d-flex align-center gap-1 mb-1">
                                        @if (recipe.IsHellofresh)
                                        {
                                            <MudIcon Icon="@Icons.Material.Rounded.LocalDining" Size="Size.Small" Color="Color.Success" Title="HelloFresh" Style="flex-shrink: 0; font-size: 14px;" />
                                        }
                                        @if (recipe.IsPublished)
                                        {
                                            <MudIcon Icon="@Icons.Material.Rounded.Cloud" Size="Size.Small" Color="Color.Info" Title="Publisert" Style="flex-shrink: 0; font-size: 14px;" />
                                        }
                                        @if (recipe.IsLinkedToGlobal && !recipe.IsHellofresh)
                                        {
                                            <MudIcon Icon="@Icons.Material.Rounded.Link" Size="Size.Small" Color="Color.Secondary" Title="Koblet" Style="flex-shrink: 0; font-size: 14px;" />
                                        }
                                        <h3 class="food-card-title text-truncate">@recipe.Name</h3>
                                    </div>

                                    <div style="display:flex; gap:4px">

                                        @if (recipe.PrepTimeMinutes.HasValue || !string.IsNullOrEmpty(recipe.Difficulty))
                                        {
                                            <div class="d-flex align-center flex-wrap gap-1">
                                                @if (!string.IsNullOrEmpty(recipe.Difficulty))
                                                {
                                                    <span class="meta-chip @GetDifficultyClass(recipe.Difficulty)">
                                                        <MudIcon Icon="@GetDifficultyIcon(recipe.Difficulty)" Size="Size.Small" />
                                                        @GetDifficultyLabel(recipe.Difficulty)
                                                    </span>
                                                }
                                                @if (recipe.PrepTimeMinutes.HasValue)
                                                {
                                                    <span class="meta-chip">
                                                        <MudIcon Icon="@Icons.Material.Rounded.AccessTime" Size="Size.Small" />
                                                        @recipe.PrepTimeMinutes min
                                                    </span>
                                                }
                                            </div>
                                        }

                                        <div class="d-flex align-center gap-1">
                                            <MudIcon Icon="@Icons.Material.Rounded.Person" Size="Size.Small" Color="Color.Default" />
                                            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="text-truncate" Style="font-size:0.7rem;">
                                                @(recipe.UserDisplayName == AuthService.CurrentUserName ? "Meg" : recipe.UserDisplayName)
                                            </MudText>
                                        </div>
                                    </div>
                                </div>

                                @* Right: Average Badge *@
                                @if (recipe.AverageRating > 0)
                                {
                                    <div class="d-flex flex-column align-end" style="flex-shrink:0;">
                                        <span class="rating-badge" style="color:@recipe.AverageRating.ToRatingColorHex();">
                                            <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" Style="font-size:14px; margin-right:2px;" />
                                            @recipe.AverageRating.ToString("0.0")
                                        </span>

                                        @if (recipe.RatingCount > 0)
                                        {
                                            <span class="rating-count-badge">
                                                <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" Style="font-size:10px;" />
                                                @recipe.RatingCount
                                            </span>
                                        }
                                    </div>
                                }
                            </div>

                            @* Ratings Section *@
                            <div class="d-flex align-center flex-wrap mt-2 gap-2">
                                @if (recipe.MyRating.HasValue)
                                {
                                    <div class="rating-pill mine">
                                        <div class="rating-circle" style="background-color:var(--mud-palette-primary); color:var(--mud-palette-primary-text);">
                                            D
                                        </div>
                                        <span class="rating-score">@recipe.MyRating?.ToString("0.0")</span>
                                    </div>
                                }

                                @{
                                    var otherRatings = (recipe.MemberRatings ?? new Dictionary<string, decimal?>())
                                    .Where(r => r.Value.HasValue
                                    && !string.Equals(r.Key, AuthService.CurrentUserName, StringComparison.OrdinalIgnoreCase)
                                    && _allowedRaterNames.Contains(r.Key))
                                    .DistinctBy(r => r.Key)
                                    .Take(4);
                                }

                                @foreach (var rating in otherRatings)
                                {
                                    var initial = !string.IsNullOrEmpty(rating.Key) ? rating.Key.Substring(0, 1).ToUpper() : "?";
                                    <div class="rating-pill">
                                        <div class="rating-circle" style="background-color:@UserColorService.GetUserColor(rating.Key); color:white;">
                                            @initial
                                        </div>
                                        <span class="rating-score">@rating.Value?.ToString("0.0")</span>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    </ChildContent>
</XFade>

@code {
    private const int PersonalPageSize = 100;
    private const int CollectionPageSize = 100;
    private const int CollectionScanPageSize = 200;

    private List<UserRecipeDto> _recipes = new();
    private IEnumerable<UserRecipeDto> _sortedRecipes => GetSortedRecipes();

    private bool _isLoading = true;

    private int _loadVersion;

    private string _searchQuery = "";
    private string _sortBy = "date";
    private List<TagDto> _tags = new();
    private readonly List<Guid> _activeTagIds = new();
    private bool _personalActive = false;
    private readonly HashSet<string> _allowedRaterNames = new();

    protected override async Task OnInitializedAsync()
    {
        CollectionState.OnActiveFiltersChanged += OnFiltersChanged;

        await CollectionState.InitializeAsync();
        await DeviceState.InitializeAsync();

        // Restore saved filter state from device settings
        _personalActive = DeviceState.Settings.CookbookPersonalFilterActive;
        foreach (var collectionId in DeviceState.Settings.CookbookCollectionFilters)
        {
            // Only activate if user still has access to this collection
            if (CollectionState.UserCollections.Any(c => c.Id == collectionId))
            {
                CollectionState.SetCollectionFilter(collectionId, true);
            }
        }

        await LoadAllowedRaters();
        await LoadTags();

        await LoadRecipes();
    }

    private async Task TogglePersonal()
    {
        _personalActive = !_personalActive;
        await SaveFiltersToDevice();
        await LoadRecipes();
    }

    private void ToggleCollection(Guid collectionId)
    {
        CollectionState.ToggleCollectionFilter(collectionId);
        _ = SaveFiltersToDevice();
    }

    private async Task SaveFiltersToDevice()
    {
        var activeCollections = CollectionState.ActiveCollectionFilters.ToList();
        await DeviceState.SetCookbookFiltersAsync(activeCollections, _personalActive);
    }

    private void OnFiltersChanged()
    {
        _ = InvokeAsync(async () => await LoadRecipes());
    }

    private Task OnSearchChanged(string value) => LoadRecipes();

    private void OpenRecipe(Guid id) => Navigation.NavigateTo($"food/{id}");

    private string GetScoreColor(double score)
    {
        if (score >= 8) return "#4CAF50";
        if (score >= 6) return "#FFC107";
        return "#F44336";
    }

    private async Task LoadTags()
    {
        try
        {
            _tags = await ApiClient.GetMyTagsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading tags: {ex.Message}");
        }
    }

    private async Task ToggleTagFilter(Guid tagId)
    {
        if (_activeTagIds.Contains(tagId)) _activeTagIds.Remove(tagId);
        else _activeTagIds.Add(tagId);

        await LoadRecipes();
    }

    private async Task LoadAllowedRaters()
    {
        _allowedRaterNames.Clear();

        try
        {
            var friendships = await FriendshipService.GetFriendshipsAsync();
            foreach (var friend in friendships.Friends)
            {
                if (!string.IsNullOrEmpty(friend.FriendDisplayName))
                    _allowedRaterNames.Add(friend.FriendDisplayName);
            }

            foreach (var collection in CollectionState.UserCollections)
            {
                try
                {
                    var members = await ApiClient.GetCollectionMembersAsync(collection.Id);
                    foreach (var member in members)
                    {
                        if (!string.IsNullOrEmpty(member.DisplayName))
                            _allowedRaterNames.Add(member.DisplayName);
                    }
                }
                catch { /* ignore per collection */ }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading allowed raters: {ex.Message}");
        }
    }

    private IEnumerable<UserRecipeDto> GetSortedRecipes() => _sortBy switch
    {
        "name" => _recipes.OrderBy(r => r.Name),
        "rating" => _recipes.OrderByDescending(r => r.AverageRating),
        "personal_rating" => _recipes.OrderByDescending(r => r.MyRating ?? 0),
        _ => _recipes.OrderByDescending(r => r.CreatedAt)
    };

    private async Task LoadRecipes()
    {
        var requestVersion = ++_loadVersion;

        SetLoading(true);

        try
        {
            var hasSelectedCollections = HasSelectedCollections();
            var shouldLoadPersonal = ShouldLoadPersonal(hasSelectedCollections);
            var showOnlyUncategorized = ShowOnlyUncategorized(hasSelectedCollections);

            var combined = await LoadCombinedRecipesAsync(
                hasSelectedCollections,
                shouldLoadPersonal,
                showOnlyUncategorized);

            var deduped = Deduplicate(combined);

            if (_activeTagIds.Any())
                deduped = FilterByTags(deduped);

            if (requestVersion != _loadVersion) return;

            _recipes = deduped.ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
        finally
        {
            if (requestVersion == _loadVersion)
                SetLoading(false);
        }
    }

    private void SetLoading(bool isLoading)
    {
        _isLoading = isLoading;
        _ = InvokeAsync(StateHasChanged);
    }

    private bool HasSelectedCollections() =>
        CollectionState.HasCollections && CollectionState.ActiveCollectionFilters.Any();

    private bool ShouldLoadPersonal(bool hasSelectedCollections) =>
        !hasSelectedCollections || _personalActive;

    private bool ShowOnlyUncategorized(bool hasSelectedCollections) =>
        _personalActive && !hasSelectedCollections;

    private async Task<List<UserRecipeDto>> LoadCombinedRecipesAsync(
        bool hasSelectedCollections,
        bool shouldLoadPersonal,
        bool showOnlyUncategorized)
    {
        var combined = new List<UserRecipeDto>();

        // IMPORTANT:
        // If you want the richer "personal" DTO to win over the "collection" DTO,
        // load personal first, then collections. (See note below.)
        if (shouldLoadPersonal)
            combined.AddRange(await LoadPersonalRecipesAsync(showOnlyUncategorized));

        if (hasSelectedCollections)
            combined.AddRange(await LoadSelectedCollectionRecipesAsync());

        return combined;
    }

    private IEnumerable<UserRecipeDto> Deduplicate(List<UserRecipeDto> recipes) =>
        recipes.DistinctBy(r => r.Id);

    private IEnumerable<UserRecipeDto> FilterByTags(IEnumerable<UserRecipeDto> recipes) =>
        recipes.Where(r => r.Tags.Any(t => _activeTagIds.Contains(t.Id)));


    private async Task<List<UserRecipeDto>> LoadSelectedCollectionRecipesAsync()
    {
        var list = new List<UserRecipeDto>();

        foreach (var collectionId in CollectionState.ActiveCollectionFilters)
        {
            try
            {
                var query = new GetCollectionRecipesQuery { Search = _searchQuery, PageSize = CollectionPageSize };
                var res = await ApiClient.GetCollectionRecipesAsync(collectionId, query);
                list.AddRange(res.Recipes);
            }
            catch { /* ignore per collection */ }
        }

        return list;
    }

    private async Task<List<UserRecipeDto>> LoadPersonalRecipesAsync(bool showOnlyUncategorized)
    {
        var userQuery = new GetUserRecipesQuery
        {
            Search = _searchQuery,
            PageSize = PersonalPageSize,
            TagIds = _activeTagIds.Any() ? _activeTagIds : null
        };

        var personalResult = await RecipeService.GetMyRecipesAsync(userQuery);

        if (!showOnlyUncategorized)
            return personalResult.Recipes.ToList();

        var inAnyCollection = await GetAllRecipeIdsInCollectionsAsync();
        return personalResult.Recipes.Where(r => !inAnyCollection.Contains(r.Id)).ToList();
    }

    private async Task<HashSet<Guid>> GetAllRecipeIdsInCollectionsAsync()
    {
        var ids = new HashSet<Guid>();

        foreach (var collection in CollectionState.UserCollections)
        {
            try
            {
                var res = await ApiClient.GetCollectionRecipesAsync(
                    collection.Id,
                    new GetCollectionRecipesQuery { PageSize = CollectionScanPageSize });

                foreach (var r in res.Recipes)
                    ids.Add(r.Id);
            }
            catch { /* ignore */ }
        }

        return ids;
    }

    private string GetDifficultyIcon(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
        "medium" or "middels" => Icons.Material.Rounded.Psychology,
        "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
        _ => Icons.Material.Rounded.HelpOutline
    };

    private string GetDifficultyLabel(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" => "Lett",
        "medium" => "Middels",
        "hard" => "Vanskelig",
        _ => difficulty ?? ""
    };

    private string GetDifficultyClass(string? difficulty) => difficulty?.ToLower() switch
    {
        "easy" or "lett" => "difficulty-easy",
        "medium" or "middels" => "difficulty-medium",
        "hard" or "vanskelig" => "difficulty-hard",
        _ => ""
    };

    public void Dispose()
    {
        CollectionState.OnActiveFiltersChanged -= OnFiltersChanged;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\CookBook.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\FoodDetails.razor
================================================================================
@page "/food/{Id:guid}"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Components
@using StorhaugenWebsite.Shared.Extensions
@using System.Text.Json
@inject IUserRecipeService RecipeService
@inject IAuthService AuthService
@inject IUserColorService UserColorService
@inject IUserFriendshipService FriendshipService
@inject NavigationManager Navigation
@inject IApiClient ApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ICollectionStateService CollectionState
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="GoBack">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_recipe == null)
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Fant ikke oppskriften</h2>
        <p class="empty-state-text">
            Denne oppskriften er enten slettet, eller du har mistet tilgangen til den.
        </p>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="">
            Tilbake til start
        </MudButton>
    </div>
}
else
{
    @* --- IMAGE CAROUSEL --- *@
    @if (_recipe.ImageUrls.Any())
    {
        <div class="detail-image-carousel">
            <MudCarousel Class="mud-width-full"
                         Style="height: 240px; border-radius: 20px;"
                         ShowArrows="@(_recipe.ImageUrls.Count > 1)"
                         ShowBullets="@(_recipe.ImageUrls.Count > 1)"
                         EnableSwipeGesture="true"
                         AutoCycle="false"
                         TData="object">
                @foreach (var imageUrl in _recipe.ImageUrls)
                {
                    <MudCarouselItem Transition="Transition.Slide" Color="@Color.Transparent">
                        <div class="d-flex" style="height:100%">
                            <MudImage Src="@imageUrl" Alt="@_recipe.Name" ObjectFit="ObjectFit.Cover" Style="width: 100%; height: 100%; border-radius: 20px;" />
                        </div>
                    </MudCarouselItem>
                }
            </MudCarousel>
        </div>
    }
    

    @* --- INFO CARD --- *@
    <div class="detail-info-card">
        <div class="d-flex justify-space-between align-start gap-3">
            <div>
                <h1 class="detail-title">@_recipe.Name</h1>
                <div class="d-flex align-center gap-2 mt-1 flex-wrap">
                    @if (_recipe.IsHellofresh)
                    {
                        <MudChip T="string" Color="Color.Success" Size="Size.Small" Icon="@Icons.Material.Rounded.LocalDining">HelloFresh</MudChip>
                    }
                    else if (IsOwner)
                    {
                        <MudChip T="string" Color="Color.Primary" Size="Size.Small" Variant="Variant.Text">Min oppskrift</MudChip>
                    }
                    else
                    {
                        <MudChip T="string" Color="Color.Secondary" Size="Size.Small" Icon="@Icons.Material.Rounded.Person">
                            @_recipe.UserDisplayName
                        </MudChip>
                    }
                    <MudText Typo="Typo.caption" Color="Color.Secondary"> @_recipe.CreatedAt.ToString("dd. MMM")</MudText>
                </div>
            </div>

            @if (_recipe.AverageRating > 0)
            {
                <div class="d-flex flex-column align-end">
                    <span class="rating-badge @GetRatingClass(_recipe.AverageRating)" style="font-size: 1rem; padding: 8px 14px; color:@_recipe.AverageRating.ToRatingColorHex();">
                        <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                        @_recipe.AverageRating.ToString("0.0")
                    </span>
                    @if (_recipe.RatingCount > 0)
                    {
                        <span class="rating-count-badge">
                            <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" Style="font-size: 12px;" />
                            @_recipe.RatingCount
                        </span>
                    }
                </div>
            }
        </div>

        @* Quick Info (PrepTime, CookTime, Difficulty, Servings, Cuisine) *@
        @if (_recipe.PrepTimeMinutes.HasValue || _recipe.CookTimeMinutes.HasValue || !string.IsNullOrEmpty(_recipe.Difficulty) || _recipe.Servings.HasValue || !string.IsNullOrEmpty(_recipe.Cuisine))
        {
            <div class="quick-info-row mt-3">
                @if (_recipe.PrepTimeMinutes.HasValue)
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.AccessTime" Size="Size.Small" Color="Color.Primary" />
                        <span>@_recipe.PrepTimeMinutes min tilberedning</span>
                    </div>
                }
                @if (!string.IsNullOrEmpty(_recipe.Difficulty))
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@GetDifficultyIcon(_recipe.Difficulty)" Size="Size.Small" Color="Color.Secondary" />
                        <span>@GetDifficultyLabel(_recipe.Difficulty)</span>
                    </div>
                }
                @if (_recipe.Servings.HasValue)
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.Group" Size="Size.Small" Color="Color.Tertiary" />
                        <span>@_recipe.Servings porsjoner</span>
                    </div>
                }
                @if (!string.IsNullOrEmpty(_recipe.Cuisine))
                {
                    <div class="quick-info-item">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" Color="Color.Info" />
                        <span>@_recipe.Cuisine</span>
                    </div>
                }
            </div>
        }

        @* HelloFresh Week Info *@
        @if (_recipe.IsHellofresh && !string.IsNullOrEmpty(_recipe.HellofreshWeek))
        {
            <div class="d-flex align-center gap-2 mt-2">
                <MudIcon Icon="@Icons.Material.Rounded.CalendarMonth" Size="Size.Small" Color="Color.Success" />
                <MudText Typo="Typo.caption" Color="Color.Secondary">HelloFresh uke @_recipe.HellofreshWeek</MudText>
            </div>
        }

        @if (!string.IsNullOrWhiteSpace(_recipe.Description))
        {
            <p class="detail-description mt-4">@_recipe.Description</p>
        }

        @* Recipe Tags *@
        @if (_recipe.RecipeTags.Any())
        {
            <div class="d-flex flex-wrap gap-2 mt-3">
                @foreach (var tag in _recipe.RecipeTags)
                {
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Default">@tag</MudChip>
                }
            </div>
        }

        @* Link Status *@
        @if (_recipe.IsLinkedToGlobal && !_recipe.IsHellofresh)
        {
            <div class="recipe-source-info mt-3">
                <div class="d-flex align-center gap-2">
                    <MudIcon Icon="@Icons.Material.Rounded.Link" Color="Color.Info" Size="Size.Small" />
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Koblet til: <b>@(_recipe.GlobalRecipeName)</b>
                    </MudText>
                </div>
            </div>
        }
    </div>

    @* --- COLLAPSIBLE SECTIONS --- *@
    @if (HasNutritionData || HasIngredients)
    {
        <MudExpansionPanels Class="mt-4" Style="margin-bottom: 16px" MultiExpansion="true">
            @* Nutrition Info *@
            @if (HasNutritionData)
            {
                <MudExpansionPanel Text="Nringsinformasjon" Icon="@Icons.Material.Rounded.LocalFireDepartment">
                    <div class="nutrition-grid">
                        @foreach (var item in ParseNutrition())
                        {
                            <div class="nutrition-item">
                                <span class="nutrition-value">@item.Amount</span>
                                <span class="nutrition-label">@item.Name</span>
                            </div>
                        }
                    </div>
                </MudExpansionPanel>
            }

            @* Ingredients *@
            @if (HasIngredients)
            {
                <MudExpansionPanel Text="Ingredienser" Icon="@Icons.Material.Rounded.ShoppingCart" IsInitiallyExpanded="true">
                    <div class="ingredients-list">
                        @foreach (var ingredient in ParseIngredients())
                        {
                            <div class="ingredient-item">
                                @if (!string.IsNullOrEmpty(ingredient.Image))
                                {
                                    <img src="@GetIngredientImageUrl(ingredient.Image)" alt="@ingredient.Name" class="ingredient-image" />
                                }
                                else
                                {
                                    <div class="ingredient-placeholder">
                                        <MudIcon Icon="@Icons.Material.Rounded.Egg" Size="Size.Small" />
                                    </div>
                                }
                                <div class="ingredient-info">
                                    <span class="ingredient-name">@ingredient.Name</span>
                                    @if (!string.IsNullOrEmpty(ingredient.Amount) || !string.IsNullOrEmpty(ingredient.Unit))
                                    {
                                        <span class="ingredient-amount">@ingredient.Amount @ingredient.Unit</span>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </MudExpansionPanel>
            }
        </MudExpansionPanels>
    }

    @* --- ACTIONS SECTION --- *@
    <div class="form-section">
        <p class="form-section-title">Handlinger</p>

        @if (IsOwner)
        {
            <div class="d-flex flex-column gap-3">

                @* --- NEW: PUBLISH LOGIC --- *@
                @if (!_recipe.IsPublished)
                {
                    @* Not Published: Show Publish Button *@
                    <div class="visibility-card">
                        <div class="d-flex align-center justify-space-between">
                            <div class="d-flex align-center gap-3">
                                <MudIcon Icon="@Icons.Material.Rounded.Public" Color="Color.Info" />
                                <div>
                                    <MudText Typo="Typo.subtitle2">Publisering</MudText>
                                    <MudText Typo="Typo.caption">Del oppskriften med hele fellesskapet</MudText>
                                </div>
                            </div>
                            <MudButton Variant="Variant.Filled" Color="Color.Info" Size="Size.Small" OnClick="PublishRecipe" Disabled="_isProcessing">
                                Publiser
                            </MudButton>
                        </div>
                    </div>
                }
                else
                {
                    @* Published: Show Status and Unpublish Option *@
                    <div class="visibility-card" style="border: 1px solid var(--mud-palette-success); background: rgba(var(--mud-palette-success-rgb), 0.05);">
                        <div class="d-flex align-center justify-space-between">
                            <div class="d-flex align-center gap-3">
                                <MudIcon Icon="@Icons.Material.Rounded.CheckCircle" Color="Color.Success" />
                                <div>
                                    <MudText Typo="Typo.subtitle2">Publisert</MudText>
                                    <MudText Typo="Typo.caption">Tilgjengelig for alle</MudText>
                                </div>
                            </div>
                            <MudMenu Icon="@Icons.Material.Rounded.MoreVert" Size="Size.Small" AnchorOrigin="Origin.BottomRight">
                                <MudMenuItem Icon="@Icons.Material.Rounded.Delete" IconColor="Color.Error" OnClick="DeletePublishedRecipe">Slett publisert versjon</MudMenuItem>
                            </MudMenu>
                        </div>
                    </div>
                }

                @* Collection Management *@
                <div class="visibility-card">
                    <div class="d-flex align-center justify-space-between mb-2">
                        <div class="d-flex align-center gap-3">
                            <MudIcon Icon="@Icons.Material.Rounded.FolderShared" Color="Color.Primary" />
                            <div>
                                <MudText Typo="Typo.subtitle2">Samlinger</MudText>
                                <MudText Typo="Typo.caption">Organiser oppskriften i samlinger</MudText>
                            </div>
                        </div>
                    </div>

                    @if (_recipeCollections.Any())
                    {
                        <div class="d-flex flex-wrap gap-2 mb-2">
                            @foreach (var collection in _recipeCollections)
                            {
                                <MudChip T="string"
                                         Color="Color.Primary"
                                         Size="Size.Small"
                                         OnClose="@(() => RemoveFromCollection(collection.Id))"
                                         Icon="@Icons.Material.Rounded.Folder">
                                    @collection.Name
                                </MudChip>
                            }
                        </div>
                    }
                    else
                    {
                        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
                            Ikke i noen samling
                        </MudText>
                    }

                    @if (CollectionState.UserCollections.Any(c => !_recipeCollections.Any(rc => rc.Id == c.Id)))
                    {
                        <MudButton Variant="Variant.Text"
                                   Color="Color.Primary"
                                   Size="Size.Small"
                                   StartIcon="@Icons.Material.Rounded.Add"
                                   OnClick="OpenAddToCollectionMenu">
                            Legg til i samling
                        </MudButton>
                    }
                </div>

                @* Edit / Archive Buttons *@
                <div class="d-flex gap-2">
                    <MudButton Variant="Variant.Outlined" Color="Color.Primary" FullWidth="true" StartIcon="@Icons.Material.Rounded.Edit" OnClick="EditRecipe">
                        Rediger
                    </MudButton>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" FullWidth="true" StartIcon="@Icons.Material.Rounded.Archive" OnClick="ArchiveRecipe">
                        Arkiver
                    </MudButton>
                </div>
            </div>
        }
        else
        {
            @* Visitor View *@
            <div class="alert-box pa-3 mb-3" style="background-color: rgba(var(--mud-palette-warning-rgb), 0.1); border-radius: 12px;">
                <div class="d-flex gap-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Info" Color="Color.Warning" />
                    <div>
                        <MudText Typo="Typo.subtitle2">Du er i lesemodus</MudText>
                        <MudText Typo="Typo.caption">
                            Dette er @_recipe.UserDisplayName sin oppskrift.
                        </MudText>
                    </div>
                </div>
            </div>

            <MudButton Variant="Variant.Filled" Color="Color.Success" FullWidth="true" Size="Size.Large" StartIcon="@Icons.Material.Rounded.SaveAlt" OnClick="SaveCopyToMyCollection" Disabled="_isProcessing">
                @if (_isProcessing)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Lagrer...</span>
         }
        else
        {
                    <span>Lagre min egen kopi</span>
                }
            </MudButton>
        }
    </div>

    @* --- NOTES & RATING --- *@
    @if (IsOwner)
    {
        <div class="form-section">
            <div class="d-flex justify-space-between align-center mb-2">
                <p class="form-section-title mb-0">Personlige Notater</p>
                <MudIconButton Icon="@Icons.Material.Rounded.Save" Size="Size.Small" Color="Color.Primary" OnClick="SaveNotes" Disabled="_isSavingNotes" />
            </div>
            <MudTextField @bind-Value="_notes" Variant="Variant.Outlined" Lines="3" Placeholder="Notater er kun synlige for deg..." Class="mb-2" />
        </div>
    }

    <div class="form-section">
        <p class="form-section-title">Vurdering</p>

        @* My Rating - Only show if user can rate *@
        @if (CanRate)
        {
            var myRatingColor = ((double)_myRating).ToRatingColorHex();
            
            <div class="d-flex align-center gap-3 mb-3">
                <MudSlider T="decimal" Value="_myRating" ValueChanged="OnRatingChanged" Min="0" Max="10" Step="0.1M" Color="Color.Primary" Style="flex: 1;" Class="rating-slider" />
                <span class="rating-badge-colored" style="--rating-color: @myRatingColor;">
                    @(_myRating > 0 ? _myRating.ToString("0.0") : "-")
                </span>
            </div>
        }
        else
        {
            <MudAlert Severity="Severity.Info" Variant="Variant.Text" Dense="true" Class="mb-3">
                Du m lagre oppskriften for  kunne vurdere den.
            </MudAlert>
        }

        @* Collection Members' Ratings (only from friends and collection members) *@
        @{
            var otherRatings = (_recipe?.MemberRatings ?? new Dictionary<string, decimal?>())
                .Where(r => r.Value.HasValue
                    && !string.Equals(r.Key, AuthService.CurrentUserName, StringComparison.OrdinalIgnoreCase)
                    && _allowedRaterNames.Contains(r.Key)) // Only show ratings from friends/collection members
                .ToList();
        }

        @if (otherRatings.Any())
        {
            <MudDivider Class="my-3" />
            <MudText Typo="Typo.subtitle2" Class="mb-2">Andre i samlingen</MudText>
            <div class="d-flex flex-wrap gap-2">
                @foreach (var rating in otherRatings)
                {
                    var initial = !string.IsNullOrEmpty(rating.Key) ? rating.Key.Substring(0, 1).ToUpper() : "?";

                    <div class="rating-pill">
                        <div class="rating-circle" style="background-color: @UserColorService.GetUserColor(rating.Key); color: white;">
                            @initial
                        </div>
                        <span class="rating-score">@rating.Value?.ToString("0.0")</span>
                        <MudTooltip Text="@rating.Key" Placement="Placement.Top">
                            <span class="rating-name">@rating.Key</span>
                        </MudTooltip>
                    </div>
                }
            </div>
        }

        @* Public Rating Count (if published) *@
        @if (_recipe?.IsPublished == true && _recipe.RatingCount > 0)
        {
            <MudDivider Class="my-3" />
            <div class="d-flex align-center gap-2">
                <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" Color="Color.Info" />
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    Offentlig vurdering: <b>@_recipe.AverageRating.ToString("0.0")</b> (@_recipe.RatingCount @(_recipe.RatingCount == 1 ? "vurdering" : "vurderinger"))
                </MudText>
            </div>
        }
    </div>
}

<style>
    .quick-info-row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
    }

    .quick-info-item {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        font-size: 0.85rem;
    }

    .nutrition-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
    }

    .nutrition-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        text-align: center;
    }

    .nutrition-value {
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--mud-palette-primary);
    }

    .nutrition-label {
        font-size: 0.65rem;
        color: var(--mud-palette-text-secondary);
        text-transform: uppercase;
        margin-top: 2px;
    }

    .ingredients-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .ingredient-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
    }

    .ingredient-image {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        object-fit: cover;
        background: white;
    }

    .ingredient-placeholder {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        background: var(--mud-palette-divider);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-disabled);
    }

    .ingredient-info {
        display: flex;
        flex-direction: column;
    }

    .ingredient-name {
        font-weight: 500;
        color: var(--mud-palette-text-primary);
    }

    .ingredient-amount {
        font-size: 0.8rem;
        color: var(--mud-palette-text-secondary);
    }

    .visibility-card {
        background: var(--mud-palette-background-grey);
        border-radius: 12px;
        padding: 12px;
    }

    .rating-badge-colored {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 3px;
        font-size: 1rem;
        padding: 8px 14px;
        min-width: 50px;
        text-align: center;
        border-radius: 12px;
        font-weight: 600;
        color: var(--rating-color);
        background: color-mix(in srgb, var(--rating-color) 15%, transparent);
    }

    /* Fix MudSlider touch issues on mobile */
    .rating-slider {
        touch-action: none;
    }

    .rating-slider .mud-slider-track {
        cursor: pointer;
    }

    .rating-slider .mud-slider-filled {
        pointer-events: none;
    }

    @@media (max-width: 600px) {
        .nutrition-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .quick-info-row {
            gap: 8px;
        }

        .quick-info-item {
            font-size: 0.8rem;
            padding: 4px 8px;
        }
    }
</style>

@implements IDisposable

@code {
    [Parameter] public Guid Id { get; set; }

    private UserRecipeDto? _recipe;
    private bool _isLoading = true;
    private bool _isProcessing = false;
    private bool _isSavingNotes = false;
    private string _notes = "";
    private decimal _myRating = 0;
    private Guid _currentUserId;
    private List<CollectionDto> _recipeCollections = new();
    private HashSet<string> _allowedRaterNames = new(); // Friends + collection members

    // Debounce for rating slider
    private CancellationTokenSource? _ratingDebounceTimer;
    private const int RatingDebounceMs = 500;

    private bool IsOwner => _recipe?.UserId == _currentUserId;

    // User can rate if they own the recipe OR if the recipe is in one of their collections
    private bool CanRate => IsOwner || _recipeCollections.Any(c => CollectionState.UserCollections.Any(uc => uc.Id == c.Id));

    private async Task GoBack()
    {
        await JSRuntime.InvokeVoidAsync("history.back");
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var user = await ApiClient.GetMyProfileAsync();
            if (user != null) _currentUserId = user.Id;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading user profile: {ex.Message}");
        }
        await CollectionState.InitializeAsync();
        await LoadAllowedRaters();
        await LoadRecipe();
        await LoadRecipeCollections();
    }

    /// <summary>
    /// Loads the list of allowed raters (friends + collection members).
    /// Ratings from users not in this list will be hidden.
    /// </summary>
    private async Task LoadAllowedRaters()
    {
        _allowedRaterNames.Clear();

        try
        {
            // 1. Add all friends
            var friendships = await FriendshipService.GetFriendshipsAsync();
            foreach (var friend in friendships.Friends)
            {
                if (!string.IsNullOrEmpty(friend.FriendDisplayName))
                {
                    _allowedRaterNames.Add(friend.FriendDisplayName);
                }
            }

            // 2. Add all collection members from user's collections
            foreach (var collection in CollectionState.UserCollections)
            {
                try
                {
                    var members = await ApiClient.GetCollectionMembersAsync(collection.Id);
                    foreach (var member in members)
                    {
                        if (!string.IsNullOrEmpty(member.DisplayName))
                        {
                            _allowedRaterNames.Add(member.DisplayName);
                        }
                    }
                }
                catch { /* Continue to next collection */ }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading allowed raters: {ex.Message}");
        }
    }

    private async Task LoadRecipe()
    {
        _isLoading = true;
        try
        {
            _recipe = await RecipeService.GetRecipeAsync(Id);
            if (_recipe != null)
            {
                _notes = _recipe.PersonalNotes ?? "";
                _myRating = _recipe.MyRating ?? 0m;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add("Kunne ikke laste oppskrift", Severity.Error);
            Console.WriteLine(ex);
        }
        finally { _isLoading = false; }
    }

    // --- NEW: PUBLISH LOGIC ---
    private async Task PublishRecipe()
    {
        if (_recipe == null) return;

        // Use the existing component PublishRecipeDialog
        var parameters = new DialogParameters<PublishRecipeDialog> { { x => x.Recipe, _recipe } };
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small, FullWidth = true };

        var dialog = await DialogService.ShowAsync<PublishRecipeDialog>("Publiser", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            await LoadRecipe(); // Reload to update UI (IsPublished will be true)
        }
    }

    private async Task DeletePublishedRecipe()
    {
        if (_recipe == null || !_recipe.GlobalRecipeId.HasValue) return;

        var confirm = await DialogService.ShowMessageBox(
            "Slett publisert versjon?",
            "Dette fjerner oppskriften fra fellesskapet. Din lokale kopi beholdes, men koblingen brytes.",
            yesText: "Slett", cancelText: "Avbryt");

        if (confirm == true)
        {
            _isProcessing = true;
            try
            {
                // 1. Detach locally first to break link
                await RecipeService.DetachRecipeAsync(_recipe.Id);

                // 2. Delete the global version using new ApiClient method
                await ApiClient.DeleteGlobalRecipeAsync(_recipe.GlobalRecipeId.Value);

                Snackbar.Add("Publisert versjon slettet.", Severity.Success);
                await LoadRecipe();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
                await LoadRecipe();
            }
            finally { _isProcessing = false; }
        }
    }
    // --------------------------

    private async Task SaveCopyToMyCollection()
    {
        if (_recipe == null) return;
        _isProcessing = true;
        try
        {
            var copyDto = new CreateUserRecipeDto
            {
                Name = $"{_recipe.Name} (Kopi)",
                Description = _recipe.Description,
                Ingredients = _recipe.Ingredients,
                ImageUrls = _recipe.ImageUrls,
                GlobalRecipeId = _recipe.GlobalRecipeId,
                Visibility = "private"
            };
            var newRecipe = await RecipeService.CreateRecipeAsync(copyDto); // [cite: 1201]
            Snackbar.Add("Kopiert!", Severity.Success);
            Navigation.NavigateTo($"food/{newRecipe.Id}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
        finally { _isProcessing = false; }
    }

    private async Task SaveNotes()
    {
        if (_recipe == null) return;
        _isSavingNotes = true;
        try
        {
            await RecipeService.UpdateRecipeAsync(_recipe.Id, new UpdateUserRecipeDto { PersonalNotes = _notes });
            Snackbar.Add("Notater lagret", Severity.Success);
        }
        catch { Snackbar.Add("Kunne ikke lagre notater", Severity.Error); }
        _isSavingNotes = false;
    }

    private async Task OnRatingChanged(decimal rating)
    {
        if (_recipe == null) return;
        _myRating = rating;

        // Cancel any pending save
        _ratingDebounceTimer?.Cancel();
        _ratingDebounceTimer = new CancellationTokenSource();

        try
        {
            // Wait for debounce period (user stops dragging)
            await Task.Delay(RatingDebounceMs, _ratingDebounceTimer.Token);

            // Save the rating
            await RecipeService.RateRecipeAsync(_recipe.Id, rating);
            Snackbar.Add("Vurdering lagret", Severity.Success);
        }
        catch (TaskCanceledException)
        {
            // Debounce cancelled - user still dragging, do nothing
        }
        catch
        {
            Snackbar.Add("Kunne ikke lagre vurdering", Severity.Error);
        }
    }

    public void Dispose()
    {
        _ratingDebounceTimer?.Cancel();
        _ratingDebounceTimer?.Dispose();
    }

    // --- Collection Management ---
    private async Task LoadRecipeCollections()
    {
        if (_recipe == null) return;

        _recipeCollections = new List<CollectionDto>();
        foreach (var collection in CollectionState.UserCollections)
        {
            try
            {
                var result = await ApiClient.GetCollectionRecipesAsync(collection.Id, new GetCollectionRecipesQuery { PageSize = 200 });
                if (result.Recipes.Any(r => r.Id == _recipe.Id))
                {
                    _recipeCollections.Add(collection);
                }
            }
            catch { /* Continue to next collection */ }
        }
        StateHasChanged();
    }

    private async Task RemoveFromCollection(Guid collectionId)
    {
        if (_recipe == null) return;
        try
        {
            await CollectionState.RemoveRecipeFromCollectionAsync(collectionId, _recipe.Id);
            _recipeCollections.RemoveAll(c => c.Id == collectionId);
            Snackbar.Add("Fjernet fra samling", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
    }

    private async Task OpenAddToCollectionMenu()
    {
        if (_recipe == null) return;

        var availableCollections = CollectionState.UserCollections
            .Where(c => !_recipeCollections.Any(rc => rc.Id == c.Id))
            .ToList();

        if (!availableCollections.Any())
        {
            Snackbar.Add("Ingen tilgjengelige samlinger", Severity.Info);
            return;
        }

        var parameters = new DialogParameters<AddToCollectionDialog>
        {
            { x => x.AvailableCollections, availableCollections },
            { x => x.RecipeId, _recipe.Id }
        };
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.ExtraSmall, FullWidth = true };

        var dialog = await DialogService.ShowAsync<AddToCollectionDialog>("Legg til i samling", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled && result.Data is CollectionDto selectedCollection)
        {
            _recipeCollections.Add(selectedCollection);
            StateHasChanged();
        }
    }

    private async Task ArchiveRecipe()
    {
        if (_recipe == null) return;
        var confirm = await DialogService.ShowMessageBox("Arkiver", "Er du sikker?", yesText: "Arkiver", cancelText: "Avbryt");
        if (confirm == true)
        {
            await RecipeService.ArchiveRecipeAsync(_recipe.Id);
            Navigation.NavigateTo("");
        }
    }

    private async Task EditRecipe()
    {
        if (_recipe == null) return;

        var parameters = new DialogParameters<EditRecipeDialog> { { x => x.Recipe, _recipe } };
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small, FullWidth = true };

        var dialog = await DialogService.ShowAsync<EditRecipeDialog>("Rediger", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            // Reload the recipe to get updated data
            await LoadRecipe();
        }
    }

    private string GetRatingClass(double r) => r >= 8 ? "rating-high" : r >= 5 ? "rating-medium" : "rating-low";
    private string GetVisibilityText(string v) => v switch { "private" => "Privat (Kun deg)", "household" => "Privat", "public" => "Offentlig", _ => v };
    private string GetVisibilityIcon(string v) => v switch { "public" => Icons.Material.Rounded.Public, _ => Icons.Material.Rounded.Lock };

    // Difficulty helpers
    private string GetDifficultyIcon(string? difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" or "lett" => Icons.Material.Rounded.SentimentSatisfied,
            "medium" or "middels" => Icons.Material.Rounded.Psychology,
            "hard" or "vanskelig" => Icons.Material.Rounded.LocalFireDepartment,
            _ => Icons.Material.Rounded.HelpOutline
        };
    }

    private string GetDifficultyLabel(string? difficulty)
    {
        return difficulty?.ToLower() switch
        {
            "easy" => "Lett",
            "medium" => "Middels",
            "hard" => "Vanskelig",
            _ => difficulty ?? ""
        };
    }

    // Nutrition and Ingredients parsing
    private record NutritionInfo(string Name, string Amount);
    private record IngredientInfo(string Name, string? Amount, string? Unit, string? Image);

    private bool HasNutritionData => _recipe?.NutritionData != null;
    private bool HasIngredients => _recipe?.Ingredients != null;

    private List<NutritionInfo> ParseNutrition()
    {
        var items = new List<NutritionInfo>();
        if (_recipe?.NutritionData == null) return items;

        try
        {
            if (_recipe.NutritionData is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Object)
            {
                foreach (var prop in jsonElement.EnumerateObject())
                {
                    var amount = prop.Value.ToString();
                    var name = GetNutritionDisplayName(prop.Name);
                    items.Add(new NutritionInfo(name, amount));
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing nutrition data: {ex.Message}");
        }
        return items;
    }

    private string GetNutritionDisplayName(string key)
    {
        return key.ToLower() switch
        {
            "kalorier" => "kcal",
            "energi (kj)" => "kJ",
            "fett" => "Fett",
            "mettet fett" => "M. fett",
            "karbohydrater" => "Karb.",
            "sukker" => "Sukker",
            "protein" => "Protein",
            "natrium" => "Natrium",
            _ => key.Length > 8 ? key.Substring(0, 6) + ".." : key
        };
    }

    private List<IngredientInfo> ParseIngredients()
    {
        var items = new List<IngredientInfo>();
        if (_recipe?.Ingredients == null) return items;

        try
        {
            if (_recipe.Ingredients is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var item in jsonElement.EnumerateArray())
                {
                    var name = item.TryGetProperty("name", out var n) ? n.GetString() : "";
                    var amount = item.TryGetProperty("amount", out var a) ? a.ToString() : null;
                    var unit = item.TryGetProperty("unit", out var u) ? u.GetString() : null;
                    var image = item.TryGetProperty("image", out var i) ? i.GetString() : null;

                    if (!string.IsNullOrEmpty(name))
                    {
                        items.Add(new IngredientInfo(name!, amount, unit, image));
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing ingredients: {ex.Message}");
        }
        return items;
    }

    private string GetIngredientImageUrl(string? imagePath)
    {
        if (string.IsNullOrEmpty(imagePath)) return "";
        if (imagePath.StartsWith("http")) return imagePath;
        return $"https://d3hvwccx09j84u.cloudfront.net/0,0{imagePath}";
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\FoodDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\FriendRatings.razor
================================================================================
@page "/friends/{FriendUserId:guid}"
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IApiClient ApiClient
@inject IUserFriendshipService FriendshipService
@inject ICollectionStateService CollectionState
@inject IUserColorService UserColorService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<MudPaper Class="pa-4" Elevation="0">
    <div class="d-flex justify-space-between align-center mb-4">
        <MudButton Variant="Variant.Text" StartIcon="@Icons.Material.Rounded.ArrowBack"
                   OnClick="@(() => Navigation.NavigateTo("friends"))">
            Tilbake
        </MudButton>
        <MudMenu Icon="@Icons.Material.Rounded.MoreVert" AnchorOrigin="Origin.BottomRight">
            <MudMenuItem Icon="@Icons.Material.Rounded.PersonRemove" IconColor="Color.Error" OnClick="RemoveFriend">Fjern venn</MudMenuItem>
        </MudMenu>
    </div>

    @if (!_loaded)
    {
        <div class="d-flex justify-center my-6">
            <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
        </div>
    }
    else if (_friend == null)
    {
        <div class="d-flex flex-column align-center pa-4">
            <MudIcon Icon="@Icons.Material.Rounded.PersonOff" Size="Size.Large" Color="Color.Default" />
            <MudText Class="mt-2">Fant ikke brukerprofil.</MudText>
        </div>
    }
    else
    {
        @* --- PROFILE HEADER --- *@
        <div class="d-flex flex-column align-center mb-6">
            <MudAvatar Style="@($"width:80px; height:80px; font-size: 2rem; background-color: {UserColorService.GetUserColor(_friend.DisplayName)}; color: white;")" Variant="Variant.Filled" Class="mb-3">
                @(_friend.DisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
            </MudAvatar>

            <MudText Typo="Typo.h5" Style="font-weight: 700;">@_friend.DisplayName</MudText>

            @if (!string.IsNullOrWhiteSpace(_friend.Bio))
            {
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1 text-center">@_friend.Bio</MudText>
            }

            @if (CollectionState.UserCollections.Any())
            {
                <div class="d-flex gap-2 mt-4">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Success"
                               StartIcon="@Icons.Material.Rounded.GroupAdd"
                               OnClick="OpenInviteDialog">
                        Legg til i samling
                    </MudButton>
                </div>
            }
        </div>

        <MudDivider Class="my-4" />

        @* Shared Collections Section *@
        <div class="d-flex justify-space-between align-center mb-2">
            <MudText Typo="Typo.h6">Delte samlinger</MudText>
            <MudButton Variant="Variant.Text" Color="Color.Primary" Size="Size.Small"
                       StartIcon="@Icons.Material.Rounded.Link" OnClick="ShowShareCodeDialog">
                Åpne med kode
            </MudButton>
        </div>

        @if (_friendCollections.Count == 0)
        {
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                @_friend.DisplayName har ingen samlinger delt med deg.
            </MudText>
        }
        else
        {
            <div class="d-flex flex-column gap-2 mb-4">
                @foreach (var collection in _friendCollections)
                {
                    <MudPaper Class="pa-3" Elevation="0" Outlined="true" Style="cursor: pointer;"
                              @onclick="() => OpenFriendCollection(collection)">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Size="Size.Medium" Color="@GetVisibilityColor(collection.Visibility)" Variant="Variant.Filled">
                                <MudIcon Icon="@GetVisibilityIcon(collection.Visibility)" />
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.subtitle2" Style="font-weight: 600;">@collection.Name</MudText>
                                @if (!string.IsNullOrEmpty(collection.Description))
                                {
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="text-truncate">@collection.Description</MudText>
                                }
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @collection.RecipeCount oppskrifter
                                </MudText>
                            </div>
                            <MudIcon Icon="@Icons.Material.Rounded.ChevronRight" Color="Color.Default" />
                        </div>
                    </MudPaper>
                }
            </div>
        }
    }
</MudPaper>

@* Dialog is now shown via IDialogService with AddMemberToCollectionDialog component *@

@* Share Code Dialog *@
<MudDialog @bind-Visible="_showShareCodeDialog" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Åpne samling med kode</MudText>
    </TitleContent>
    <DialogContent>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
            Skriv inn samlingskoden du har fått fra vennen din.
        </MudText>
        <MudTextField @bind-Value="_shareCode"
                      Label="Samlingskode"
                      Variant="Variant.Outlined"
                      Placeholder="F.eks. ABC123"
                      Immediate="true" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showShareCodeDialog = false">Avbryt</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="OpenSharedCollection"
                   Disabled="@(string.IsNullOrWhiteSpace(_shareCode))">
            Åpne
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter] public Guid FriendUserId { get; set; }

    private FriendProfileDto? _friend;
    private List<CollectionDto> _friendCollections = new();
    private bool _loaded;
    private bool _showShareCodeDialog = false;
    private string _shareCode = "";

    protected override async Task OnInitializedAsync()
    {
        await CollectionState.InitializeAsync();
        try
        {
            _friend = await FriendshipService.GetUserProfileAsync(FriendUserId);
            _friendCollections = await ApiClient.GetFriendCollectionsAsync(FriendUserId);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste profil: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loaded = true;
        }
    }

    private void OpenFriendCollection(CollectionDto collection)
    {
        if (string.IsNullOrEmpty(collection.ShareCode)) return;
        var returnUrl = Uri.EscapeDataString($"friends/{FriendUserId}");
        Navigation.NavigateTo($"collections/shared/{collection.ShareCode}?returnUrl={returnUrl}");
    }

    private string GetVisibilityIcon(string visibility) => visibility switch
    {
        "public" => Icons.Material.Rounded.Public,
        "friends" => Icons.Material.Rounded.People,
        _ => Icons.Material.Rounded.Lock
    };

    private Color GetVisibilityColor(string visibility) => visibility switch
    {
        "public" => Color.Success,
        "friends" => Color.Info,
        _ => Color.Default
    };

    private async Task OpenInviteDialog()
    {
        if (_friend == null) return;

        // Ensure collections are loaded
        await CollectionState.RefreshCollectionsAsync();

        if (!CollectionState.HasCollections)
        {
            Snackbar.Add("Du har ingen samlinger.", Severity.Warning);
            return;
        }

        // Show collections user owns (only owners can add members)
        var availableCollections = CollectionState.UserCollections
            .Where(c => CollectionState.IsOwnerOf(c.Id))
            .ToList();

        if (!availableCollections.Any())
        {
            Snackbar.Add("Du må være eier av en samling for å legge til medlemmer.", Severity.Warning);
            return;
        }

        // Use IDialogService to show the dialog component (MudBlazor 8.15 compatible)
        var parameters = new DialogParameters<AddMemberToCollectionDialog>
        {
            { x => x.AvailableCollections, availableCollections },
            { x => x.UserShareId, _friend.ShareId },
            { x => x.UserDisplayName, _friend.DisplayName ?? "" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<AddMemberToCollectionDialog>("Legg til i samling", parameters, options);
    }

    private async Task RemoveFriend()
    {
        if (_friend == null) return;

        var friendships = await FriendshipService.GetFriendshipsAsync();
        var friendship = friendships.Friends.FirstOrDefault(f => f.FriendUserId == FriendUserId);

        if (friendship == null)
        {
            Snackbar.Add("Kunne ikke finne vennskapet.", Severity.Error);
            return;
        }

        var confirm = await DialogService.ShowMessageBox(
            "Fjern venn",
            $"Er du sikker på at du vil fjerne {_friend.DisplayName} som venn?",
            yesText: "Ja, fjern", cancelText: "Avbryt");

        if (confirm == true)
        {
            try
            {
                await FriendshipService.RemoveFriendAsync(friendship.FriendUserId);
                Snackbar.Add("Venn fjernet", Severity.Info);
                Navigation.NavigateTo("friends");
            }
            catch
            {
                Snackbar.Add("Kunne ikke fjerne venn", Severity.Error);
            }
        }
    }

    private void ShowShareCodeDialog()
    {
        _shareCode = "";
        _showShareCodeDialog = true;
    }

    private void OpenSharedCollection()
    {
        if (string.IsNullOrWhiteSpace(_shareCode)) return;

        _showShareCodeDialog = false;
        var returnUrl = Uri.EscapeDataString($"friends/{FriendUserId}");
        Navigation.NavigateTo($"collections/shared/{_shareCode.Trim()}?returnUrl={returnUrl}");
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\FriendRatings.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Friends.razor
================================================================================
@page "/friends"
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.ApiClient
@inject IUserFriendshipService FriendshipService
@inject ICollectionStateService CollectionState
@inject IUserColorService UserColorService
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<div class="friends-container animate-in">
    @* --- HEADER --- *@
    <div class="d-flex justify-space-between align-center mb-4">
        <MudText Typo="Typo.h4" Style="font-family: 'Fraunces', serif;">Venner</MudText>
        @if (_friends.Any())
        {
            <MudText Typo="Typo.caption" Color="Color.Secondary">@_friends.Count venner</MudText>
        }
    </div>

    @* --- SEARCH BAR --- *@
    <MudTextField @bind-Value="_searchQuery"
                  Placeholder="Søk etter navn eller ID..."
                  Variant="Variant.Outlined"
                  Adornment="Adornment.Start"
                  AdornmentIcon="@Icons.Material.Rounded.Search"
                  OnKeyUp="OnSearchKeyUp"
                  Immediate="true"
                  DebounceInterval="500"
                  OnDebounceIntervalElapsed="PerformSearch"
                  Class="search-field mb-4"
                  Clearable="true"
                  OnClearButtonClick="@(() => _searchQuery = string.Empty)" />

    @* --- LOADING STATE --- *@
    @if (_isLoading)
    {
        <div class="d-flex flex-column gap-3">
            @for (int i = 0; i < 4; i++)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="72px" Class="rounded-lg" />
            }
        </div>
    }
    @* --- SEARCH RESULTS MODE --- *@
    else if (!string.IsNullOrWhiteSpace(_searchQuery))
    {
        <MudText Typo="Typo.subtitle2" Class="mb-2 ml-1" Color="Color.Secondary">Resultater</MudText>

        @if (_searchResults.Any())
        {
            <div class="d-flex flex-column gap-3">
                @foreach (var user in _searchResults)
                {
                    <MudPaper Class="pa-3 friend-card" Elevation="0" Outlined="true">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Size="Size.Medium" Style="@($"background-color: {UserColorService.GetUserColor(user.DisplayName)}; color: white;")">
                                @(user.DisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body1" Style="font-weight: 600;">@user.DisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">ID: @user.ShareId</MudText>
                            </div>

                            @if (user.FriendshipStatus == "friends")
                            {
                                <MudChip T="string" Color="Color.Success" Size="Size.Small" Variant="Variant.Text" Icon="@Icons.Material.Rounded.Check">Venn</MudChip>
                            }
                            else if (user.FriendshipStatus == "pending_sent")
                            {
                                <MudChip T="string" Color="Color.Warning" Size="Size.Small" Variant="Variant.Text">Venter</MudChip>
                            }
                            else if (user.FriendshipStatus == "pending_received")
                            {
                                <MudChip T="string" Color="Color.Info" Size="Size.Small" Variant="Variant.Text">Har sendt deg</MudChip>
                            }
                            else
                            {
                                <MudIconButton Icon="@Icons.Material.Rounded.PersonAdd"
                                               Color="Color.Primary"
                                               Variant="Variant.Filled"
                                               Size="Size.Small"
                                               OnClick="@(() => SendFriendRequest(user))" />
                            }
                        </div>
                    </MudPaper>
                }
            </div>
        }
        else if (!_isSearching)
        {
            <div class="empty-state">
                <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" Color="Color.Default" />
                <MudText Typo="Typo.body1" Class="mt-2">Ingen brukere funnet</MudText>
            </div>
        }
    }
    else
    {
        @* --- STANDARD LIST MODE --- *@

        @* 1. INCOMING REQUESTS *@
        @if (_pendingReceived.Any())
        {
            <div class="section-header">
                <MudIcon Icon="@Icons.Material.Rounded.MarkEmailUnread" Size="Size.Small" Color="Color.Primary" />
                <MudText Typo="Typo.subtitle2" Color="Color.Primary">Forespørsler</MudText>
            </div>

            <div class="d-flex flex-column gap-2 mb-6">
                @foreach (var request in _pendingReceived)
                {
                    <MudPaper Class="pa-3 friend-card request-card" Elevation="0">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Size="Size.Medium" Style="@($"background-color: {UserColorService.GetUserColor(request.FriendDisplayName)}; color: white;")">
                                @(request.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body2" Style="font-weight: 600;">@request.FriendDisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">Vil bli venn med deg</MudText>
                            </div>
                        </div>
                        <div class="d-flex gap-2 mt-3">
                            <MudButton Variant="Variant.Filled" Color="Color.Success" Size="Size.Small" FullWidth="true" OnClick="@(() => AcceptRequest(request))">Godta</MudButton>
                            <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" FullWidth="true" OnClick="@(() => RejectRequest(request))">Avslå</MudButton>
                        </div>
                    </MudPaper>
                }
            </div>
        }

        @* 2. FRIENDS LIST *@
        @if (_friends.Any())
        {
            <div class="d-flex flex-column gap-2">
                @foreach (var friend in _friends)
                {
                    <MudPaper Class="pa-3 friend-card" Elevation="0" @onclick="@(() => OpenFriendProfile(friend))">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Size="Size.Medium" Variant="Variant.Filled" Style="@($"background-color: {UserColorService.GetUserColor(friend.FriendDisplayName)}; color: white;")">
                                @(friend.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body1" Style="font-weight: 600;">@friend.FriendDisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @friend.RecipeCount oppskrifter
                                </MudText>
                            </div>
                            <MudIcon Icon="@Icons.Material.Rounded.ChevronRight" Color="Color.Default" />
                        </div>
                    </MudPaper>
                }
            </div>
        }
        else if (!_pendingReceived.Any() && !_pendingSent.Any())
        {
            <div class="empty-state mt-8">
                <MudIcon Icon="@Icons.Material.Rounded.PersonSearch" Size="Size.Large" Color="Color.Default" />
                <MudText Typo="Typo.h6" Class="mt-2">Ingen venner ennå</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Style="max-width: 250px;">
                    Søk etter brukernavn eller ID i feltet over for å legge til venner.
                </MudText>
            </div>
        }

        @* 3. OUTGOING REQUESTS (Collapsed) *@
        @if (_pendingSent.Any())
        {
            <MudExpansionPanel Text="@($"Sendte forespørsler ({_pendingSent.Count})")" Class="mt-6 shadow-none bg-transparent" DisableGutters="true">
                <div class="d-flex flex-column gap-2 mt-2">
                    @foreach (var request in _pendingSent)
                    {
                        <MudPaper Class="pa-3 friend-card" Elevation="0" Outlined="true" Style="opacity: 0.8;">
                            <div class="d-flex align-center gap-3">
                                <MudAvatar Size="Size.Small" Style="@($"background-color: {UserColorService.GetUserColor(request.FriendDisplayName)}; color: white;")">
                                    @(request.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                                </MudAvatar>
                                <div class="flex-grow-1">
                                    <MudText Typo="Typo.body2">@request.FriendDisplayName</MudText>
                                    <MudText Typo="Typo.caption" Color="Color.Secondary">Venter...</MudText>
                                </div>
                                <MudIconButton Icon="@Icons.Material.Rounded.Close" Size="Size.Small" OnClick="@(() => CancelRequest(request))" />
                            </div>
                        </MudPaper>
                    }
                </div>
            </MudExpansionPanel>
        }
    }
</div>


@code {
    private List<UserFriendshipDto> _friends = new();
    private List<UserFriendshipDto> _pendingReceived = new();
    private List<UserFriendshipDto> _pendingSent = new();
    private List<UserSearchResultDto> _searchResults = new();

    private string _searchQuery = "";
    private bool _isLoading = true;
    private bool _isSearching = false;

    protected override async Task OnInitializedAsync()
    {
        await CollectionState.InitializeAsync();
        await LoadFriendships();
    }

    private async Task LoadFriendships()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var friendships = await FriendshipService.GetFriendshipsAsync();
            _friends = friendships.Friends ?? new();
            _pendingReceived = friendships.PendingReceived ?? new();
            _pendingSent = friendships.PendingSent ?? new();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste venner: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery))
        {
            _searchResults.Clear();
            StateHasChanged();
            return;
        }

        _isSearching = true;
        StateHasChanged();

        try
        {
            _searchResults = await FriendshipService.SearchUsersAsync(_searchQuery);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Søk feilet: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSearching = false;
            StateHasChanged();
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs args)
    {
        if (args.Key == "Enter") await PerformSearch();
    }

    private async Task SendFriendRequest(UserSearchResultDto user)
    {
        try
        {
            await FriendshipService.SendFriendRequestAsync(user.Id);
            user.FriendshipStatus = "pending_sent";
            Snackbar.Add($"Forespørsel sendt til {user.DisplayName}", Severity.Success);
            _ = LoadFriendships();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke sende forespørsel: {ex.Message}", Severity.Error);
        }
    }

    private async Task AcceptRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.AcceptFriendRequestAsync(request.Id);
            Snackbar.Add($"Du er nå venn med {request.FriendDisplayName}!", Severity.Success);
            await LoadFriendships();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
    }

    private async Task RejectRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.RejectFriendRequestAsync(request.Id);
            _pendingReceived.Remove(request);
            StateHasChanged();
        }
        catch
        {
            Snackbar.Add("Kunne ikke avslå", Severity.Error);
        }
    }

    private async Task CancelRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.RemoveFriendAsync(request.Id);
            _pendingSent.Remove(request);
            StateHasChanged();
            Snackbar.Add("Forespørsel kansellert", Severity.Info);
        }
        catch
        {
            Snackbar.Add("Kunne ikke kansellere", Severity.Error);
        }
    }

    private void OpenFriendProfile(UserFriendshipDto friend)
    {
        Navigation.NavigateTo($"friends/{friend.FriendUserId}");
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Friends.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\HelloTest.razor
================================================================================
@page "/hello-test"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IApiClient ApiClient
@inject IAuthService AuthService
@inject ISnackbar Snackbar
@attribute [Authorize]

<MudContainer MaxWidth="MaxWidth.Medium" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">HelloFresh Admin Panel</MudText>

    @if (!_isAdmin)
    {
        <MudAlert Severity="Severity.Error" Class="mb-4">
            <MudIcon Icon="@Icons.Material.Rounded.Lock" Class="mr-2" />
            Du har ikke tilgang til denne siden. Bare administratorer kan se denne siden.
        </MudAlert>
    }
    else
    {
        @* Sync Status Card *@
        <MudCard Class="mb-4">
            <MudCardHeader>
                <CardHeaderContent>
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.CloudSync" Color="Color.Primary" />
                        <MudText Typo="Typo.h6">Synkroniseringsstatus</MudText>
                    </div>
                </CardHeaderContent>
                <CardHeaderActions>
                    <MudIconButton Icon="@Icons.Material.Rounded.Refresh" OnClick="LoadSyncStatus" Disabled="_isLoadingStatus" />
                </CardHeaderActions>
            </MudCardHeader>
            <MudCardContent>
                @if (_isLoadingStatus)
                {
                    <div class="d-flex justify-center pa-4">
                        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                    </div>
                }
                else if (_syncStatus == null)
                {
                    <MudAlert Severity="Severity.Info">Ingen synkronisering er utfort enda.</MudAlert>
                }
                else
                {
                    <div class="d-flex flex-column gap-2">
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Siste synkronisering:</MudText>
                            <MudText Typo="Typo.body2" Style="font-weight: 600;">
                                @(_syncStatus.LastSync?.ToLocalTime().ToString("dd.MM.yyyy HH:mm") ?? "Aldri")
                            </MudText>
                        </div>
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Status:</MudText>
                            <MudChip T="string" Size="Size.Small" Color="@GetStatusColor(_syncStatus.Status)" Variant="Variant.Filled">
                                @(_syncStatus.Status ?? "Ukjent")
                            </MudChip>
                        </div>
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Oppskrifter lagt til:</MudText>
                            <MudText Typo="Typo.body2" Style="font-weight: 600;">@_syncStatus.RecipesAdded</MudText>
                        </div>
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Oppskrifter oppdatert:</MudText>
                            <MudText Typo="Typo.body2" Style="font-weight: 600;">@_syncStatus.RecipesUpdated</MudText>
                        </div>
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Build ID:</MudText>
                            <MudText Typo="Typo.body2" Style="font-family: monospace;">@(_syncStatus.BuildId ?? "N/A")</MudText>
                        </div>
                        <div class="d-flex justify-space-between">
                            <MudText Typo="Typo.body2" Color="Color.Secondary">Uker synkronisert:</MudText>
                            <MudText Typo="Typo.body2" Style="font-weight: 600;">@(_syncStatus.WeeksSynced ?? "N/A")</MudText>
                        </div>
                        @if (!string.IsNullOrEmpty(_syncStatus.ErrorMessage))
                        {
                            <MudAlert Severity="Severity.Error" Dense="true" Class="mt-2">
                                @_syncStatus.ErrorMessage
                            </MudAlert>
                        }
                    </div>
                }
            </MudCardContent>
        </MudCard>

        @* Manual Sync Card *@
        <MudCard Class="mb-4">
            <MudCardHeader>
                <CardHeaderContent>
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.CloudDownload" Color="Color.Success" />
                        <MudText Typo="Typo.h6">Manuell synkronisering</MudText>
                    </div>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <MudAlert Severity="Severity.Warning" Dense="true" Class="mb-4">
                    Manuell synkronisering vil overstyre 24-timers regelen og hente oppskrifter umiddelbart.
                </MudAlert>

                @* Full Sync Button *@
                <div class="mb-4">
                    <MudText Typo="Typo.subtitle2" Class="mb-2">Full synkronisering (alle kommende uker)</MudText>
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               OnClick="TriggerFullSync"
                               Disabled="_isSyncing"
                               StartIcon="@Icons.Material.Rounded.Sync"
                               FullWidth="true">
                        @if (_isSyncing && _syncingAll)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" Color="Color.Surface" />
                            <span>Synkroniserer...</span>
                        }
                        else
                        {
                            <span>Start full synkronisering (Force)</span>
                        }
                    </MudButton>
                </div>

                <MudDivider Class="my-4" />

                @* Week-specific Sync *@
                <MudText Typo="Typo.subtitle2" Class="mb-2">Synkroniser spesifikk uke</MudText>
                <div class="d-flex gap-2 mb-2">
                    <MudSelect T="string"
                               @bind-Value="_selectedWeek"
                               Label="Velg uke"
                               Variant="Variant.Outlined"
                               Style="min-width: 200px;">
                        @foreach (var week in _availableWeeks)
                        {
                            <MudSelectItem Value="@week">@week</MudSelectItem>
                        }
                    </MudSelect>
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Success"
                               OnClick="TriggerWeekSync"
                               Disabled="_isSyncing || string.IsNullOrEmpty(_selectedWeek)"
                               StartIcon="@Icons.Material.Rounded.CloudDownload">
                        @if (_isSyncing && !_syncingAll)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" Color="Color.Surface" />
                            <span>Synkroniserer...</span>
                        }
                        else
                        {
                            <span>Synkroniser uke</span>
                        }
                    </MudButton>
                </div>
            </MudCardContent>
        </MudCard>

        @* Test Data Card (existing functionality) *@
        <MudCard Class="mb-4">
            <MudCardHeader>
                <CardHeaderContent>
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Science" Color="Color.Info" />
                        <MudText Typo="Typo.h6">Test HelloFresh API</MudText>
                    </div>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <MudAlert Severity="Severity.Info" Class="mb-4">
                    Dette tester direkte henting fra HelloFresh API uten a lagre data.
                </MudAlert>

                <MudButton Variant="Variant.Outlined"
                           Color="Color.Info"
                           OnClick="FetchData"
                           Disabled="_isLoading"
                           StartIcon="@Icons.Material.Rounded.CloudDownload">
                    @(_isLoading ? "Henter..." : "Test HelloFresh API")
                </MudButton>

                @if (_data != null && _data.PageProps?.SsrPayload?.Courses != null)
                {
                    <MudText Typo="Typo.h6" Class="mt-6 mb-2">
                        Fant @_data.PageProps.SsrPayload.Courses.Count oppskrifter
                    </MudText>

                    <div class="d-flex flex-wrap gap-4 mt-4">
                        @foreach (var item in _data.PageProps.SsrPayload.Courses.Take(6))
                        {
                            var recipe = item.Recipe;
                            <MudCard Style="width: 280px;">
                                <MudCardMedia Image="@recipe.ImageLink" Height="160" />
                                <MudCardContent>
                                    <MudText Typo="Typo.subtitle1" Style="font-weight: 600;">@recipe.Name</MudText>
                                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="text-truncate">@recipe.Headline</MudText>
                                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Class="mt-2">@recipe.PrepTime</MudChip>
                                </MudCardContent>
                            </MudCard>
                        }
                    </div>
                }
            </MudCardContent>
        </MudCard>
    }
</MudContainer>

@code {
    private bool _isLoading = false;
    private bool _isLoadingStatus = false;
    private bool _isSyncing = false;
    private bool _syncingAll = false;
    private HelloFreshRawResponse? _data;
    private HelloFreshSyncStatus? _syncStatus;
    private List<string> _availableWeeks = new();
    private string? _selectedWeek;
    private bool _isAdmin = false;

    // Admin email whitelist
    private readonly HashSet<string> _adminEmails = new(StringComparer.OrdinalIgnoreCase)
    {
        "markussvenoy@gmail.com",
        "eliassvenoy@gmail.com"
    };

    protected override async Task OnInitializedAsync()
    {
        // Check if user is admin
        var userEmail = AuthService.CurrentUserEmail;
        _isAdmin = !string.IsNullOrEmpty(userEmail) && _adminEmails.Contains(userEmail);

        if (_isAdmin)
        {
            await LoadSyncStatus();
            await LoadAvailableWeeks();
        }
    }

    private async Task LoadSyncStatus()
    {
        _isLoadingStatus = true;
        try
        {
            _syncStatus = await ApiClient.GetHelloFreshSyncStatusAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading sync status: {ex.Message}");
            Snackbar.Add("Kunne ikke laste synkroniseringsstatus", Severity.Error);
        }
        finally
        {
            _isLoadingStatus = false;
        }
    }

    private async Task LoadAvailableWeeks()
    {
        try
        {
            _availableWeeks = await ApiClient.GetAvailableHelloFreshWeeksToFetchAsync();
            if (_availableWeeks.Any())
            {
                _selectedWeek = _availableWeeks.First();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading available weeks: {ex.Message}");
        }
    }

    private async Task TriggerFullSync()
    {
        _isSyncing = true;
        _syncingAll = true;
        try
        {
            var result = await ApiClient.TriggerHelloFreshSyncAsync(force: true);
            Snackbar.Add($"Synkronisering fullfort! {result.RecipesAdded} nye, {result.RecipesUpdated} oppdatert", Severity.Success);
            await LoadSyncStatus();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error syncing: {ex.Message}");
            Snackbar.Add($"Synkronisering feilet: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSyncing = false;
            _syncingAll = false;
        }
    }

    private async Task TriggerWeekSync()
    {
        if (string.IsNullOrEmpty(_selectedWeek)) return;

        _isSyncing = true;
        _syncingAll = false;
        try
        {
            var result = await ApiClient.SyncHelloFreshWeekAsync(_selectedWeek);
            Snackbar.Add($"Uke {_selectedWeek} synkronisert! {result.RecipesAdded} nye, {result.RecipesUpdated} oppdatert", Severity.Success);
            await LoadSyncStatus();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error syncing week: {ex.Message}");
            Snackbar.Add($"Synkronisering feilet: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSyncing = false;
        }
    }

    private async Task FetchData()
    {
        _isLoading = true;
        try
        {
            _data = await ApiClient.GetHelloFreshTestRawAsync();
            Snackbar.Add("Data hentet!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
            Console.WriteLine(ex);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private Color GetStatusColor(string? status)
    {
        return status?.ToLower() switch
        {
            "success" => Color.Success,
            "failed" => Color.Error,
            _ => Color.Default
        };
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\HelloTest.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Home.razor
================================================================================
@page "/"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.Components
@using StorhaugenWebsite.Services
@inject IAuthService AuthService
@inject NavigationManager Navigation
@attribute [Authorize]

<div class="home-container">
    @* --- ACTION GRID --- *@
    <div class="action-grid mb-8">
        <div class="action-card variant-primary" @onclick="@(() => Navigation.NavigateTo("add"))">
            <div class="card-content">
                <div class="action-icon-circle mb-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Add" />
                </div>
                <div class="action-text">
                    <MudText Typo="Typo.h6" Class="font-weight-bold" Style="line-height: 1.2;">Logg middag</MudText>
                    <MudText Typo="Typo.body2" Style="opacity: 0.9;">Hva spiste dere?</MudText>
                </div>
            </div>
            <div class="watermark-container">
                <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Class="watermark-icon" />
            </div>
        </div>

        <div class="action-card variant-surface" @onclick="@(() => Navigation.NavigateTo("browse"))">
            <div class="card-content">
                <div class="action-icon-circle surface-icon mb-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Public" />
                </div>
                <div class="action-text">
                    <MudText Typo="Typo.h6" Class="font-weight-bold" Style="line-height: 1.2;">Utforsk</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Finn nye oppskrifter</MudText>
                </div>
            </div>
            <div class="watermark-container surface-watermark-container">
                <MudIcon Icon="@Icons.Material.Rounded.TravelExplore" Class="watermark-icon" />
            </div>
        </div>
    </div>

    @* --- ACTIVITY FEED --- *@
    <ActivityFeed PageSize="10" />
</div>

<style>
    .home-container { padding-bottom: 80px; }

    .action-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
    }

    .action-card {
        position: relative;
        border-radius: 24px;
        padding: 20px;
        height: 160px;
        display: flex;
        cursor: pointer;
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
        overflow: hidden;
    }

    .action-card:active { transform: scale(0.96); }

    .card-content {
        position: relative;
        z-index: 2;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-start;
    }

    .action-card.variant-primary {
        background: linear-gradient(135deg, #E07A2E 0%, #C56820 100%);
        color: white;
        box-shadow: 0 8px 20px rgba(224, 122, 46, 0.3);
    }

    .action-card.variant-primary .action-icon-circle {
        background: rgba(255, 255, 255, 0.2);
        color: white;
    }

    .action-card.variant-primary .watermark-icon {
        color: white;
        opacity: 0.3;
    }

    .action-card.variant-surface {
        background: var(--mud-palette-surface);
        border-color: var(--mud-palette-divider);
        box-shadow: 0 4px 12px rgba(0,0,0,0.03);
    }

    .action-card.variant-surface .action-icon-circle {
        background: rgba(var(--mud-palette-info-rgb), 0.1);
        color: var(--mud-palette-info);
    }

    .action-card.variant-surface .watermark-icon {
        color: var(--mud-palette-text-secondary);
        opacity: 0.15;
    }

    .action-icon-circle {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
    }

    .watermark-container {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 60%;
        overflow: hidden;
        z-index: 1;
        -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0.1) 80%, rgba(0,0,0,0) 100%);
        mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0.1) 80%, rgba(0,0,0,0) 100%);
        border-radius: 0 24px 24px 0;
    }

    .surface-watermark-container {
        -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,1) 10%, rgba(0,0,0,0.05) 70%, rgba(0,0,0,0) 100%);
        mask-image: linear-gradient(to left, rgba(0,0,0,1) 10%, rgba(0,0,0,0.05) 70%, rgba(0,0,0,0) 100%);
    }

    .watermark-icon {
        position: absolute;
        top: 50%;
        right: -20px;
        transform: translateY(-50%) rotate(-10deg) scale(1.2);
        font-size: 140px !important;
        pointer-events: none;
        transition: transform 0.3s ease-out, right 0.3s ease-out;
    }

    .action-card:hover .watermark-icon {
        transform: translateY(-50%) rotate(0deg) scale(1.3);
        right: -10px;
    }
</style>

@code {
    // Cookbook-style: crossfade only once (initial load)
    private bool _firstLoadInProgress = true;
    private bool _showSkeleton = true;
    private bool _hasLoadedOnce = false;

    private int _fadeToken;

    private async Task OnFeedLoadingChanged(bool isLoading)
    {
        // Ignore "loading=true" after we already have content on screen.
        // This is what prevents the "fade out".
        if (_hasLoadedOnce && isLoading)
            return;

        if (isLoading)
        {
            // First load only: show skeleton + keep wrapper in loading state
            _fadeToken++;
            _firstLoadInProgress = true;
            _showSkeleton = true;
            await InvokeAsync(StateHasChanged);
            return;
        }

        // Finished (first load)
        _firstLoadInProgress = false;
        _hasLoadedOnce = true;

        var token = ++_fadeToken;
        await InvokeAsync(StateHasChanged);

        // Remove skeleton after the fade completes
        await Task.Delay(180);

        if (!_firstLoadInProgress && token == _fadeToken)
        {
            _showSkeleton = false;
            await InvokeAsync(StateHasChanged);
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\Home.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Login.razor
================================================================================
@page "/login"
@using StorhaugenWebsite.Services
@using System.ComponentModel.DataAnnotations
@using System.Text.Json
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<div class="login-container">
    <div class="login-card animate-in">
        <div class="login-logo">
            <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Size="Size.Large" />
        </div>

        <h1 class="login-title">Storhaugen Eats</h1>
        <p class="login-subtitle">Sporing av familiemiddager gjort enkelt</p>

        @* --- ALERTS --- *@
        @if (!string.IsNullOrEmpty(_errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mb-4" Dense="true" ShowCloseIcon="true" CloseIconClicked="() => _errorMessage = null">
                @_errorMessage
            </MudAlert>
        }

        @if (!string.IsNullOrEmpty(_successMessage))
        {
            <MudAlert Severity="Severity.Success" Class="mb-4" Variant="Variant.Filled" Dense="true">
                <MudText Typo="Typo.body2">@_successMessage</MudText>
            </MudAlert>
        }

        @* --- FORM AREA --- *@
        <div class="form-content">
            @if (_isLoginMode)
            {
                // *** LOGIN FORM ***
                <MudForm @ref="_loginForm" @bind-IsValid="_loginValid" @onkeydown="@(e => HandleEnterKey(e))">
                    <MudTextField @bind-Value="_email"
                                  Label="E-post"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Email"
                                  Required="true"
                                  RequiredError="E-post er pkrevd"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_password"
                                  Label="Passord"
                                  Variant="Variant.Outlined"
                                  InputType="@_passwordInputType"
                                  Adornment="Adornment.End"
                                  AdornmentIcon="@_passwordInputIcon"
                                  OnAdornmentClick="TogglePasswordVisibility"
                                  Required="true"
                                  RequiredError="Passord er pkrevd"
                                  Immediate="true"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="DoEmailLogin"
                               Disabled="@(_isLoading || !_loginValid)"
                               Class="login-action-btn">
                        @if (_isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Logger inn...</span>
                        }
                        else
                        {
                            <span>Logg inn</span>
                        }
                    </MudButton>
                </MudForm>

                <div class="toggle-mode-text mt-4">
                    Har du ikke bruker? <a href="#" @onclick:preventDefault @onclick="ToggleMode" class="text-link">Opprett konto</a>
                </div>
            }
            else
            {
                // *** REGISTER FORM ***
                <MudForm @ref="_registerForm" @bind-IsValid="_registerValid" @onkeydown="@(e => HandleEnterKey(e))">
                    <MudTextField @bind-Value="_regDisplayName"
                                  Label="Navn"
                                  Variant="Variant.Outlined"
                                  Required="true"
                                  RequiredError="Navn er pkrevd"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_regEmail"
                                  Label="E-post"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Email"
                                  Required="true"
                                  RequiredError="E-post er pkrevd"
                                  Validation="@(new EmailAddressAttribute() { ErrorMessage = "Ugyldig e-post" })"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_regPassword"
                                  Label="Passord"
                                  Variant="Variant.Outlined"
                                  InputType="@_passwordInputType"
                                  Adornment="Adornment.End"
                                  AdornmentIcon="@_passwordInputIcon"
                                  OnAdornmentClick="TogglePasswordVisibility"
                                  Required="true"
                                  RequiredError="Passord er pkrevd"
                                  HelperText="Minst 6 tegn"
                                  Immediate="true"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Secondary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="DoEmailRegister"
                               Disabled="@(_isLoading || !_registerValid)"
                               Class="login-action-btn">
                        @if (_isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Registrerer...</span>
                        }
                        else
                        {
                            <span>Opprett konto</span>
                        }
                    </MudButton>
                </MudForm>

                <div class="toggle-mode-text mt-4">
                    Har du allerede bruker? <a href="#" @onclick:preventDefault @onclick="ToggleMode" class="text-link">Logg inn</a>
                </div>
            }
        </div>

        <div class="divider-text mt-6 mb-4">ELLER</div>

        <button class="google-btn" @onclick="DoGoogleLogin" disabled="@_isLoading">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4" />
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853" />
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05" />
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335" />
            </svg>
            <span>Fortsett med Google</span>
        </button>
    </div>
</div>

<style>
    .login-action-btn {
        border-radius: 12px;
        height: 48px;
        text-transform: none;
        font-weight: 600;
        font-family: 'DM Sans', sans-serif;
    }

    .text-link {
        color: var(--mud-palette-primary);
        font-weight: 600;
        text-decoration: none;
    }

        .text-link:hover {
            text-decoration: underline;
        }

    .toggle-mode-text {
        font-size: 0.9rem;
        color: var(--mud-palette-text-secondary);
    }

    .google-btn {
        width: 100%;
        padding: 12px 24px;
        border-radius: 12px;
        border: 1px solid var(--mud-palette-divider);
        background: var(--mud-palette-surface);
        color: var(--mud-palette-text-primary);
        font-weight: 500;
        font-size: 0.95rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        transition: background-color 0.2s;
        font-family: 'DM Sans', system-ui, sans-serif;
    }

        .google-btn:hover {
            background-color: var(--mud-palette-background-grey);
        }

    .divider-text {
        display: flex;
        align-items: center;
        color: var(--mud-palette-text-secondary);
        font-size: 0.8rem;
        font-weight: 600;
    }

        .divider-text::before, .divider-text::after {
            content: "";
            flex: 1;
            height: 1px;
            background: var(--mud-palette-divider);
        }

        .divider-text::before {
            margin-right: 10px;
        }

        .divider-text::after {
            margin-left: 10px;
        }
</style>

@code {
    private bool _isLoading = false;
    private string? _errorMessage;
    private string? _successMessage;

    // Toggle state: true = Login, false = Register
    private bool _isLoginMode = true;

    // Login Fields
    private MudForm? _loginForm;
    private bool _loginValid;
    private string _email = "";
    private string _password = "";

    // Register Fields
    private MudForm? _registerForm;
    private bool _registerValid;
    private string _regEmail = "";
    private string _regPassword = "";
    private string _regDisplayName = "";

    // Password Visibility
    private bool _passwordVisible;
    private InputType _passwordInputType = InputType.Password;
    private string _passwordInputIcon = Icons.Material.Filled.VisibilityOff;

    protected override async Task OnInitializedAsync()
    {
        await AuthService.InitializeAsync();
        if (AuthService.IsAuthorized)
        {
            Navigation.NavigateTo("");
        }
    }

    private void ToggleMode()
    {
        _isLoginMode = !_isLoginMode;
        _errorMessage = null;
        _successMessage = null;
    }

    private void TogglePasswordVisibility()
    {
        if (_passwordVisible)
        {
            _passwordVisible = false;
            _passwordInputIcon = Icons.Material.Filled.VisibilityOff;
            _passwordInputType = InputType.Password;
        }
        else
        {
            _passwordVisible = true;
            _passwordInputIcon = Icons.Material.Filled.Visibility;
            _passwordInputType = InputType.Text;
        }
    }

    private async Task DoEmailLogin()
    {
        await _loginForm!.Validate();
        if (!_loginValid) return;

        _isLoading = true;
        _errorMessage = null;
        _successMessage = null;

        var (success, error) = await AuthService.SignInWithEmailAsync(_email, _password);

        _isLoading = false;

        if (success)
        {
            Navigation.NavigateTo("");
        }
        else
        {
            _errorMessage = CleanErrorMessage(error);
        }
    }

    private async Task DoEmailRegister()
    {
        await _registerForm!.Validate();
        if (!_registerValid) return;

        _isLoading = true;
        _errorMessage = null;
        _successMessage = null;

        var (success, error) = await AuthService.SignUpWithEmailAsync(_regEmail, _regPassword, _regDisplayName);

        _isLoading = false;

        if (success)
        {
            // If explicit error message returned (like "Check your email"), treat it as success message
            if (!string.IsNullOrEmpty(error))
            {
                // Explicitly warn the user about email confirmation
                _successMessage = "Konto opprettet! Du m bekrefte e-postadressen din fr du kan logge inn. Sjekk innboksen din.";

                // Clear inputs and switch to login mode so they can login after confirming
                _regEmail = "";
                _regPassword = "";
                _regDisplayName = "";
                _isLoginMode = true;
            }
            else
            {
                // Immediate login success (Auto confirm enabled)
                Navigation.NavigateTo("");
            }
        }
        else
        {
            _errorMessage = CleanErrorMessage(error);
        }
    }

    private async Task DoGoogleLogin()
    {
        _isLoading = true;
        var (success, error) = await AuthService.LoginAsync();
        if (!success)
        {
            _errorMessage = CleanErrorMessage(error);
            _isLoading = false;
        }
    }

    private async Task HandleEnterKey(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (_isLoginMode) await DoEmailLogin();
            else await DoEmailRegister();
        }
    }

    // Helper to make Supabase JSON errors readable
    private string CleanErrorMessage(string? error)
    {
        if (string.IsNullOrEmpty(error)) return "En ukjent feil oppstod.";

        // Try to parse JSON if it looks like JSON
        if (error.Trim().StartsWith("{"))
        {
            try
            {
                using var doc = JsonDocument.Parse(error);
                var root = doc.RootElement;

                // Look for "error_code" or "msg"
                if (root.TryGetProperty("error_code", out var codeElement))
                {
                    var code = codeElement.GetString();
                    if (code == "email_not_confirmed") return "E-posten er ikke bekreftet. Sjekk innboksen din.";
                    if (code == "invalid_credentials") return "Feil e-post eller passord.";
                }

                if (root.TryGetProperty("msg", out var msgElement))
                {
                    return msgElement.GetString() ?? error;
                }
            }
            catch
            {
                // If parsing fails, just return original or a fallback
            }
        }

        // Common text fallbacks
        if (error.Contains("Invalid login credentials")) return "Feil e-post eller passord.";
        if (error.Contains("User already registered")) return "Denne e-posten er allerede i bruk.";

        return error;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Login.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\NotFound.razor
================================================================================
@page "/not-found"
@using StorhaugenWebsite.Shared
@layout MainLayout

<h3>Not Found</h3>
<p>Sorry, the content you are looking for does not exist.</p>


================================================================================
FILE END: \StorhaugenWebsite\Pages\NotFound.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Settings.razor
================================================================================
@page "/settings"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Shared.DTOs
@inject IAuthService AuthService
@inject IDeviceStateService DeviceState
@inject ICollectionStateService CollectionState
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject IThemeService ThemeService
@attribute [Authorize]


<div class="d-flex align-center gap-3 mb-6">
    <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Innstillinger</h1>
</div>

<div class="form-section">
    <p class="form-section-title">Konto</p>

    <div class="setting-row">
        <div class="d-flex align-center gap-3">
            <MudAvatar Size="Size.Medium" Style="@($"background: {GetMemberColor(AuthService.CurrentUserName ?? "")}")">
                @(string.IsNullOrEmpty(AuthService.CurrentUserName) ? '?' : AuthService.CurrentUserName[0])
            </MudAvatar>
            <div>
                <MudText Typo="Typo.body1" Style="font-weight: 500;">@AuthService.CurrentUserName</MudText>
                <MudText Typo="Typo.caption" Color="Color.Secondary">@AuthService.CurrentUserEmail</MudText>
            </div>
        </div>
    </div>

    <div class="mt-4">
        <MudTextField @bind-Value="_editDisplayName"
                      Label="Brukernavn"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Save"
                      OnAdornmentClick="UpdateDisplayName"
                      HelperText="Trykk p lagre-ikonet for  oppdatere navnet ditt" />
    </div>

    @if (!string.IsNullOrEmpty(_userProfile?.UniqueShareId))
    {
        <div class="setting-row" style="padding: 12px 0;">
            <div class="d-flex align-center justify-space-between" style="width: 100%;">
                <div>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Din personlige ID</MudText>
                    <MudText Typo="Typo.h6" Style="font-family: monospace; letter-spacing: 2px; font-weight: 600;">
                        @_userProfile.UniqueShareId
                    </MudText>
                </div>
                <MudIconButton Icon="@Icons.Material.Rounded.ContentCopy"
                               Size="Size.Small"
                               Color="Color.Primary"
                               OnClick="CopyShareId"
                               Title="Kopier ID" />
            </div>
        </div>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Style="margin-top: -8px;">
            Brukes for  bli lagt til i andres samlinger
        </MudText>
    }
</div>

<div class="form-section">
    <p class="form-section-title">Utseende</p>
    <MudSelect T="string"
               Label="Fargetema"
               Value="@_currentTheme"
               ValueChanged="OnThemeChanged"
               Variant="Variant.Outlined"
               Class="theme-select"
               AnchorOrigin="Origin.BottomLeft"
               Style="margin-bottom: 16px;">
        @foreach (var themeName in ThemeService.GetAvailableThemes())
        {
            var colors = ThemeService.GetThemeColors(themeName);
            <MudSelectItem Value="@themeName">
                <div class="theme-preview-container">
                    <div class="mini-website" style="background: @colors.Background; border-color: @colors.Divider;">
                        <div class="mini-appbar" style="background: @colors.AppbarBackground;"></div>
                        <div class="mini-sidebar" style="background: @colors.BackgroundGrey;"></div>
                        <div class="mini-content" style="background: @colors.Surface;">
                            <div class="mini-primary" style="background: @colors.Primary;"></div>
                            <div class="mini-text" style="background: @colors.TextPrimary;"></div>
                            <div class="mini-text-sm" style="background: @colors.TextSecondary;"></div>
                        </div>
                    </div>
                    <span class="theme-name">@GetThemeDisplayName(themeName)</span>
                </div>
            </MudSelectItem>
        }
    </MudSelect>
</div>

@if (CollectionState.UserCollections.Any())
{
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-2">
            <p class="form-section-title" style="margin-bottom: 0;">Dine Samlinger</p>
            <MudButton Variant="Variant.Text"
                       Color="Color.Primary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Rounded.Settings"
                       Href="collections">
                Administrer
            </MudButton>
        </div>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-3">
            Du er med i @CollectionState.UserCollections.Count samling(er). 
        </MudText>
       
    </div>
}

<div class="form-section mt-4">
    <div class="d-flex justify-center flex-column align-center gap-1">
        <MudText Typo="Typo.body2" Style="font-weight: 500;">Storhaugen Eats</MudText>
        <MudText Typo="Typo.caption" Color="Color.Secondary">Versjon 2.0.1</MudText>
    </div>
</div>

<div class="form-section">
    <MudButton Variant="Variant.Outlined"
               Color="Color.Error"
               FullWidth="true"
               StartIcon="@Icons.Material.Rounded.Logout"
               OnClick="Logout"
               Style="border-radius: 12px;">
        Logg ut
    </MudButton>
</div>


<style>
    .setting-row {
        display: flex;
        align-items: center;
        padding: 12px 0;
        gap: 16px;
    }

    .theme-select .mud-input-slot {
        min-height: 70px !important;
        padding: 8px 14px !important;
    }

    .theme-preview-container {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
    }

    .theme-name {
        font-weight: 500;
    }

    .mini-website {
        width: 100px;
        height: 56px;
        border-radius: 6px;
        border: 1px solid;
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
        flex-shrink: 0;
    }

    .mini-appbar {
        width: 100%;
        height: 10px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .mini-sidebar {
        width: 16px;
        height: calc(100% - 10px);
    }

    .mini-content {
        flex: 1;
        margin: 4px;
        border-radius: 3px;
        padding: 4px;
        display: flex;
        flex-direction: column;
        gap: 3px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    .mini-primary {
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }

    .mini-text {
        width: 60%;
        height: 4px;
        border-radius: 2px;
    }

    .mini-text-sm {
        width: 40%;
        height: 3px;
        border-radius: 2px;
    }
</style>

@code {
    private UserDto? _userProfile;
    private string? _editDisplayName;
    private string _currentTheme = "Light";
    private string _viewMode = "card";

    protected override async Task OnInitializedAsync()
    {
        await CollectionState.InitializeAsync();

        try
        {
            _userProfile = await ApiClient.GetMyProfileAsync();
            if (_userProfile != null)
            {
                _editDisplayName = _userProfile.DisplayName;
                AuthService.UpdateCachedDisplayName(_userProfile.DisplayName);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading user profile: {ex.Message}");
        }

        _currentTheme = ThemeService.GetCurrentThemeName();
        _viewMode = DeviceState.Settings.ViewMode;
    }

    private async Task UpdateDisplayName()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(_editDisplayName)) _editDisplayName = null;

            var updatedProfile = await ApiClient.UpdateMyProfileAsync(new UpdateUserDto
            {
                DisplayName = _editDisplayName
            });

            _userProfile = updatedProfile;
            AuthService.UpdateCachedDisplayName(updatedProfile.DisplayName);
            Snackbar.Add("Brukernavn oppdatert", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Klarte ikke  oppdatere navn", Severity.Error);
        }
    }

    private async Task CopyShareId()
    {
        if (string.IsNullOrEmpty(_userProfile?.UniqueShareId)) return;
        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", _userProfile.UniqueShareId);
            Snackbar.Add("ID kopiert!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Feil ved kopiering", Severity.Error);
        }
    }

    private void ToggleCollectionFilter(Guid collectionId)
    {
        CollectionState.ToggleCollectionFilter(collectionId);
        StateHasChanged();
        Snackbar.Add("Samlingsfilter oppdatert", Severity.Info);
    }

    private async Task OnThemeChanged(string themeName)
    {
        _currentTheme = themeName;
        await ThemeService.SetThemeAsync(themeName);
    }



    private string GetThemeDisplayName(string themeName)
    {
        return themeName switch
        {
            "System" => "System Default",
            "Light" => "Light (Amber)",
            "Dark" => "Dark (Rustic)",   // I renamed this slightly to distinguish it
            "Black" => "Midnight Black",
            "Material" => "Material Red",
            "Forest" => "Night Forest",

            // --- NEW THEMES ---
            "Cafe" => "Dark Caf",
            "Walnut" => "Dark Walnut",
            "Clay" => "Dark Clay",
            "Moss" => "Dark Moss",
            "Ink" => "Dark Ink",



            _ => themeName
        };
    }

    private async Task Logout()
    {
        await AuthService.LogoutAsync();
        Navigation.NavigateTo("login");
    }

    private string GetMemberColor(string name)
    {
        var hash = name.GetHashCode();
        var hue = Math.Abs(hash % 360);
        return $"hsl({hue}, 45%, 45%)";
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Settings.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\SharedCollectionView.razor
================================================================================
@page "/collections/shared/{ShareCode}"
@using Microsoft.AspNetCore.Authorization
@using System.Web
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="GoBack">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_collection == null)
{
    <div class="empty-state pa-8 text-center">
        <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" Color="Color.Default" />
        <MudText Typo="Typo.h6" Class="mt-3">Fant ikke samlingen</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Samlingen finnes ikke, eller du har ikke tilgang til den.
        </MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="friends">
            Tilbake til venner
        </MudButton>
    </div>
}
else
{
    <div class="collection-header mb-4">
        <div class="d-flex align-center gap-3 mb-2">
            <div class="collection-icon-large">
                <MudIcon Icon="@GetVisibilityIcon(_collection.Visibility)" Size="Size.Large" />
            </div>

            <div class="flex-grow-1">
                <h1 class="page-title" style="margin: 0;">@_collection.Name</h1>

                @if (!string.IsNullOrEmpty(_collection.Description))
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">@_collection.Description</MudText>
                }

                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-1">
                    <MudIcon Icon="@Icons.Material.Rounded.Person" Size="Size.Small" Style="font-size: 14px; vertical-align: middle;" />
                    Delt av @_collection.OwnerDisplayName
                </MudText>
            </div>
        </div>

        <div class="d-flex flex-wrap gap-2 mt-3">
            <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.Restaurant">
                @_collection.RecipeCount oppskrifter
            </MudChip>
            <MudChip T="string" Size="Size.Small" Color="@GetVisibilityColor(_collection.Visibility)" Icon="@GetVisibilityIcon(_collection.Visibility)">
                @GetVisibilityText(_collection.Visibility)
            </MudChip>
        </div>
    </div>

    <CollectionRecipesList CollectionId="_collection.Id" Title="Oppskrifter" PageSize="30" />
}

<style>
    .collection-header {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid var(--mud-palette-lines-default);
    }

    .collection-icon-large {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        background: var(--mud-palette-info);
        color: var(--mud-palette-info-text);
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>

@code {
    [Parameter] public string ShareCode { get; set; } = "";

    private CollectionDto? _collection;
    private bool _isLoading = true;
    private string _returnUrl = "friends";

    protected override async Task OnInitializedAsync()
    {
        var uri = new Uri(Navigation.Uri);
        var query = HttpUtility.ParseQueryString(uri.Query);

        _returnUrl = query["returnUrl"] ?? "friends";

        await LoadCollection();
    }

    private async Task LoadCollection()
    {
        _isLoading = true;
        try
        {
            _collection = await ApiClient.GetCollectionByShareCodeAsync(ShareCode);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading collection: {ex.Message}");
            Snackbar.Add("Kunne ikke laste samlingen", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void GoBack() => Navigation.NavigateTo(_returnUrl);

    private string GetVisibilityIcon(string visibility) => visibility switch
    {
        "public" => Icons.Material.Rounded.Public,
        "friends" => Icons.Material.Rounded.People,
        _ => Icons.Material.Rounded.Lock
    };

    private string GetVisibilityText(string visibility) => visibility switch
    {
        "public" => "Offentlig",
        "friends" => "Venner",
        _ => "Privat"
    };

    private Color GetVisibilityColor(string visibility) => visibility switch
    {
        "public" => Color.Success,
        "friends" => Color.Info,
        _ => Color.Default
    };
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\SharedCollectionView.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class ActivityFeedService : IActivityFeedService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<ActivityFeedItemDto> CachedFeedItems { get; private set; } = new();
        public ActivitySummaryDto? CachedSummary { get; private set; }

        public ActivityFeedService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthentication()
        {
            if (!_authService.IsAuthenticated)
            {
                throw new UnauthorizedAccessException("You must be logged in to access the activity feed.");
            }
        }

        public async Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery? query = null)
        {
            ValidateAuthentication();

            query ??= new ActivityFeedQuery();
            var result = await _apiClient.GetFeedAsync(query);

            // Cache first page of results
            if (query.Page == 1)
            {
                CachedFeedItems = result.Items;
            }

            return result;
        }

        public async Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20)
        {
            ValidateAuthentication();
            return await _apiClient.GetMyActivityAsync(page, pageSize);
        }

        public async Task<ActivitySummaryDto> GetActivitySummaryAsync()
        {
            ValidateAuthentication();

            var summary = await _apiClient.GetActivitySummaryAsync();
            CachedSummary = summary;
            return summary;
        }

        public void InvalidateCache()
        {
            CachedFeedItems = new List<ActivityFeedItemDto>();
            CachedSummary = null;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IActivityFeedService
    {
        // Feed queries
        Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery? query = null);
        Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20);
        Task<ActivitySummaryDto> GetActivitySummaryAsync();

        // Cache
        List<ActivityFeedItemDto> CachedFeedItems { get; }
        ActivitySummaryDto? CachedSummary { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\IAuthService.cs
================================================================================
namespace StorhaugenWebsite.Services
{
    public interface IAuthService
    {
        event Action? OnAuthStateChanged;
        bool IsAuthenticated { get; }
        bool IsAuthorized { get; }
        string? CurrentUserEmail { get; }
        string? CurrentUserName { get; }

        Task<(bool success, string? errorMessage)> LoginAsync(); // Keep for Google
        // --- ADD THESE ---
        Task<(bool success, string? errorMessage)> SignInWithEmailAsync(string email, string password);
        Task<(bool success, string? errorMessage)> SignUpWithEmailAsync(string email, string password, string displayName);
        // -----------------
        Task LogoutAsync();
        Task InitializeAsync();
        Task<string?> GetAccessTokenAsync();
        void UpdateCachedDisplayName(string? displayName);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\IAuthService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
================================================================================
using Microsoft.AspNetCore.Components;
using Microsoft.JSInterop;
using Newtonsoft.Json;
using Supabase;
using Supabase.Gotrue;
using System.IdentityModel.Tokens.Jwt;
using static Supabase.Gotrue.Constants;
using Client = Supabase.Client;

namespace StorhaugenWebsite.Services;

public class SupabaseAuthService : IAuthService, IAsyncDisposable
{
    private readonly Client _supabaseClient;
    private readonly IJSRuntime _jsRuntime;
    private readonly NavigationManager _navigationManager;
    private Session? _session;
    private const string AuthCacheKey = "supa_auth_session";

    public event Action? OnAuthStateChanged;

    public bool IsAuthenticated => _session?.User != null;
    public bool IsAuthorized => IsAuthenticated; // Any authenticated user is authorized

    private string? _cachedDisplayName; 
    public string? CurrentUserEmail => _session?.User?.Email;
    public string? CurrentUserName => !string.IsNullOrEmpty(_cachedDisplayName)
        ? _cachedDisplayName
        : GetUserNameFromEmail(CurrentUserEmail);

    // Inject NavigationManager here
    public SupabaseAuthService(Client supabaseClient, IJSRuntime jsRuntime, NavigationManager navigationManager)
    {
        _supabaseClient = supabaseClient;
        _jsRuntime = jsRuntime;
        _navigationManager = navigationManager;

        _supabaseClient.Auth.AddStateChangedListener(OnAuthStateChange);
    }

    private void OnAuthStateChange(object? sender, Constants.AuthState state)
    {
        _session = _supabaseClient.Auth.CurrentSession;

        // Prevent refresh storms (TokenRefreshed / SetSession should not cause the whole app to refetch)
        if (state is Constants.AuthState.SignedIn or Constants.AuthState.SignedOut)
            OnAuthStateChanged?.Invoke();
    }


    public void UpdateCachedDisplayName(string? displayName)
    {
        _cachedDisplayName = displayName;
        OnAuthStateChanged?.Invoke();
    }

    public async Task InitializeAsync()
    {
        try
        {
            // 1. Check if we are coming back from a login redirect (URL contains access_token)
            var uri = _navigationManager.Uri;
            if (uri.Contains("access_token") && uri.Contains("type=recovery") == false)
            {
                // Parse the session from the URL
                var session = await _supabaseClient.Auth.GetSessionFromUrl(new Uri(uri));

                if (session != null)
                {
                    _session = session;
                    OnAuthStateChanged?.Invoke();

                    // Optional: Clean the URL so the user doesn't see the ugly token
                    // _navigationManager.NavigateTo("/", replace: true); 
                    return;
                }
            }

            // 2. If no token in URL, check LocalStorage for existing session
            var storedSession = await _supabaseClient.Auth.RetrieveSessionAsync();
            if (storedSession != null)
            {
                _session = storedSession;
                OnAuthStateChanged?.Invoke();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Auth initialization error: {ex.Message}");
        }
    }

    public async Task<(bool success, string? errorMessage)> LoginAsync()
    {
        try
        {
            var redirectUrl = await GetRedirectUrlAsync();

            var options = new SignInOptions
            {
                RedirectTo = redirectUrl
            };

            var result = await _supabaseClient.Auth.SignIn(Provider.Google, options);

            if (result != null && result.Uri != null)
            {
                // 1. We are leaving the app. Using NavigationManager with forceLoad: true 
                // is cleaner than JS Interop for external links.
                _navigationManager.NavigateTo(result.Uri.ToString(), forceLoad: true);

                // 2. We return basic success here, but the code below 
                // technically won't matter because the browser is navigating away.
                return (true, null);
            }

            return (false, "Login was cancelled or failed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Login error: {ex.Message}");
            return (false, $"Login error: {ex.Message}");
        }
    }

    public async Task<(bool success, string? errorMessage)> SignInWithEmailAsync(string email, string password)
    {
        try
        {
            var session = await _supabaseClient.Auth.SignIn(email, password);

            if (session != null && session.User != null)
            {
                _session = session;
                OnAuthStateChanged?.Invoke();
                return (true, null);
            }
            return (false, "Invalid credentials");
        }
        catch (Exception ex)
        {
            // Supabase throws specific exceptions for invalid login
            return (false, ex.Message);
        }
    }

    public async Task<(bool success, string? errorMessage)> SignUpWithEmailAsync(string email, string password, string displayName)
    {
        try
        {
            var options = new SignUpOptions
            {
                Data = new Dictionary<string, object>
                {
                    { "name", displayName }, // Pass display name to Supabase metadata
                    { "full_name", displayName } // Some providers look for full_name
                }
            };

            var session = await _supabaseClient.Auth.SignUp(email, password, options);

            // If Supabase is set to "Auto Confirm Emails", you get a session immediately.
            // If "Confirm Email" is on, session might be null, but User is not.
            if (session?.User != null)
            {
                if (session.AccessToken != null)
                {
                    _session = session;
                    OnAuthStateChanged?.Invoke();
                    return (true, null);
                }
                else
                {
                    return (true, "Registration successful! Please check your email to confirm your account.");
                }
            }

            return (false, "Registration failed.");
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }

    public async Task LogoutAsync()
    {
        try
        {
            await _supabaseClient.Auth.SignOut();
            _session = null;
            OnAuthStateChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Logout error: {ex.Message}");
        }
    }

    private readonly SemaphoreSlim _refreshLock = new(1, 1);

    public async Task<string?> GetAccessTokenAsync()
    {
        _session ??= _supabaseClient.Auth.CurrentSession
                 ?? await _supabaseClient.Auth.RetrieveSessionAsync();

        if (_session?.AccessToken is null)
            return null;

        // Refresh earlier than 60s if your backend uses strict lifetime validation (yours does)
        if (!IsExpiredOrNearExpiry(_session.AccessToken, skewSeconds: 180))
            return _session.AccessToken;

        await _refreshLock.WaitAsync();
        try
        {
            // Re-check after waiting: another caller may have refreshed already
            _session = _supabaseClient.Auth.CurrentSession ?? _session;
            if (_session?.AccessToken is null)
                return null;

            if (!IsExpiredOrNearExpiry(_session.AccessToken, skewSeconds: 180))
                return _session.AccessToken;

            //  Do an actual refresh (method name may be RefreshSession / RefreshSessionAsync depending on your SDK)
            var refreshed = await _supabaseClient.Auth.RefreshSession();
            if (refreshed != null)
                _session = refreshed;
            else
                _session = _supabaseClient.Auth.CurrentSession;

            return _session?.AccessToken;
        }
        finally
        {
            _refreshLock.Release();
        }
    }


    private static bool IsExpiredOrNearExpiry(string jwt, int skewSeconds)
    {
        try
        {
            var handler = new JwtSecurityTokenHandler();
            var token = handler.ReadJwtToken(jwt);
            return token.ValidTo <= DateTime.UtcNow.AddSeconds(skewSeconds);
        }
        catch
        {
            // If we can't parse it, treat it as invalid and force renewal path.
            return true;
        }
    }

    private Task<string> GetRedirectUrlAsync()
    {
        // Ensure we redirect specifically to the login page so the 
        // OnInitializedAsync method in Login.razor actually runs to parse the token.
        var baseUri = _navigationManager.BaseUri;

        // Handle trailing slash just in case
        var redirectUrl = baseUri.EndsWith("/")
            ? $"{baseUri}login"
            : $"{baseUri}/login";

        return Task.FromResult(redirectUrl);
    }

    public async ValueTask DisposeAsync()
    {
        _supabaseClient.Auth.RemoveStateChangedListener(OnAuthStateChange);
        await Task.CompletedTask;
    }

    private static string? GetUserNameFromEmail(string? email)
    {
        if (string.IsNullOrEmpty(email))
            return null;

        // Extract name from email (part before @)
        var atIndex = email.IndexOf('@');
        if (atIndex <= 0)
            return email;

        var namePart = email.Substring(0, atIndex);

        // Capitalize first letter
        if (namePart.Length > 0)
        {
            return char.ToUpper(namePart[0]) + namePart.Substring(1).ToLower();
        }

        return namePart;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
================================================================================
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.JSInterop;
using Newtonsoft.Json;
using Supabase.Gotrue;
using System.Security.Claims;
using static Supabase.Gotrue.Constants;

namespace StorhaugenWebsite.Services;

public class SupabaseAuthStateProvider : AuthenticationStateProvider
{
    private readonly Supabase.Client _client;
    private readonly IJSRuntime _jsRuntime;
    private const string AuthCacheKey = "supa_auth_session";

    public SupabaseAuthStateProvider(Supabase.Client client, IJSRuntime jsRuntime)
    {
        _client = client;
        _jsRuntime = jsRuntime;
        _client.Auth.AddStateChangedListener(OnAuthStateChanged);
    }

    public override async Task<AuthenticationState> GetAuthenticationStateAsync()
    {
        try
        {
            // 1. Check if Supabase already has the session in memory
            var session = _client.Auth.CurrentSession;

            if (session != null)
            {
                // Ensure persistence if session exists in memory
                var json = JsonConvert.SerializeObject(session);
                await _jsRuntime.InvokeVoidAsync("localStorage.setItem", AuthCacheKey, json);
            }
            else
            {
                // 2. Try to load from LocalStorage
                var cachedJson = await _jsRuntime.InvokeAsync<string>("localStorage.getItem", AuthCacheKey);

                if (!string.IsNullOrEmpty(cachedJson))
                {
                    session = JsonConvert.DeserializeObject<Session>(cachedJson);
                    if (session?.AccessToken != null)
                    {
                        await _client.Auth.SetSession(session.AccessToken, session.RefreshToken);
                        session = _client.Auth.CurrentSession;
                    }
                }
            }

            // 3. Create Claims
            if (session?.User != null)
            {
                // --- FIX STARTS HERE ---
                // Try to get display name from metadata ("name" or "full_name"), fallback to email
                string? displayName = session.User.Email;

                if (session.User.UserMetadata != null)
                {
                    if (session.User.UserMetadata.TryGetValue("name", out var nameObj) && nameObj != null)
                    {
                        displayName = nameObj.ToString();
                    }
                    else if (session.User.UserMetadata.TryGetValue("full_name", out var fullNameObj) && fullNameObj != null)
                    {
                        displayName = fullNameObj.ToString();
                    }
                }

                var claims = new List<Claim>
                {
                    // Use the resolved displayName here instead of just email
                    new Claim(ClaimTypes.Name, displayName ?? ""),
                    new Claim(ClaimTypes.Email, session.User.Email ?? ""),
                    new Claim(ClaimTypes.NameIdentifier, session.User.Id ?? "")
                };
                // --- FIX ENDS HERE ---

                var identity = new ClaimsIdentity(claims, "Supabase");
                return new AuthenticationState(new ClaimsPrincipal(identity));
            }
        }
        catch
        {
            await _jsRuntime.InvokeVoidAsync("localStorage.removeItem", AuthCacheKey);
        }

        return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity()));
    }

    // ... rest of the file (OnAuthStateChanged, Dispose) remains the same
    private async void OnAuthStateChanged(object sender, AuthState state)
    {
        var session = _client.Auth.CurrentSession;

        if (state == AuthState.SignedIn || state == AuthState.TokenRefreshed)
        {
            if (session != null)
            {
                var json = JsonConvert.SerializeObject(session);
                await _jsRuntime.InvokeVoidAsync("localStorage.setItem", AuthCacheKey, json);
            }
        }
        else if (state == AuthState.SignedOut)
        {
            await _jsRuntime.InvokeVoidAsync("localStorage.removeItem", AuthCacheKey);
        }

        NotifyAuthenticationStateChanged(GetAuthenticationStateAsync());
    }

    public void Dispose()
    {
        _client.Auth.RemoveStateChangedListener(OnAuthStateChanged);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Collection\CollectionStateService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class CollectionStateService : ICollectionStateService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;
        private Guid? _currentUserId;

        public List<CollectionDto> UserCollections { get; private set; } = new();
        public CollectionDto? ActiveCollection { get; private set; }
        public List<CollectionMemberDto> ActiveCollectionMembers { get; private set; } = new();
        public List<Guid> ActiveCollectionFilters { get; private set; } = new();
        public bool HasCollections => UserCollections.Any();

        public event Action? OnStateChanged;
        public event Action? OnActiveFiltersChanged;

        public CollectionStateService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;

            // Subscribe to auth state changes
            _authService.OnAuthStateChanged += HandleAuthStateChanged;
        }

        private async void HandleAuthStateChanged()
        {
            if (_authService.IsAuthenticated)
            {
                await RefreshCollectionsAsync();
            }
            else
            {
                ClearState();
            }
        }

        public async Task InitializeAsync()
        {
            if (_authService.IsAuthenticated)
            {
                await RefreshCollectionsAsync();
            }
        }

        public async Task RefreshCollectionsAsync()
        {
            try
            {
                // Get current user ID
                var profile = await _apiClient.GetMyProfileAsync();
                _currentUserId = profile?.Id;

                // Load collections
                UserCollections = await _apiClient.GetMyCollectionsAsync();

                // If we had an active collection, try to restore it
                if (ActiveCollection != null)
                {
                    var restored = UserCollections.FirstOrDefault(c => c.Id == ActiveCollection.Id);
                    if (restored != null)
                    {
                        ActiveCollection = restored;
                        await LoadActiveCollectionMembersAsync();
                    }
                    else
                    {
                        ActiveCollection = null;
                        ActiveCollectionMembers = new();
                    }
                }

                OnStateChanged?.Invoke();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to refresh collections: {ex.Message}");
                UserCollections = new();
            }
        }

        public async Task SetActiveCollectionAsync(Guid? collectionId)
        {
            if (collectionId == null)
            {
                ActiveCollection = null;
                ActiveCollectionMembers = new();
            }
            else
            {
                ActiveCollection = UserCollections.FirstOrDefault(c => c.Id == collectionId);
                if (ActiveCollection != null)
                {
                    await LoadActiveCollectionMembersAsync();
                }
            }

            OnStateChanged?.Invoke();
        }

        private async Task LoadActiveCollectionMembersAsync()
        {
            if (ActiveCollection == null)
            {
                ActiveCollectionMembers = new();
                return;
            }

            try
            {
                ActiveCollectionMembers = await _apiClient.GetCollectionMembersAsync(ActiveCollection.Id);
            }
            catch
            {
                ActiveCollectionMembers = new();
            }
        }

        public async Task<CollectionDto> CreateCollectionAsync(string name)
        {
            var dto = new CreateCollectionDto { Name = name };
            var created = await _apiClient.CreateCollectionAsync(dto);

            // Add to local list
            UserCollections.Add(created);
            OnStateChanged?.Invoke();

            return created;
        }

        public async Task AddRecipeToCollectionAsync(Guid collectionId, Guid recipeId)
        {
            var dto = new AddRecipeToCollectionDto { UserRecipeId = recipeId };
            await _apiClient.AddRecipeToCollectionAsync(collectionId, dto);
        }

        public async Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId)
        {
            await _apiClient.RemoveRecipeFromCollectionAsync(collectionId, recipeId);
        }

        public async Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId)
        {
            return await _apiClient.GetCollectionMembersAsync(collectionId);
        }

        public bool IsOwnerOf(Guid collectionId)
        {
            if (_currentUserId == null) return false;

            var collection = UserCollections.FirstOrDefault(c => c.Id == collectionId);
            return collection?.OwnerId == _currentUserId;
        }

        public bool IsCollectionActive(Guid collectionId)
        {
            return ActiveCollectionFilters.Contains(collectionId);
        }

        public void ToggleCollectionFilter(Guid collectionId)
        {
            if (ActiveCollectionFilters.Contains(collectionId))
            {
                ActiveCollectionFilters.Remove(collectionId);
            }
            else
            {
                ActiveCollectionFilters.Add(collectionId);
            }
            OnActiveFiltersChanged?.Invoke();
        }

        public void SetCollectionFilter(Guid collectionId, bool active)
        {
            var isCurrentlyActive = ActiveCollectionFilters.Contains(collectionId);
            if (active && !isCurrentlyActive)
            {
                ActiveCollectionFilters.Add(collectionId);
                OnActiveFiltersChanged?.Invoke();
            }
            else if (!active && isCurrentlyActive)
            {
                ActiveCollectionFilters.Remove(collectionId);
                OnActiveFiltersChanged?.Invoke();
            }
        }

        public void ClearState()
        {
            UserCollections = new();
            ActiveCollection = null;
            ActiveCollectionMembers = new();
            ActiveCollectionFilters = new();
            _currentUserId = null;
            OnStateChanged?.Invoke();
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Collection\CollectionStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Collection\ICollectionStateService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface ICollectionStateService
    {
        /// <summary>
        /// All collections the current user owns or is a member of.
        /// </summary>
        List<CollectionDto> UserCollections { get; }

        /// <summary>
        /// Currently selected collection for filtering/adding recipes.
        /// </summary>
        CollectionDto? ActiveCollection { get; }

        /// <summary>
        /// Members of the currently active collection.
        /// </summary>
        List<CollectionMemberDto> ActiveCollectionMembers { get; }

        /// <summary>
        /// Collections currently active in filter (for CookBook multi-select).
        /// </summary>
        List<Guid> ActiveCollectionFilters { get; }

        /// <summary>
        /// Whether user has any collections.
        /// </summary>
        bool HasCollections { get; }

        /// <summary>
        /// Event raised when collections or active collection changes.
        /// </summary>
        event Action? OnStateChanged;

        /// <summary>
        /// Event raised when active collection filters change.
        /// </summary>
        event Action? OnActiveFiltersChanged;

        /// <summary>
        /// Initialize the service and load user's collections.
        /// </summary>
        Task InitializeAsync();

        /// <summary>
        /// Refresh collections from the API.
        /// </summary>
        Task RefreshCollectionsAsync();

        /// <summary>
        /// Set the active collection for filtering/operations.
        /// </summary>
        Task SetActiveCollectionAsync(Guid? collectionId);

        /// <summary>
        /// Create a new collection and add it to the list.
        /// </summary>
        Task<CollectionDto> CreateCollectionAsync(string name);

        /// <summary>
        /// Add a recipe to a collection.
        /// </summary>
        Task AddRecipeToCollectionAsync(Guid collectionId, Guid recipeId);

        /// <summary>
        /// Remove a recipe from a collection.
        /// </summary>
        Task RemoveRecipeFromCollectionAsync(Guid collectionId, Guid recipeId);

        /// <summary>
        /// Get members of a specific collection.
        /// </summary>
        Task<List<CollectionMemberDto>> GetCollectionMembersAsync(Guid collectionId);

        /// <summary>
        /// Check if the current user is the owner of a collection.
        /// </summary>
        bool IsOwnerOf(Guid collectionId);

        /// <summary>
        /// Check if a collection is active in the filter.
        /// </summary>
        bool IsCollectionActive(Guid collectionId);

        /// <summary>
        /// Toggle a collection in the active filter list.
        /// </summary>
        void ToggleCollectionFilter(Guid collectionId);

        /// <summary>
        /// Set a specific collection filter to active/inactive.
        /// </summary>
        void SetCollectionFilter(Guid collectionId, bool active);

        /// <summary>
        /// Clear state (e.g., on logout).
        /// </summary>
        void ClearState();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Collection\ICollectionStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
================================================================================
using Microsoft.JSInterop;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public class DeviceStateService : IDeviceStateService
    {
        private readonly IJSRuntime _jsRuntime;
        private const string STORAGE_KEY = "storhaugen_settings";

        public DeviceSettings Settings { get; private set; } = new();
        public event Action? OnSettingsChanged;

        public DeviceStateService(IJSRuntime jsRuntime)
        {
            _jsRuntime = jsRuntime;
        }

        public async Task InitializeAsync()
        {
            try
            {
                var json = await _jsRuntime.InvokeAsync<string?>("deviceState.get", STORAGE_KEY);
                if (!string.IsNullOrEmpty(json))
                {
                    var settings = System.Text.Json.JsonSerializer.Deserialize<DeviceSettings>(json);
                    if (settings != null)
                    {
                        Settings = settings;
                    }
                }
            }
            catch
            {
                // Use defaults if localStorage fails
            }
        }

        public async Task SetSortAsync(string sortBy, bool descending)
        {
            Settings.SortBy = sortBy;
            Settings.SortDescending = descending;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task SetThemeAsync(string theme)
        {
            Settings.Theme = theme;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task SetViewModeAsync(string viewMode)
        {
            Settings.ViewMode = viewMode;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task<string> GetSystemThemePreferenceAsync()
        {
            try
            {
                return await _jsRuntime.InvokeAsync<string>("deviceState.getPreferredTheme");
            }
            catch
            {
                return "dark";
            }
        }

        public async Task SetCookbookFiltersAsync(List<Guid> collectionIds, bool personalActive)
        {
            Settings.CookbookCollectionFilters = collectionIds;
            Settings.CookbookPersonalFilterActive = personalActive;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        private async Task SaveSettingsAsync()
        {
            try
            {
                var json = System.Text.Json.JsonSerializer.Serialize(Settings);
                await _jsRuntime.InvokeVoidAsync("deviceState.set", STORAGE_KEY, json);
            }
            catch
            {
                // Silently fail if localStorage is not available
            }
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
================================================================================
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IDeviceStateService
    {
        DeviceSettings Settings { get; }
        event Action? OnSettingsChanged;

        Task InitializeAsync();
        Task SetThemeAsync(string theme);
        Task SetViewModeAsync(string viewMode);
        Task<string> GetSystemThemePreferenceAsync();
        Task SetSortAsync(string sortBy, bool descending);
        Task SetCookbookFiltersAsync(List<Guid> collectionIds, bool personalActive);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Food\FoodService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    /// <summary>
    /// Legacy service for FoodItem compatibility.
    /// Wraps the user-centric recipe APIs.
    /// </summary>
    public class FoodService : IFoodService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;
        public FoodItem? DraftRecipe { get; set; }
        public List<FoodItem> CachedFoods { get; private set; } = new();

        public FoodService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthorization()
        {
            if (!_authService.IsAuthorized)
            {
                throw new UnauthorizedAccessException("You are not authorized to perform this action.");
            }
        }

        public async Task<List<FoodItem>> GetAllFoodsAsync(bool includeArchived = false)
        {
            if (!_authService.IsAuthenticated) throw new UnauthorizedAccessException();

            var query = new GetUserRecipesQuery { IncludeArchived = includeArchived };
            var result = await _apiClient.GetMyUserRecipesAsync(query);
            var mappedRecipes = result.Recipes.Select(MapToFoodItem).ToList();

            // Update the cache if we are fetching the standard active list
            if (!includeArchived)
            {
                CachedFoods = mappedRecipes;
            }

            return mappedRecipes;
        }

        public async Task<FoodItem?> GetFoodByIdAsync(string id)
        {
            if (!Guid.TryParse(id, out var recipeId))
                return null;

            var recipe = await _apiClient.GetUserRecipeAsync(recipeId);
            return recipe != null ? MapToFoodItem(recipe) : null;
        }

        public async Task<string> AddFoodAsync(FoodItem food)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(food.Name))
                throw new ArgumentException("Food name cannot be empty.");

            var dto = new CreateUserRecipeDto
            {
                Name = food.Name,
                Description = food.Description,
                ImageUrls = food.ImageUrls,
                PersonalNotes = food.PersonalNotes,
                Visibility = food.IsPublic ? "public" : "private"
            };

            var created = await _apiClient.CreateUserRecipeAsync(dto);

            // Add the user's rating if provided
            foreach (var rating in food.Ratings.Where(r => r.Value.HasValue))
            {
                await _apiClient.RateUserRecipeAsync(created.Id, rating.Value!.Value);
            }

            return created.Id.ToString();
        }

        public async Task UpdateFoodAsync(FoodItem food)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(food.Id)) throw new ArgumentException("ID required.");
            if (string.IsNullOrWhiteSpace(food.Name)) throw new ArgumentException("Name required.");

            if (!Guid.TryParse(food.Id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            var dto = new UpdateUserRecipeDto
            {
                Name = food.Name,
                Description = food.Description,
                ImageUrls = food.ImageUrls,
                PersonalNotes = food.PersonalNotes
            };

            await _apiClient.UpdateUserRecipeAsync(recipeId, dto);
        }

        public async Task ArchiveFoodAsync(string id, string archivedBy)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.ArchiveUserRecipeAsync(recipeId);
        }

        public async Task RestoreFoodAsync(string id)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.RestoreUserRecipeAsync(recipeId);
        }

        public async Task UpdateRatingAsync(string foodId, string personName, decimal rating)
        {
            ValidateAuthorization();

            if (rating < 0m || rating > 10m) throw new ArgumentException("Invalid rating.");

            if (!Guid.TryParse(foodId, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.RateUserRecipeAsync(recipeId, rating);
        }

        public async Task<string> UploadImageAsync(byte[] imageData, string fileName)
        {
            ValidateAuthorization();

            if (imageData == null || imageData.Length == 0)
                throw new ArgumentException("Image data is required.");

            var result = await _apiClient.UploadImageAsync(imageData, fileName);
            return result.Url;
        }

        public async Task ForkRecipeAsync(string id)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            // Fork is now "detach" - creates a local copy
            await _apiClient.DetachUserRecipeAsync(recipeId);
        }

        public async Task SetPublicStatusAsync(string id, bool isPublic)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            var dto = new UpdateUserRecipeDto
            {
                Visibility = isPublic ? "public" : "private"
            };

            await _apiClient.UpdateUserRecipeAsync(recipeId, dto);
        }

        // Map UserRecipeDto to FoodItem for backward compatibility
        private FoodItem MapToFoodItem(UserRecipeDto recipe)
        {
            return new FoodItem
            {
                Id = recipe.Id.ToString(),
                Name = recipe.Name,
                Description = recipe.Description,
                ImageUrls = recipe.ImageUrls,
                Ratings = recipe.MemberRatings ?? new Dictionary<string, decimal?>(),
                DateAdded = recipe.CreatedAt,
                AddedBy = recipe.UserDisplayName ?? "Unknown",
                IsArchived = recipe.IsArchived,
                ArchivedDate = null,
                ArchivedBy = null,
                GlobalRecipeId = recipe.GlobalRecipeId,
                GlobalRecipeName = recipe.GlobalRecipeName,
                IsForked = false,
                PersonalNotes = recipe.PersonalNotes,
                IsPublic = recipe.Visibility == "public",
                PrepTimeMinutes = recipe.PrepTimeMinutes,
                CookTimeMinutes = recipe.CookTimeMinutes,
                Servings = recipe.Servings,
                Difficulty = recipe.Difficulty,
                Cuisine = recipe.Cuisine,
                Ingredients = recipe.Ingredients
            };
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Food\FoodService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Food\IFoodService.cs
================================================================================
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IFoodService
    {
        Task<string> AddFoodAsync(FoodItem food);
        Task UpdateFoodAsync(FoodItem food);
        Task<List<FoodItem>> GetAllFoodsAsync(bool includeArchived = false);
        Task<FoodItem?> GetFoodByIdAsync(string id);
        Task ArchiveFoodAsync(string id, string archivedBy);
        Task RestoreFoodAsync(string id);
        Task UpdateRatingAsync(string foodId, string personName, decimal rating);
        Task<string> UploadImageAsync(byte[] imageData, string fileName);
        Task ForkRecipeAsync(string id);
        Task SetPublicStatusAsync(string id, bool isPublic);
        List<FoodItem> CachedFoods { get; }
        FoodItem? DraftRecipe { get; set; } 
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Food\IFoodService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Ocr\IOcrService.cs
================================================================================
namespace StorhaugenWebsite.Services // Adjust namespace if your folder structure is different
{
    public interface IOcrService
    {
        Task<string> RecognizeTextAsync(string imageBase64DataUrl);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Ocr\IOcrService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
================================================================================
using Microsoft.JSInterop;

namespace StorhaugenWebsite.Services
{
    // The ": IOcrService" part tells C# that this class fulfills the IOcrService contract
    public class TesseractOcrService : IOcrService
    {
        private readonly IJSRuntime _jsRuntime;

        // We inject the JS Runtime so we can talk to the JavaScript file you added
        public TesseractOcrService(IJSRuntime jsRuntime)
        {
            _jsRuntime = jsRuntime;
        }

        public async Task<string> RecognizeTextAsync(string imageSource)
        {
            // This line calls the 'window.ocrInterop.recognizeTextFromImage' function 
            // inside your wwwroot/js/ocrInterop.js file
            return await _jsRuntime.InvokeAsync<string>("ocrInterop.recognizeTextFromImage", imageSource);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Theme\IThemeService.cs
================================================================================
using MudBlazor;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IThemeService
    {
        bool IsDarkMode { get; }
        event Action? OnThemeChanged;

        Task InitializeAsync();
        MudTheme GetCurrentTheme();
        IEnumerable<string> GetAvailableThemes();
        string GetCurrentThemeName();
        Task SetThemeAsync(string themeName);
        ThemeColors GetThemeColors(string themeName);
        bool IsThemeDark(string themeName);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Theme\IThemeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Theme\ThemeService.cs
================================================================================
using MudBlazor;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public class ThemeService : IThemeService
    {
        private readonly IDeviceStateService _deviceState;
        private Dictionary<string, MudTheme> _themes = new();
        private string? _systemPreference;

        public bool IsDarkMode { get; private set; }
        public event Action? OnThemeChanged;

        public ThemeService(IDeviceStateService deviceState)
        {
            _deviceState = deviceState;
        }

        public async Task InitializeAsync()
        {
            _systemPreference = await _deviceState.GetSystemThemePreferenceAsync();

            _themes["System"] = _systemPreference == "dark" ? GenerateDarkTheme() : GenerateLightTheme();
            _themes["Light"] = GenerateLightTheme();

            // Your existing themes
            _themes["Dark"] = GenerateDarkTheme(); // The original rustic brown
            _themes["Black"] = GenerateBlackTheme();
            _themes["Material"] = GenerateMaterialTheme();
            _themes["Forest"] = GenerateForestTheme();

            // --- NEW THEMES ---
            // --- DARK VARIANTS (modern / sleek, not bleak) ---
            _themes["Cafe"] = GenerateCafeDarkTheme();
            _themes["Walnut"] = GenerateWalnutDarkTheme();
            _themes["Clay"] = GenerateClayDarkTheme();
            _themes["Moss"] = GenerateMossDarkTheme();
            _themes["Ink"] = GenerateInkDarkTheme();



            UpdateDarkModeState();
        }

        public MudTheme GetCurrentTheme()
        {
            var themeName = _deviceState.Settings.Theme;
            if (_themes.TryGetValue(themeName, out var theme))
            {
                return theme;
            }
            return _themes["Light"];
        }

        public IEnumerable<string> GetAvailableThemes() => _themes.Keys;

        public string GetCurrentThemeName() => _deviceState.Settings.Theme;

        public async Task SetThemeAsync(string themeName)
        {
            if (!_themes.ContainsKey(themeName)) return;

            await _deviceState.SetThemeAsync(themeName);
            UpdateDarkModeState();
            OnThemeChanged?.Invoke();
        }

        public ThemeColors GetThemeColors(string themeName)
        {
            if (!_themes.TryGetValue(themeName, out var theme))
            {
                theme = _themes["Light"];
            }

            var isDark = IsThemeDark(themeName);

            Palette palette = isDark ? theme.PaletteDark : theme.PaletteLight;

            return new ThemeColors
            {
                Primary = palette.Primary.ToString(),
                Info = palette.Info.ToString(),
                AppbarBackground = palette.AppbarBackground.ToString(),
                Surface = palette.Surface.ToString(),
                Background = palette.Background.ToString(),
                BackgroundGrey = palette.BackgroundGray.ToString(), // Note: MudBlazor v7 uses 'BackgroundGray'
                Divider = palette.Divider.ToString(),
                TextPrimary = palette.TextPrimary.ToString(),
                TextSecondary = palette.TextSecondary.ToString()
            };
        }

        public bool IsThemeDark(string themeName)
        {
            if (themeName == "System")
            {
                return _systemPreference == "dark";
            }
            return themeName != "Light";
        }

        private void UpdateDarkModeState()
        {
            IsDarkMode = IsThemeDark(_deviceState.Settings.Theme);
        }

        // ========== LIGHT THEME (Warm Amber) ==========
        private MudTheme GenerateLightTheme()
        {
            return new MudTheme
            {
                PaletteLight = new PaletteLight
                {
                    Primary = "#E07A2E",
                    PrimaryDarken = "#C56820",
                    PrimaryLighten = "#F5A65B",
                    Secondary = "#2D5A45",
                    Tertiary = "#4A7C9B",
                    Info = "#4A7C9B",
                    Success = "#2D5A45",
                    Warning = "#D4A017",
                    Error = "#C44536",
                    Background = "#FBF8F4",
                    Surface = "#FFFFFF",
                    AppbarBackground = "#FFFFFF",
                    AppbarText = "#2C2416",
                    DrawerBackground = "#FFFFFF",
                    TextPrimary = "#2C2416",
                    TextSecondary = "#6B5D4D",
                    ActionDefault = "#6B5D4D",
                    Divider = "#E8E2D9",
                    DividerLight = "#F0EBE4",
                    BackgroundGray = "#F5F0E8"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }


        // ========== CAFE (warm, clean brown + amber accent) ==========
        private MudTheme GenerateCafeDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#F0A35E",
                    PrimaryDarken = "#E07A2E",
                    PrimaryLighten = "#FFD2A6",

                    Secondary = "#78BFA0",
                    Tertiary = "#7CAAD0",
                    Info = "#7CAAD0",
                    Success = "#78BFA0",
                    Warning = "#E6C06A",
                    Error = "#E07B6F",

                    Background = "#17120D",
                    Surface = "#2A2118",
                    AppbarBackground = "#241C14",
                    DrawerBackground = "#241C14",
                    AppbarText = "#F5F0E8",

                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#B7AA9A",
                    ActionDefault = "#B7AA9A",
                    Divider = "#3B2F25",
                    DividerLight = "#4A3B2F",
                    BackgroundGray = "#201810"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== WALNUT (deeper + sleeker contrast, still warm) ==========
        private MudTheme GenerateWalnutDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#E48B4A",
                    PrimaryDarken = "#C96E33",
                    PrimaryLighten = "#F4B789",

                    Secondary = "#7DB6A3",
                    Tertiary = "#7FA8C7",
                    Info = "#7FA8C7",
                    Success = "#7DB6A3",
                    Warning = "#D7B66A",
                    Error = "#D8786C",

                    Background = "#120F0D",
                    Surface = "#1F1914",
                    AppbarBackground = "#1B1511",
                    DrawerBackground = "#1B1511",
                    AppbarText = "#F5F0E8",

                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#A89B8A",
                    ActionDefault = "#A89B8A",
                    Divider = "#2F261F",
                    DividerLight = "#3B3028",
                    BackgroundGray = "#18130F"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== CLAY (earthy, modern terracotta, warmer surfaces) ==========
        private MudTheme GenerateClayDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#D98A76",
                    PrimaryDarken = "#BD6A59",
                    PrimaryLighten = "#F0B0A2",

                    Secondary = "#7FB3A0",
                    Tertiary = "#7CAAD0",
                    Info = "#7CAAD0",
                    Success = "#7FB3A0",
                    Warning = "#E0B86C",
                    Error = "#D66B6B",

                    Background = "#17100F",
                    Surface = "#2B1B18",
                    AppbarBackground = "#241513",
                    DrawerBackground = "#241513",
                    AppbarText = "#F5EEE9",

                    TextPrimary = "#F5EEE9",
                    TextSecondary = "#B09A95",
                    ActionDefault = "#B09A95",
                    Divider = "#3B2523",
                    DividerLight = "#4A2F2C",
                    BackgroundGray = "#211412"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== MOSS (sleek brown base with muted green accent) ==========
        private MudTheme GenerateMossDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#79C98E",
                    PrimaryDarken = "#55AE73",
                    PrimaryLighten = "#A7E7B8",

                    Secondary = "#E3A85B",   // warm accent to balance the green
                    Tertiary = "#7CAAD0",
                    Info = "#7CAAD0",
                    Success = "#79C98E",
                    Warning = "#E6C06A",
                    Error = "#D8786C",

                    Background = "#14130F",
                    Surface = "#232016",
                    AppbarBackground = "#1F1C13",
                    DrawerBackground = "#1F1C13",
                    AppbarText = "#F5F0E8",

                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#ABA38F",
                    ActionDefault = "#ABA38F",
                    Divider = "#2F2C1F",
                    DividerLight = "#3C3828",
                    BackgroundGray = "#1B190F"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== INK (cleaner, slightly cooler modern dark while staying cozy) ==========
        private MudTheme GenerateInkDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#5FAAD8",
                    PrimaryDarken = "#3E8FB8",
                    PrimaryLighten = "#92D0EE",

                    Secondary = "#7FB3A0",
                    Tertiary = "#E6B56A",   // warm counter-accent (prevents bleak)
                    Info = "#5FAAD8",
                    Success = "#7FB3A0",
                    Warning = "#E6B56A",
                    Error = "#D8786C",

                    Background = "#131416",
                    Surface = "#1C1E22",
                    AppbarBackground = "#171A1E",
                    DrawerBackground = "#171A1E",
                    AppbarText = "#F5F0E8",

                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#A7AAB0",
                    ActionDefault = "#A7AAB0",
                    Divider = "#2A2D33",
                    DividerLight = "#383C44",
                    BackgroundGray = "#16181C"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }


        // ========== DARK THEME (Warm Dark) ==========
        private MudTheme GenerateDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#F5A65B",
                    PrimaryDarken = "#E07A2E",
                    PrimaryLighten = "#FFCF9E",
                    Secondary = "#5DBE8A",
                    Tertiary = "#6BA3C7",
                    Info = "#6BA3C7",
                    Success = "#5DBE8A",
                    Warning = "#F5C842",
                    Error = "#E86B5B",
                    Background = "#1A1612",
                    Surface = "#2C2416",
                    AppbarBackground = "#2C2416",
                    AppbarText = "#F5F0E8",
                    DrawerBackground = "#2C2416",
                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#A89B8A",
                    ActionDefault = "#A89B8A",
                    Divider = "#3D3428",
                    DividerLight = "#4A3F32",
                    BackgroundGray = "#241F19"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== BLACK THEME ==========
        private MudTheme GenerateBlackTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#5e48d4",
                    PrimaryDarken = "#4a38b0",
                    PrimaryLighten = "#7a66e8",
                    Secondary = "#8b5cf6",
                    Tertiary = "#a78bfa",
                    Info = "#5e48d4",
                    Success = "#22c55e",
                    Warning = "#eab308",
                    Error = "#ef4444",
                    Background = "#000000",
                    Surface = "#161515",
                    AppbarBackground = "#0e0e0e",
                    AppbarText = "#ffffff",
                    DrawerBackground = "#161515",
                    TextPrimary = "#ffffff",
                    TextSecondary = "#a1a1aa",
                    ActionDefault = "#a1a1aa",
                    Divider = "#27272a",
                    DividerLight = "#3f3f46",
                    BackgroundGray = "#201f1f"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== MATERIAL THEME ==========
        private MudTheme GenerateMaterialTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#ff6a6a",
                    PrimaryDarken = "#e05555",
                    PrimaryLighten = "#ff8a8a",
                    Secondary = "#64b5f6",
                    Tertiary = "#81c784",
                    Info = "#ff6a6a",
                    Success = "#81c784",
                    Warning = "#ffb74d",
                    Error = "#e57373",
                    Background = "#141414",
                    Surface = "#1e1d1d",
                    AppbarBackground = "#1e1d1d",
                    AppbarText = "#e1e1e1",
                    DrawerBackground = "#1e1d1d",
                    TextPrimary = "#e1e1e1",
                    TextSecondary = "#9e9e9e",
                    ActionDefault = "#9e9e9e",
                    Divider = "#424242",
                    DividerLight = "#616161",
                    BackgroundGray = "#2f2e2e"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== FOREST THEME (Nattskog) ==========
        private MudTheme GenerateForestTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#348202",
                    PrimaryDarken = "#286601",
                    PrimaryLighten = "#4ca812",
                    Secondary = "#238636",
                    Tertiary = "#58a6ff",
                    Info = "#348202",
                    Success = "#238636",
                    Warning = "#d29922",
                    Error = "#f85149",
                    Background = "#0d1117",
                    Surface = "#161b22",
                    AppbarBackground = "#161b22",
                    AppbarText = "#e6edf3",
                    DrawerBackground = "#161b22",
                    TextPrimary = "#e6edf3",
                    TextSecondary = "#8b949e",
                    ActionDefault = "#8b949e",
                    Divider = "#30363d",
                    DividerLight = "#484f58",
                    BackgroundGray = "#14151c"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        private Typography GetTypography()
        {
            return new Typography
            {
                Default = new DefaultTypography
                {
                    FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }
                },
                H1 = new H1Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H2 = new H2Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H3 = new H3Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H4 = new H4Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H5 = new H5Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H6 = new H6Typography { FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }, FontWeight = "600" },
                Button = new ButtonTypography { FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }, FontWeight = "600", TextTransform = "none" }
            };
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Theme\ThemeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\IUserFriendshipService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IUserFriendshipService
    {
        // Friendship queries
        Task<FriendshipListDto> GetFriendshipsAsync();
        Task<List<FriendProfileDto>> GetFriendsAsync();
        Task<UserFriendshipDto?> GetFriendshipAsync(Guid id);

        // Friend requests
        Task<UserFriendshipDto> SendFriendRequestAsync(Guid targetUserId);
        Task<UserFriendshipDto> SendFriendRequestByEmailAsync(string email);
        Task<UserFriendshipDto> AcceptFriendRequestAsync(Guid friendshipId);
        Task<UserFriendshipDto> RejectFriendRequestAsync(Guid friendshipId);
        Task RemoveFriendAsync(Guid friendshipId);

        // Search and profiles
        Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20);
        Task<FriendProfileDto?> GetUserProfileAsync(Guid userId);

        // Cache
        List<FriendProfileDto> CachedFriends { get; }
        int PendingRequestCount { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\IUserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\IUserRecipeService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IUserRecipeService
    {
        // Recipe CRUD
        Task<UserRecipePagedResult> GetMyRecipesAsync(GetUserRecipesQuery? query = null);
        Task<UserRecipeDto?> GetRecipeAsync(Guid id);
        Task<UserRecipeDto> CreateRecipeAsync(CreateUserRecipeDto dto);
        Task<UserRecipeDto> UpdateRecipeAsync(Guid id, UpdateUserRecipeDto dto);
        Task DeleteRecipeAsync(Guid id);

        // Publishing
        Task<PublishRecipeResultDto> PublishRecipeAsync(Guid id);
        Task<UserRecipeDto> DetachRecipeAsync(Guid id);

        // Rating
        Task<UserRecipeDto> RateRecipeAsync(Guid id, decimal rating, string? comment = null);
        Task RemoveRatingAsync(Guid id);

        // Archiving
        Task<UserRecipeDto> ArchiveRecipeAsync(Guid id);
        Task<UserRecipeDto> RestoreRecipeAsync(Guid id);

        // Friends' Recipes
        Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery? query = null);

        // Cache
        List<UserRecipeDto> CachedRecipes { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\IUserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\UserColorService.cs
================================================================================
namespace StorhaugenWebsite.Services;

/// <summary>
/// Service that generates consistent colors for users based on their username.
/// This ensures the same user always gets the same color across the entire app.
/// </summary>
public interface IUserColorService
{
    /// <summary>
    /// Gets a consistent hex color for a username.
    /// </summary>
    string GetUserColor(string? username);

    /// <summary>
    /// Gets a consistent hex color for a user ID.
    /// </summary>
    string GetUserColorById(Guid userId);

    /// <summary>
    /// Gets the CSS style string for background-color based on username.
    /// </summary>
    string GetUserColorStyle(string? username);
}

public class UserColorService : IUserColorService
{
    // A pleasing palette of distinct, accessible colors
    private static readonly string[] ColorPalette = {
        "#2E7D32", // Green
        "#00695C", // Teal
        "#0277BD", // Light Blue
        "#1565C0", // Blue
        "#283593", // Indigo
        "#4527A0", // Deep Purple
        "#6A1B9A", // Purple
        "#AD1457", // Pink
        "#C62828", // Red
        "#D84315", // Deep Orange
        "#EF6C00", // Orange
        "#F9A825", // Yellow/Amber
        "#558B2F", // Light Green
        "#00838F", // Cyan
        "#5D4037", // Brown
        "#455A64"  // Blue Grey
    };

    /// <inheritdoc />
    public string GetUserColor(string? username)
    {
        if (string.IsNullOrEmpty(username))
            return "#9E9E9E"; // Grey for unknown/empty usernames

        // Use a simple hash that's consistent across sessions
        int hash = GetStableHash(username.ToLowerInvariant());
        int index = Math.Abs(hash) % ColorPalette.Length;
        return ColorPalette[index];
    }

    /// <inheritdoc />
    public string GetUserColorById(Guid userId)
    {
        if (userId == Guid.Empty)
            return "#9E9E9E";

        int hash = GetStableHash(userId.ToString());
        int index = Math.Abs(hash) % ColorPalette.Length;
        return ColorPalette[index];
    }

    /// <inheritdoc />
    public string GetUserColorStyle(string? username)
    {
        return $"background-color: {GetUserColor(username)}";
    }

    /// <summary>
    /// Generates a stable hash code that's consistent across app sessions.
    /// Unlike string.GetHashCode(), this is deterministic.
    /// </summary>
    private static int GetStableHash(string str)
    {
        unchecked
        {
            int hash = 17;
            foreach (char c in str)
            {
                hash = hash * 31 + c;
            }
            return hash;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\UserColorService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\UserFriendshipService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class UserFriendshipService : IUserFriendshipService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<FriendProfileDto> CachedFriends { get; private set; } = new();
        public int PendingRequestCount { get; private set; } = 0;

        public UserFriendshipService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthentication()
        {
            if (!_authService.IsAuthenticated)
            {
                throw new UnauthorizedAccessException("You must be logged in to access friendships.");
            }
        }

        public async Task<FriendshipListDto> GetFriendshipsAsync()
        {
            ValidateAuthentication();

            var result = await _apiClient.GetFriendshipsAsync();
            PendingRequestCount = result.PendingReceived?.Count ?? 0;
            return result;
        }

        public async Task<List<FriendProfileDto>> GetFriendsAsync()
        {
            ValidateAuthentication();

            var friends = await _apiClient.GetFriendsAsync();
            CachedFriends = friends;
            return friends;
        }

        public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid id)
        {
            ValidateAuthentication();
            return await _apiClient.GetFriendshipAsync(id);
        }

		public async Task<UserFriendshipDto> SendFriendRequestAsync(Guid targetUserId)
		{
			ValidateAuthentication();

			// FIX 1: Corrected class name from 'SendUserFriendRequestDto' to 'SendFriendRequestDto'
			var dto = new SendFriendRequestDto
			{
				TargetUserId = targetUserId
			};

			var result = await _apiClient.SendFriendRequestAsync(dto);
			InvalidateCache();
			return result;
		}

		public async Task<UserFriendshipDto> SendFriendRequestByEmailAsync(string email)
		{
			ValidateAuthentication();

			if (string.IsNullOrWhiteSpace(email))
				throw new ArgumentException("Email is required.");

			// WARNING: Your backend 'SendFriendRequestDto' does NOT have an Email property.
			// You must add 'public string? TargetEmail { get; set; }' to the DTO in the Shared project
			// and handle it in the Backend Controller for this to work.

			// Assuming you will add it, the code would look like this:
			/*
			var dto = new SendFriendRequestDto { TargetEmail = email };
			var result = await _apiClient.SendFriendRequestAsync(dto);
			InvalidateCache();
			return result;
			*/

			throw new NotImplementedException("The backend DTO is missing the 'TargetEmail' property.");
		}

		public async Task<UserFriendshipDto> AcceptFriendRequestAsync(Guid friendshipId)
		{
			ValidateAuthentication();

			// FIX 2: Create the expected DTO with the string action "accept"
			var dto = new RespondFriendRequestDto { Action = "accept" };

			// Update ApiClient call to pass the object, not an enum
			var result = await _apiClient.RespondToFriendRequestAsync(friendshipId, dto);

			InvalidateCache();
			return result;
		}

		public async Task<UserFriendshipDto> RejectFriendRequestAsync(Guid friendshipId)
		{
			ValidateAuthentication();

			// FIX 2: Create the expected DTO with the string action "reject"
			var dto = new RespondFriendRequestDto { Action = "reject" };

			// Update ApiClient call to pass the object, not an enum
			var result = await _apiClient.RespondToFriendRequestAsync(friendshipId, dto);

			InvalidateCache();
			return result;
		}

		public async Task RemoveFriendAsync(Guid friendshipId)
        {
            ValidateAuthentication();

            await _apiClient.RemoveFriendshipAsync(friendshipId);
            InvalidateCache();
        }

        public async Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20)
        {
            ValidateAuthentication();

            if (string.IsNullOrWhiteSpace(query))
                return new List<UserSearchResultDto>();

            return await _apiClient.SearchUsersAsync(query, limit);
        }

        public async Task<FriendProfileDto?> GetUserProfileAsync(Guid userId)
        {
            ValidateAuthentication();
            return await _apiClient.GetUserProfileAsync(userId);
        }

        public void InvalidateCache()
        {
            CachedFriends = new List<FriendProfileDto>();
            PendingRequestCount = 0;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\UserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\UserRecipeService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class UserRecipeService : IUserRecipeService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<UserRecipeDto> CachedRecipes { get; private set; } = new();

        public UserRecipeService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthorization()
        {
            if (!_authService.IsAuthorized)
            {
                throw new UnauthorizedAccessException("You are not authorized to perform this action.");
            }
        }

        public async Task<UserRecipePagedResult> GetMyRecipesAsync(GetUserRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            query ??= new GetUserRecipesQuery();
            var result = await _apiClient.GetMyUserRecipesAsync(query);

            // Update cache with first page results
            if (query.Page == 1 && !query.IncludeArchived)
            {
                CachedRecipes = result.Recipes;
            }

            return result;
        }

        public async Task<UserRecipeDto?> GetRecipeAsync(Guid id)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            return await _apiClient.GetUserRecipeAsync(id);
        }

        public async Task<UserRecipeDto> CreateRecipeAsync(CreateUserRecipeDto dto)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(dto.Name) && !dto.GlobalRecipeId.HasValue)
                throw new ArgumentException("Recipe must have either a title or be linked to a global recipe.");

            var result = await _apiClient.CreateUserRecipeAsync(dto);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> UpdateRecipeAsync(Guid id, UpdateUserRecipeDto dto)
        {
            ValidateAuthorization();

            var result = await _apiClient.UpdateUserRecipeAsync(id, dto);
            InvalidateCache();
            return result;
        }

        public async Task DeleteRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            await _apiClient.DeleteUserRecipeAsync(id);
            InvalidateCache();
        }

        public async Task<PublishRecipeResultDto> PublishRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.PublishUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> DetachRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.DetachUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> RateRecipeAsync(Guid id, decimal rating, string? comment = null)
        {
            ValidateAuthorization();

            if (rating < 0 || rating > 10)
                throw new ArgumentException("Rating must be between 0 and 10.");

            var result = await _apiClient.RateUserRecipeAsync(id, rating, comment);
            InvalidateCache();
            return result;
        }

        public async Task RemoveRatingAsync(Guid id)
        {
            ValidateAuthorization();

            await _apiClient.RemoveUserRecipeRatingAsync(id);
            InvalidateCache();
        }

        public async Task<UserRecipeDto> ArchiveRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.ArchiveUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> RestoreRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.RestoreUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            query ??= new GetUserRecipesQuery();
            return await _apiClient.GetFriendsRecipesAsync(query);
        }

        public void InvalidateCache()
        {
            CachedRecipes = new List<UserRecipeDto>();
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\UserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\HelloFreshSyncService.cs
================================================================================
using StorhaugenWebsite.ApiClient;

namespace StorhaugenWebsite.Services;

public interface IHelloFreshSyncService
{
    Task TryTriggerSyncAsync();
    bool HasCheckedThisSession { get; }
}

/// <summary>
/// Service that handles automatic HelloFresh sync triggering.
/// Attempts to sync once per session if the server-side check determines it's needed.
/// </summary>
public class HelloFreshSyncService : IHelloFreshSyncService
{
    private readonly IApiClient _apiClient;
    private readonly ILogger<HelloFreshSyncService> _logger;
    private bool _hasCheckedThisSession = false;
    private readonly SemaphoreSlim _syncLock = new(1, 1);

    public bool HasCheckedThisSession => _hasCheckedThisSession;

    public HelloFreshSyncService(IApiClient apiClient, ILogger<HelloFreshSyncService> logger)
    {
        _apiClient = apiClient;
        _logger = logger;
    }

    /// <summary>
    /// Attempts to trigger a HelloFresh sync if needed.
    /// This is a fire-and-forget operation that runs in the background.
    /// Only runs once per session to avoid repeated API calls.
    /// </summary>
    public async Task TryTriggerSyncAsync()
    {
        // Only check once per session
        if (_hasCheckedThisSession)
            return;

        // Use a lock to prevent multiple simultaneous sync attempts
        if (!await _syncLock.WaitAsync(0))
            return;

        try
        {
            _hasCheckedThisSession = true;

            _logger.LogInformation("Checking if HelloFresh sync is needed...");

            // Call the sync endpoint without force - the server will check if sync is needed
            var result = await _apiClient.TriggerHelloFreshSyncAsync(force: false);

            if (result.RecipesAdded > 0 || result.RecipesUpdated > 0)
            {
                _logger.LogInformation(
                    "HelloFresh sync completed: {Added} added, {Updated} updated",
                    result.RecipesAdded, result.RecipesUpdated);
            }
            else
            {
                _logger.LogInformation("HelloFresh sync: {Message}", result.Message);
            }
        }
        catch (Exception ex)
        {
            // Log but don't throw - this is a background operation
            _logger.LogWarning(ex, "HelloFresh sync check failed (non-critical)");
        }
        finally
        {
            _syncLock.Release();
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\HelloFreshSyncService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\Extensions\RatingColorExtensions.cs
================================================================================
using System;

namespace StorhaugenWebsite.Shared.Extensions
{
    public static class RatingColorExtensions
    {
        // Default 0..10 rating scale
        public static string ToRatingColorHex(this double score, double min = 0, double max = 10)
        {
            // Clamp to range
            var x = Clamp(score, min, max);

            // Color stops (position, hex)
            // Tune these if you want different "where green starts" etc.
            var stops = new (double pos, string hex)[]
            {
                (0.0,  "#6A1B9A"), // purple (worst)
                (5.0,  "#F44336"), // red (below 5 fades to purple)
                (8.2,  "#4CAF50"), // green (good)
                (9.4,  "#4CAF50"), // keep green until "near 10"
                (10.0, "#2196F3"), // blue (best)
            };

            // Normalize x to 0..10 if min/max differ
            var t = (x - min) / (max - min);
            var v = t * 10.0;

            // Find segment
            for (int i = 0; i < stops.Length - 1; i++)
            {
                var (p0, c0) = stops[i];
                var (p1, c1) = stops[i + 1];

                if (v <= p1)
                {
                    var segT = (v - p0) / (p1 - p0);
                    segT = Clamp(segT, 0, 1);
                    return LerpHex(c0, c1, segT);
                }
            }

            return stops[^1].hex;
        }

        private static string LerpHex(string a, string b, double t)
        {
            var (ar, ag, ab) = ParseHex(a);
            var (br, bg, bb) = ParseHex(b);

            int r = (int)Math.Round(ar + (br - ar) * t);
            int g = (int)Math.Round(ag + (bg - ag) * t);
            int bl = (int)Math.Round(ab + (bb - ab) * t);

            return $"#{r:X2}{g:X2}{bl:X2}";
        }

        private static (int r, int g, int b) ParseHex(string hex)
        {
            if (string.IsNullOrWhiteSpace(hex)) throw new ArgumentException("Hex color is null/empty");
            if (hex[0] == '#') hex = hex[1..];
            if (hex.Length != 6) throw new ArgumentException("Hex color must be 6 digits (RRGGBB)");

            return (
                Convert.ToInt32(hex.Substring(0, 2), 16),
                Convert.ToInt32(hex.Substring(2, 2), 16),
                Convert.ToInt32(hex.Substring(4, 2), 16)
            );
        }

        private static double Clamp(double v, double min, double max) => v < min ? min : (v > max ? max : v);
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Shared\Extensions\RatingColorExtensions.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\Authorization.razor
================================================================================
<div class="login-required-container">
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Vennligst logg inn</h2>
        <p class="empty-state-text">@Text</p>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="login" Size="Size.Large">
            G til innlogging
        </MudButton>
    </div>
</div>

@code {
    [Parameter] public string Text { get; set; } = "Du m vre logget inn for  se denne siden";
}

================================================================================
FILE END: \StorhaugenWebsite\Shared\Authorization.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\Authorization.razor.css
================================================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Shared\Authorization.razor.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\MainLayout.razor
================================================================================
@inherits LayoutComponentBase
@inject IAuthService AuthService
@inject IHelloFreshSyncService HelloFreshSyncService
@inject NavigationManager Navigation
@using StorhaugenWebsite.Shared
@using StorhaugenWebsite.Components

<MudLayout>
    <MudAppBar Elevation="0" Class="app-header">
        <div class="d-flex align-center gap-2">
            <div class="brand-icon">
                <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Size="Size.Small" />
            </div>
            <MudText Typo="Typo.h6" Class="brand-text">Storhaugen</MudText>
        </div>
        <MudSpacer />
        @if (AuthService.IsAuthorized)
        {
            <MudIconButton Icon="@Icons.Material.Rounded.Settings"
                           Color="Color.Inherit"
                           OnClick="@(() => Navigation.NavigateTo("settings"))"
                           Size="Size.Medium" />
        }
    </MudAppBar>

    <MudMainContent Class="main-content">
        <MudContainer MaxWidth="MaxWidth.Small" Class="page-container">
            @if (IsAccessAllowed())
            {
                @Body
            }
            else
            {
                <Authorization Text="Du m vre medlem av en husstand for  se denne siden." />
            }
        </MudContainer>
    </MudMainContent>

    @if (AuthService.IsAuthorized)
    {
        <div class="bottom-nav">
            <div class="bottom-nav-inner">
                <button class="nav-item @(IsActive("") ? "active" : "")" @onclick="@(() => Navigate(""))">
                    <MudIcon Icon="@(IsActive("") ? Icons.Material.Rounded.Home : Icons.Material.Outlined.Home)" Size="Size.Small" />
                    <span>Hjem</span>
                </button>

                <button class="nav-item @(IsActive("cookbook") ? "active" : "")" @onclick="@(() => Navigate("cookbook"))">
                    <MudIcon Icon="@(IsActive("cookbook") ? Icons.Material.Rounded.MenuBook : Icons.Material.Outlined.MenuBook)" Size="Size.Small" />
                    <span>Kokebok</span>
                </button>

                <button class="nav-item nav-item-add @(IsActive("add") ? "active" : "")" @onclick="@(() => Navigate("add"))">
                    <div class="add-button">
                        <MudIcon Icon="@Icons.Material.Rounded.Add" Size="Size.Medium" />
                    </div>
                    <span>Ny</span>
                </button>

                <button class="nav-item @(IsActive("friends") ? "active" : "")" @onclick="@(() => Navigate("friends"))">
                    <MudIcon Icon="@(IsActive("friends") ? Icons.Material.Rounded.People : Icons.Material.Outlined.People)" Size="Size.Small" />
                    <span>Venner</span>
                </button>

                <button class="nav-item @(IsActive("collections") ? "active" : "")" @onclick="@(() => Navigate("collections"))">
                    <MudIcon Icon="@(IsActive("collections") ? Icons.Material.Rounded.FolderShared : Icons.Material.Outlined.FolderShared)" Size="Size.Small" />
                    <span>Samlinger</span>
                </button>
            </div>
        </div>
    }
</MudLayout>

@code {
    protected override void OnInitialized()
    {
        AuthService.OnAuthStateChanged += OnAuthStateChanged;
        Navigation.LocationChanged += OnLocationChanged;

        // If already authenticated, trigger sync check
        if (AuthService.IsAuthorized)
        {
            _ = TriggerHelloFreshSyncAsync();
        }
    }

    private void OnAuthStateChanged()
    {
        StateHasChanged();

        // Trigger HelloFresh sync when user becomes authenticated
        if (AuthService.IsAuthorized)
        {
            _ = TriggerHelloFreshSyncAsync();
        }
    }

    private async Task TriggerHelloFreshSyncAsync()
    {
        try
        {
            await HelloFreshSyncService.TryTriggerSyncAsync();
        }
        catch
        {
            // Silently ignore errors - this is a background operation
        }
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        StateHasChanged();
    }

    private bool IsAccessAllowed()
    {
        if (AuthService.IsAuthorized) return true;

        var currentPath = Navigation.ToBaseRelativePath(Navigation.Uri).ToLower();

        if (string.IsNullOrEmpty(currentPath) || currentPath.StartsWith("login"))
        {
            return true;
        }

        return false;
    }

    private bool IsActive(string path)
    {
        var currentPath = Navigation.ToBaseRelativePath(Navigation.Uri);

        // Exact match for Home ("")
        if (string.IsNullOrEmpty(path))
            return string.IsNullOrEmpty(currentPath);

        // Starts with match for others (e.g. "browse" matches "browse/123")
        return currentPath.StartsWith(path, StringComparison.OrdinalIgnoreCase);
    }

    private void Navigate(string path)
    {
        Navigation.NavigateTo(path);
    }

    public void Dispose()
    {
        AuthService.OnAuthStateChanged -= OnAuthStateChanged;
        Navigation.LocationChanged -= OnLocationChanged;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Shared\MainLayout.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\MainLayout.razor.css
================================================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Shared\MainLayout.razor.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\app.css
================================================================================
/* Fonts */
@import url('https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=Fraunces:ital,opsz,wght@0,9..144,400;0,9..144,500;0,9..144,600;0,9..144,700;1,9..144,400&display=swap');

/* CSS Variables */
:root {
    --app-bar-height: 56px;
    --bottom-nav-height: 56px;
    --page-padding: 20px;
    --card-radius: 20px;
    --transition-fast: 150ms ease;
    --transition-smooth: 300ms cubic-bezier(0.4, 0, 0.2, 1);
    /* Member Colors */
    --color-markus: #E07A2E;
    --color-siv: #2D5A45;
    --color-elias: #4A7C9B;
}

/* Base */
html {
    scroll-behavior: smooth;
    -webkit-tap-highlight-color: transparent;
}

body {
    font-family: 'DM Sans', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overscroll-behavior: none;
}

/* MudBlazor Overrides */
.mud-input-outlined .mud-input-slot-input {
    font-size: 16px !important;
}

.mud-button {
    text-transform: none !important;
    font-weight: 600 !important;
}

.mud-chip {
    font-weight: 600 !important;
}

.mud-snackbar-location-bottom-center {
    bottom: calc(var(--bottom-nav-height) + 16px) !important;
}

/* ============================================
   GENERIC SHARED CARD STYLES (non-food specific)
   ============================================ */

.card-base {
    background: var(--mud-palette-surface);
    border-radius: 16px;
    border: 1px solid var(--mud-palette-divider);
    transition: var(--transition-smooth);
    cursor: pointer;
}

    .card-base:hover {
        border-color: transparent;
        box-shadow: 0 8px 24px rgba(44, 36, 22, 0.1);
        background-color: var(--mud-palette-background-grey);
    }

    .card-base:active {
        transform: scale(0.98);
    }

/* Friend Card */
.friend-card {
    background: var(--mud-palette-surface);
    border-radius: 16px;
    transition: transform 0.2s, background-color 0.2s;
    cursor: pointer;
}

    .friend-card:hover {
        background-color: var(--mud-palette-background-grey);
    }

    .friend-card:active {
        transform: scale(0.98);
    }

.request-card {
    background: rgba(var(--mud-palette-primary-rgb), 0.05);
    border-color: rgba(var(--mud-palette-primary-rgb), 0.2);
}

/* Section Header */
.section-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    padding-left: 4px;
}

.meta-chip {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    padding: 2px 6px;
    background: var(--mud-palette-background-grey);
    border-radius: 6px;
    font-size: 0.7rem;
    color: var(--mud-palette-text-secondary);
}

    .meta-chip.difficulty-easy {
        background: rgba(76, 175, 80, 0.1);
        color: #2e7d32;
    }

    .meta-chip.difficulty-medium {
        background: rgba(255, 152, 0, 0.1);
        color: #e65100;
    }

    .meta-chip.difficulty-hard {
        background: rgba(244, 67, 54, 0.1);
        color: #c62828;
    }

.rating-count {
    font-size: 0.6rem;
    color: var(--mud-palette-text-secondary);
    margin-top: 1px;
}

/* ============================================
   ACTIVITY FEED STYLES (kept)
   ============================================ */

.activity-feed {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.activity-card {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    cursor: pointer;
    transition: var(--transition-smooth);
    min-height: 80px;
}

    .activity-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(44, 36, 22, 0.1);
    }

.activity-image-layer {
    position: absolute;
    top: 0;
    right: 0;
    width: 50%;
    height: 100%;
    background-size: cover;
    background-position: center;
    mask-image: linear-gradient(to left, rgba(0,0,0,0.7) 0%, transparent 100%);
    -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,0.7) 0%, transparent 100%);
}


/* Error UI */
#blazor-error-ui {
    background: var(--mud-palette-error);
    bottom: 0;
    box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.2);
    display: none;
    left: 0;
    padding: 0.6rem 1.25rem 0.7rem;
    position: fixed;
    width: 100%;
    z-index: 1000;
    color: white;
}

    #blazor-error-ui .dismiss {
        cursor: pointer;
        position: absolute;
        right: 0.75rem;
        top: 0.5rem;
    }


/* ============================================
   GENERIC CROSSFADE STACK (Skeleton -> Content)
   Usage:
     <div class="xfade @(isLoading ? "loading" : "loaded")">
        <div class="xfade-skeleton">...</div>
        <div class="xfade-content">...</div>
     </div>
   ============================================ */

.xfade {
    display: grid;
}

    .xfade > .xfade-skeleton,
    .xfade > .xfade-content {
        grid-area: 1 / 1;
    }

    .xfade .xfade-skeleton,
    .xfade .xfade-content {
        will-change: opacity, transform;
        transition: opacity 180ms ease, transform 220ms ease;
        min-width: 0;
    }

    /* Loading: skeleton visible, content hidden */
    .xfade.loading .xfade-skeleton {
        opacity: 1;
        transform: translateY(0);
    }

    .xfade.loading .xfade-content {
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
    }

    /* Loaded: skeleton fades out, content fades in */
    .xfade.loaded .xfade-skeleton {
        opacity: 0;
        transform: translateY(-4px);
        pointer-events: none;
    }

    .xfade.loaded .xfade-content {
        opacity: 1;
        transform: translateY(0);
    }

@media (prefers-reduced-motion: reduce) {
    .xfade .xfade-skeleton,
    .xfade .xfade-content {
        transition: none;
        transform: none;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\app.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Food.css
================================================================================
/* ==========================================================================
   1. LANDSCAPE BLOCKER & DEVICE ORIENTATION
   ========================================================================== */

#landscape-blocker {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    height: 100dvh; /* Mobile viewport fix */
    background: #0f172a; /* Dark background */
    z-index: 999999; /* Above everything */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    padding: 20px;
}

/* Only show blocker when screen is actually in Landscape */
@media screen and (orientation: landscape) {
    #landscape-blocker {
        display: flex !important;
    }
    /* Hide content behind it to prevent scrolling */
    .app-content-container {
        display: none !important;
    }
}

/* ==========================================================================
   2. GLOBAL PAGE STYLES & HEADERS
   ========================================================================== */

.page-header {
    margin-bottom: 24px;
}

.page-subtitle {
    font-size: 0.9rem;
    color: var(--mud-palette-text-secondary);
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 60px 24px;
}

.empty-state-icon {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: var(--mud-palette-divider-light);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 20px;
    color: var(--mud-palette-text-secondary);
}

.empty-state-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 8px;
}

.empty-state-text {
    color: var(--mud-palette-text-secondary);
    margin-bottom: 24px;
}

/* ==========================================================================
   3. FORM STYLES & INPUTS
   ========================================================================== */

.form-section {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 16px);
    padding: 20px;
    margin-bottom: 16px;
}

.form-section-title {
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--mud-palette-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 16px;
}

/* Rating Slider Components */
.rating-member-card {
    background: var(--mud-palette-background);
    border-radius: 14px;
    padding: 14px;
    margin-bottom: 12px;
}

.rating-member-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.rating-member-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.rating-member-avatar {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 0.9rem;
}

.rating-slider-container {
    margin-top: 14px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.rating-value-display {
    min-width: 44px;
    height: 36px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1rem;
}

/* ==========================================================================
   4. IMAGE UPLOAD & PREVIEWS
   ========================================================================== */

.image-upload-area {
    border: 2px dashed var(--mud-palette-divider);
    border-radius: 14px;
    padding: 24px;
    text-align: center;
    transition: var(--transition-fast, 0.2s ease);
    cursor: pointer;
}

    .image-upload-area:hover {
        border-color: var(--mud-palette-primary);
        background: rgba(224, 122, 46, 0.04);
    }

.image-preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    margin-bottom: 14px;
}

.image-preview-item {
    position: relative;
    aspect-ratio: 1;
    border-radius: 12px;
    overflow: hidden;
}

    .image-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

.image-preview-remove {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: var(--transition-fast, 0.2s ease);
}

    .image-preview-remove:hover {
        background: var(--mud-palette-error);
    }

/* ==========================================================================
   5. CAMERA OVERLAY & SCANNING LOGIC
   ========================================================================== */

.camera-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
    background: #000;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.camera-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(1) !important;
}

/* Guide Box Container */
.camera-guide-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10002;
    transition: all 0.5s ease;
}

.camera-guide-box {
    border: 3px solid rgba(255, 255, 255, 0.9);
    border-radius: 16px;
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8);
    position: relative;
    overflow: hidden;
    background: transparent;
}

/* --- Camera Scanning Steps --- */

/* STEP 1: Landscape Mode (Visual "Landscape" box on Portrait screen) */
.camera-guide-container.step-landscape .camera-guide-box {
    width: 95vw; /* Wider */
    aspect-ratio: 3/4; /* Shorter (was 9/16) */
    max-height: 70vh;
}

/* Logo Hint Zone */
.step-landscape .logo-hint-zone {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: rotate(90deg);
    opacity: 0.9;
}

    .step-landscape .logo-hint-zone::before {
        display: none;
    }

.step-landscape .logo-label {
    color: #ffffff;
    font-weight: 800;
    font-size: 11px;
    text-transform: uppercase;
    text-align: center;
    line-height: 1;
}

/* Text Hint Zone (Rotated 90 deg) */
.step-landscape .text-hint-zone {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(90deg);
    width: 60vh; /* Based on height since it's rotated */
    height: 60px;
    border: 2px dashed rgba(255,255,255,0.5);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.step-landscape .text-label {
    color: rgba(255,255,255,0.9);
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
    transform: rotate(90deg);
}

/* STEP 2: Ingredients (Portrait Tall) */
.camera-guide-container.step-portrait-tall .camera-guide-box {
    width: 65vw;
    height: 70vh;
}

/* STEP 3: Normal Portrait */
.camera-guide-container.step-portrait-normal .camera-guide-box {
    width: 85vw;
    aspect-ratio: 210/297;
    max-width: 450px;
}

/* --- Camera Animations & Controls --- */

.scan-line {
    width: 100%;
    height: 2px;
    background: #00E676;
    position: absolute;
    top: 0;
    box-shadow: 0 0 10px #00E676;
    animation: scanAnim 3s infinite;
}

@keyframes scanAnim {
    0% {
        top: 5%;
        opacity: 0;
    }

    20% {
        opacity: 1;
    }

    80% {
        opacity: 1;
    }

    100% {
        top: 95%;
        opacity: 0;
    }
}

.camera-instruction-pill {
    position: absolute;
    top: 24px;
    background: rgba(0,0,0,0.6);
    padding: 8px 16px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(4px);
    z-index: 10001;
}

.step-text {
    color: #00E676;
    font-weight: bold;
    font-size: 12px;
}

.camera-guide-text {
    position: absolute;
    bottom: 120px;
    color: white;
    text-align: center;
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    max-width: 80%;
    z-index: 10001;
}

.camera-controls {
    position: absolute;
    bottom: 30px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 32px;
    z-index: 10000;
    pointer-events: auto;
}

.step-counter {
    color: white;
    font-weight: bold;
    font-size: 14px;
    width: 48px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    padding: 4px 8px;
    border-radius: 8px;
}

.camera-shutter {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3); /* Semi-transparent outer ring */
    border: 4px solid #fff; /* Solid white border */
    position: relative;
    cursor: pointer;
    transition: transform 0.1s, background 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5); /* Drop shadow to separate from background */
}

    .camera-shutter::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 54px; /* Slightly smaller inner circle */
        height: 54px;
        border-radius: 50%;
        background: #ffffff; /* Solid white inner button */
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .camera-shutter:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.5);
    }

    .camera-shutter.processing {
        border-color: #999;
        pointer-events: none;
    }

        .camera-shutter.processing::after {
            width: 20px;
            height: 20px;
            background: #999;
            animation: spin 1s infinite linear;
        }

@keyframes spin {
    100% {
        transform: rotate(360deg);
    }
}

/* ==========================================================================
   6. FOOD LIST UTILITIES
   ========================================================================== */

/* Horizontal Scroll Container */
.horizontal-scroll-container {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    mask-image: linear-gradient(to right, black 95%, transparent 100%);
    -webkit-mask-image: linear-gradient(to right, black 95%, transparent 100%);
}

    .horizontal-scroll-container::-webkit-scrollbar {
        display: none;
    }

/* Sort Dropdown */
.sort-select .mud-input-slot {
    font-size: 0.875rem;
}

/* --- FOOD CARD STYLES --- */

.food-card {
    background: var(--mud-palette-surface);
    border-radius: 16px;
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: stretch;
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.2s;
}

    .food-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }

    .food-card:active {
        transform: scale(0.98);
    }

/* Image & Placeholder Fade - MOVED TO RIGHT */
.food-card-image,
.food-card-placeholder {
    width: 50%;
    height: 100%;
    position: absolute;
    right: 0; /* Changed from left: 0 */
    top: 0;
    bottom: 0;
    z-index: 0;
    /* Flip mask to fade from Right to Left */
    -webkit-mask-image: linear-gradient(to left, black 0%, transparent 100%);
    mask-image: linear-gradient(to left, black 0%, transparent 100%);
}

.food-card-image {
    width: 50%;
    height: 100%;
    position: absolute;
    right: 0; /* Changed from left: 0 */
    top: 0;
    opacity: 0.35;
    bottom: 0;
    z-index: 0;
    object-fit: cover;
    /* Flip mask to fade from Right to Left */
    -webkit-mask-image: linear-gradient(to left, black 0%, black 0%, transparent 100%);
    mask-image: linear-gradient(to left, black 0%, black 0%, transparent 100%);
}

.food-card-placeholder {
    background: var(--mud-palette-divider-light);
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Content Section - MOVED TO LEFT */
.food-card-content {
    flex-grow: 1;
    padding: 10px 12px;
    z-index: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    margin-left: 0; /* Reset left margin */
    position: relative;
}

.food-card-title {
    font-family: 'Fraunces', serif;
    font-size: 1.1rem;
    line-height: 1.2;
    margin-bottom: 4px;
    font-weight: 600;
    text-shadow: 0 0 12px var(--mud-palette-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* --- RATING STYLES --- */

/* Generalized Rating Chip (replaces .mini-rating-avatar) */
.rating-chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 2px 8px;
    height: 24px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 700;
    backdrop-filter: blur(4px);
    transition: transform 0.1s;
}

.rating-pill {
    display: inline-flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.05); /* Very subtle background */
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 50px;
    padding: 3px 10px 3px 3px;
    margin-right: 6px;
    transition: all 0.2s ease;
    gap:4px;
}

    .rating-pill:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
    }

/* The Circle containing the Initial */
.rating-circle {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 800;
    color: #1a1a1a; /* Dark text for contrast inside colored circle */
    text-transform: uppercase;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* The Number Score */
.rating-score {
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--mud-palette-text-primary);
}

/* Special styling for "My" rating (du) */
.rating-pill.mine {
    background: rgba(var(--mud-palette-primary-rgb), 0.1);
    border-color: rgba(var(--mud-palette-primary-rgb), 0.3);
}

.rating-chip.mine {
    z-index: 2;
    font-weight: 800;
}

.rating-chip:hover {
    transform: scale(1.05);
}

/* The individual small circles */
.mini-rating-avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    color: white;
    font-size: 11px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid rgba(255,255,255,0.1);
}

    .mini-rating-avatar.mine {
        font-size: 11px;
        box-shadow: 0 0 0 2px var(--mud-palette-surface), 0 0 0 3px currentColor;
        z-index: 2;
        margin-right: 4px;
    }

/* The Main Average Star Badge */
.rating-badge {
    font-weight: 700;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 6px;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(4px);
}

/* Rating count badge - similar style to rating badge */
.rating-count-badge {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 0.7rem;
    font-weight: 600;
    background: rgba(0,0,0,0.15);
    backdrop-filter: blur(4px);
    color: var(--mud-palette-text-secondary);
    margin-top: 4px;
}

/* --- SKELETONS --- */
.skeleton-card {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 12px);
    overflow: hidden;
}

.skeleton-image {
    aspect-ratio: 16/10;
    background: linear-gradient(90deg, var(--mud-palette-divider-light) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-divider-light) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
}

.skeleton-content {
    padding: 16px;
}

.skeleton-text {
    height: 14px;
    border-radius: 6px;
    background: var(--mud-palette-divider-light);
    margin-bottom: 10px;
}

    .skeleton-text.title {
        height: 20px;
        width: 60%;
    }

    .skeleton-text.subtitle {
        width: 40%;
    }

@keyframes shimmer {
    0% {
        background-position: 200% 0;
    }

    100% {
        background-position: -200% 0;
    }
}

/* ==========================================================================
   7. FOOD DETAILS PAGE
   ========================================================================== */

/* Group Chips */
.group-chip {
    display: inline-flex;
    align-items: center;
    padding: 6px 12px;
    border-radius: 20px;
    background: transparent;
    border: 1px solid var(--mud-palette-lines-default);
    color: var(--mud-palette-text-secondary);
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
    user-select: none;
}

    /* Active State */
    .group-chip.active {
        background: rgba(45, 90, 69, 0.35);
        color: #1c9f62;
        border-color: transparent;
        font-weight: 600;
    }
/* Dark mode override */
:root[theme="dark"] .group-chip.active {
    background: rgba(93, 190, 138, 0.2);
    color: #5DBE8A;
}

.detail-header {
    margin-bottom: 20px;
}

.detail-back-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    background: var(--mud-palette-surface);
    border: 1px solid var(--mud-palette-divider);
    border-radius: 10px;
    color: var(--mud-palette-text-secondary);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-fast, 0.2s);
    font-family: 'DM Sans', system-ui, sans-serif;
}

    .detail-back-btn:hover {
        border-color: var(--mud-palette-primary);
        color: var(--mud-palette-primary);
    }

.detail-image-carousel {
    border-radius: var(--card-radius, 12px);
    overflow: hidden;
    margin-bottom: 20px;
}

.detail-info-card {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 12px);
    padding: 20px;
    margin-bottom: 20px;
}

.detail-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 8px;
}

.detail-meta {
    font-size: 0.85rem;
    color: var(--mud-palette-text-secondary);
    margin-bottom: 12px;
}

.detail-description {
    color: var(--mud-palette-text-secondary);
    line-height: 1.6;
    background-color: var(--mud-palette-background);
    padding: 16px;
    border-radius: 16px;
    margin-bottom: 16px;
}

/* Visibility Card */
.visibility-card {
    background: var(--mud-palette-background);
    border-radius: 14px;
    padding: 14px;
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Food.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Layout.css
================================================================================
/* App Header */
.app-header {
    background: var(--mud-palette-surface) !important;
    border-bottom: 1px solid var(--mud-palette-divider);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}

.brand-icon {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
}

.brand-text {
    font-family: 'Fraunces', Georgia, serif !important;
    font-weight: 600 !important;
    letter-spacing: -0.02em;
}

/* Main Content */
.main-content {
    background: var(--mud-palette-background);
    min-height: 100vh;
    padding-top: var(--app-bar-height);
    padding-bottom: calc(var(--bottom-nav-height) + 12px);
}

.page-container {
    padding: var(--page-padding) !important;
    max-width: 540px !important;
}

@media (max-width: 600px) {
    .page-container {
        padding: 16px !important;
    }
}

/* Bottom Navigation - Docked Style */
.bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1100;
    /* Remove padding to make it flush with edges */
    padding: 0;
    /* Background moves here to cover the whole bottom area */
    background: var(--mud-palette-surface);
    /* Add a subtle top border for separation */
    border-top: 1px solid var(--mud-palette-divider);
    /* Handle iPhone/Android Gesture bar area */
    padding-bottom: env(safe-area-inset-bottom);
    /* Ensure the bar blocks clicks behind it */
    pointer-events: auto;
}

.bottom-nav-inner {
    width: 100%;
    /* Max width prevents it from stretching too far on desktop */
    max-width: 600px;
    margin: 0 auto; /* Center on desktop */
    /* Remove pill styling */
    border-radius: 0;
    background: transparent;
    box-shadow: none;
    /* Adjust padding for the docked look */
    padding: 8px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: var(--bottom-nav-height);
}

.nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1; /* Distribute space evenly */
    gap: 4px;
    border: none;
    background: transparent;
    color: var(--mud-palette-text-secondary);
    cursor: pointer;
    transition: color 0.2s ease;
    height: 100%;
}

    .nav-item span {
        font-size: 11px;
        font-weight: 500;
        letter-spacing: 0.01em;
    }

    .nav-item:hover {
        color: var(--mud-palette-text-primary);
    }

    .nav-item.active {
        color: var(--mud-palette-primary);
    }

/* The Add Button Container - Pops out slightly */
.nav-item-add {
    position: relative;
    top: -10px; /* Changed from -20px. Sits lower in the bar. */
    height: auto;
    overflow: visible;
}

/* The Orange Button Itself */
.add-button {
    width: 48px; /* Changed from 56px. Smaller footprint. */
    height: 48px; /* Changed from 56px. */
    border-radius: 50%;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    /* Reduced border width slightly to match new size */
    border: 3px solid var(--mud-palette-surface);
    /* Reduced shadow opacity and spread for a softer look */
    box-shadow: 0 2px 8px rgba(224, 122, 46, 0.25);
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.nav-item-add:hover .add-button {
    transform: scale(1.05); /* Slightly smaller hover effect */
    box-shadow: 0 4px 12px rgba(224, 122, 46, 0.4);
}

.nav-item-add:active .add-button {
    transform: scale(0.95);
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Layout.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Login.css
================================================================================
.login-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 80vh;
    text-align: center;
    padding: 24px;
}

.login-card {
    background: var(--mud-palette-surface);
    border-radius: 24px;
    padding: 40px 32px;
    width: 100%;
    max-width: 360px;
    border: 1px solid var(--mud-palette-divider);
}

.login-logo {
    width: 64px;
    height: 64px;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    margin: 0 auto 24px;
}

.login-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.75rem;
    font-weight: 600;
    margin-bottom: 8px;
}

    .login-title:focus,
    .login-title:focus-visible {
        outline: none;
    }

.login-subtitle {
    color: var(--mud-palette-text-secondary);
    margin-bottom: 32px;
}

.login-btn {
    width: 100%;
    padding: 14px 24px;
    border-radius: 14px;
    border: none;
    background: var(--mud-palette-text-primary);
    color: var(--mud-palette-surface);
    font-weight: 600;
    font-size: 0.95rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    transition: var(--transition-smooth);
    font-family: 'DM Sans', system-ui, sans-serif;
}

    .login-btn:hover {
        opacity: 0.9;
        transform: translateY(-1px);
    }

    .login-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

.login-footer {
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid var(--mud-palette-divider);
}

.login-avatars {
    display: flex;
    justify-content: center;
    gap: 8px;
}

.login-avatar {
    width: 32px;
    height: 32px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 0.8rem;
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Login.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\js\deviceState.js
================================================================================
window.deviceState = {
    get: function (key) {
        return localStorage.getItem(key);
    },
    set: function (key, value) {
        localStorage.setItem(key, value);
    },
    remove: function (key) {
        localStorage.removeItem(key);
    },
    getPreferredTheme: function () {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        return 'light';
    }
};

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\js\deviceState.js
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\js\ocrInterop.js
================================================================================
// ==========================================
// 1. CAMERA INTEROP (Video Stream & Capture)
// ==========================================
window.cameraInterop = {
    stream: null,

    start: async (videoElement) => {
        if (window.cameraInterop.stream) {
            window.cameraInterop.stream.getTracks().forEach(track => track.stop());
            window.cameraInterop.stream = null;
        }

        try {
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    focusMode: 'continuous' // Try to force focus
                }
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = stream;
            window.cameraInterop.stream = stream;

            // Wait a moment for camera to adjust focus/exposure
            const track = stream.getVideoTracks()[0];
            if (track.getCapabilities && track.getCapabilities().focusMode) {
                try { await track.applyConstraints({ advanced: [{ focusMode: "continuous" }] }); } catch (e) { }
            }
        }
        catch (err) {
            console.error("Camera Error:", err);
        }
    },

    capture: async (videoElement) => {
        const canvas = document.createElement("canvas");
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        // Draw image
        canvas.getContext('2d').drawImage(videoElement, 0, 0);
        return canvas.toDataURL("image/jpeg", 0.95); // High quality for OCR
    },

    stop: (videoElement) => {
        if (window.cameraInterop.stream) {
            window.cameraInterop.stream.getTracks().forEach(track => track.stop());
            window.cameraInterop.stream = null;
        }
        if (videoElement) {
            videoElement.srcObject = null;
        }
    }
};

// ==========================================
// 2. IMAGE TOOLS
// ==========================================
window.imageTools = {
    processInputFile: async (inputId) => {
        const input = document.getElementById(inputId);
        if (!input || !input.files || input.files.length === 0) return [];

        const processedImages = [];
        for (let i = 0; i < input.files.length; i++) {
            const file = input.files[i];
            try {
                // Resize to max 2000px - bigger is often better for text detection
                const base64 = await resizeImage(file, 2000, 2000);
                processedImages.push({ name: file.name, data: base64 });
            } catch (err) {
                console.error("Error processing file:", err);
            }
        }
        input.value = '';
        return processedImages;
    }
};

function resizeImage(file, maxWidth, maxHeight) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
            const img = new Image();
            img.src = event.target.result;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width *= maxHeight / height;
                        height = maxHeight;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                resolve(canvas.toDataURL('image/jpeg', 0.9));
            };
        };
    });
}

// ==========================================
// 3. OCR INTEROP (Robust Rotation Logic)
// ==========================================
window.ocrInterop = {
    recognizeTextFromImage: async (base64Image) => {
        if (typeof Tesseract === 'undefined') {
            console.error("Tesseract.js not loaded.");
            return "Error: Tesseract missing";
        }

        try {
            console.log("OCR Start...");
            const img = new Image();
            img.src = base64Image;
            await new Promise(r => img.onload = r);

            // Create worker with better config
            const worker = await Tesseract.createWorker('nor');
            await worker.setParameters({
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                preserve_interword_spaces: '1',
            });

            // --- STRATEGY: Try 0 -> 90 -> 270 (270 is needed for your Title image) ---

            // 1. Try Normal (0 deg)
            let bestText = await tryRecognize(worker, img, 0);

            // 2. If result looks bad, try Landscape (90 deg)
            if (isTextGarbage(bestText)) {
                console.log("Text garbage at 0deg. Trying 90deg...");
                const text90 = await tryRecognize(worker, img, 90);
                if (countLetters(text90) > countLetters(bestText)) bestText = text90;
            }

            // 3. If result still looks bad, try Inverse Landscape (270 deg)
            // This is CRITICAL for the "Spr katsu" image you provided
            if (isTextGarbage(bestText)) {
                console.log("Text garbage. Trying 270deg (bottom-to-top text)...");
                const text270 = await tryRecognize(worker, img, 270);
                if (countLetters(text270) > countLetters(bestText)) bestText = text270;
            }

            await worker.terminate();
            return bestText;

        } catch (error) {
            console.error("OCR Error:", error);
            return null;
        }
    }
};

async function tryRecognize(worker, imgElement, rotation) {
    // Preprocess: Rotate -> Grayscale -> Contrast
    const processedBase64 = preprocessImageForOCR(imgElement, rotation);
    const result = await worker.recognize(processedBase64);
    console.log(`Result at ${rotation}deg:`, result.data.text.substring(0, 50) + "...");
    return result.data.text;
}

// REPLACE THESE FUNCTIONS IN ocrinterop.js

function countLetters(text) {
    if (!text) return 0;
    // Fix: Count Letters AND Numbers as valid content
    return text.replace(/[^a-zA-Z0-9]/g, '').length;
}

function isTextGarbage(text) {
    if (!text || text.length < 3) return true; // Lowered min length slightly
    const validCharCount = countLetters(text);

    // Ingredients often have many spaces/newlines, so we lower the threshold
    // If less than 30% of the content is alphanumeric, it's noise
    return (validCharCount / text.length) < 0.30;
}

// Advanced Preprocessing: High Contrast Grayscale (Better than hard threshold)
function preprocessImageForOCR(imgElement, rotateDegrees) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Swap dimensions for rotation
    if (rotateDegrees === 90 || rotateDegrees === 270) {
        canvas.width = imgElement.height;
        canvas.height = imgElement.width;
    } else {
        canvas.width = imgElement.width;
        canvas.height = imgElement.height;
    }

    // 1. ROTATE
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(rotateDegrees * Math.PI / 180);
    ctx.drawImage(imgElement, -imgElement.width / 2, -imgElement.height / 2);

    // 2. CONTRAST & GRAYSCALE
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const contrast = 1.5; // Increase contrast by 50%
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // Standard Grayscale
        let gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;

        // Apply High Contrast
        gray = (gray * contrast) + intercept;

        // Clamp 0-255
        gray = Math.max(0, Math.min(255, gray));

        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
    }
    ctx.putImageData(imageData, 0, 0);

    return canvas.toDataURL('image/jpeg', 1.0);
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\js\ocrInterop.js
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\appsettings.json
================================================================================
{
  "Supabase": {
    "Url": "https://ithuvxvsoozmvdicxedx.supabase.co",
    "AnonKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0"
  },
  "ApiBaseUrl": "https://storhaugen-eats-api-a7ckh4hwdvcagcb7.westeurope-01.azurewebsites.net"
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\appsettings.json
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\index.html
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Storhaugen Eats</title>
    <script>
        // Sjekker om vi kjører på localhost eller 127.0.0.1
        var path = window.location.hostname.includes('localhost') || window.location.hostname.includes('127.0.0.1')
            ? '/'
            : '/StorhaugenWebsite/'; // Navnet på repoet/mappen din i production

        document.write('<base href="' + path + '" />');
    </script>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="apple-touch-icon" href="icon-192.png" />

    <!-- MudBlazor CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />

    <!-- Custom Styles -->
    <link href="css/app.css" rel="stylesheet" />
    <link href="css/Food.css" rel="stylesheet" />
    <link href="css/Layout.css" rel="stylesheet" />
    <link href="css/Login.css" rel="stylesheet" />


    <!-- PWA -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0f172a" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
</head>
<body>
    <div id="app">
        <div class="app-loading-container">
            <div class="app-loading-logo">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z" />
                </svg>
            </div>

            <h1 class="app-loading-title">Storhaugen Eats</h1>

            <div class="app-loading-bar-container">
                <div class="app-loading-bar"></div>
            </div>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>

    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
    <script src="js/deviceState.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@v5/dist/tesseract.min.js"></script>
    <script src="js/ocrInterop.js?v=2"></script>

    <script type="importmap"></script>
    <script src="_framework/blazor.webassembly#[.{fingerprint}].js"></script>
</body>
</html>

<style>
    /* Import fonts immediately so they are ready */
    @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Fraunces:wght@400;600&display=swap');

    :root {
        --loading-bg: #1e1e1e; /* Dark background to match app */
        --loading-text: #ffffff;
        --loading-primary: #E07A2E; /* Your Markus Orange color */
        --loading-primary-dark: #bf6322;
    }

    /* Light Mode Support - optional if you want strictly dark */
    @media (prefers-color-scheme: light) {
        :root {
            --loading-bg: #ffffff;
            --loading-text: #2d2d2d;
        }
    }

    body {
        margin: 0;
        background-color: var(--loading-bg); /* Prevents white flash */
    }

    .app-loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100vw;
        background-color: var(--loading-bg);
        font-family: 'DM Sans', sans-serif;
        color: var(--loading-text);
        position: fixed;
        top: 0;
        left: 0;
        z-index: 9999;
    }

    /* The Logo Box - Matches your Login Page Brand Icon */
    .app-loading-logo {
        width: 80px;
        height: 80px;
        border-radius: 20px;
        background: linear-gradient(135deg, var(--loading-primary), var(--loading-primary-dark));
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        margin-bottom: 24px;
        box-shadow: 0 10px 25px rgba(224, 122, 46, 0.4);
        animation: float 3s ease-in-out infinite;
    }

        .app-loading-logo svg {
            width: 40px;
            height: 40px;
        }

    /* Typography - Matches your Headers */
    .app-loading-title {
        font-family: 'Fraunces', serif;
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0 0 32px 0;
        opacity: 0;
        animation: fadeIn 0.8s ease-out 0.2s forwards;
    }

    /* Custom Loading Bar */
    .app-loading-bar-container {
        width: 140px;
        height: 4px;
        background: rgba(128, 128, 128, 0.2);
        border-radius: 2px;
        overflow: hidden;
        opacity: 0;
        animation: fadeIn 0.8s ease-out 0.4s forwards;
    }

    .app-loading-bar {
        width: 100%;
        height: 100%;
        background: var(--loading-primary);
        transform: translateX(-100%);
        animation: loading 1.5s infinite ease-in-out;
        border-radius: 2px;
    }

    /* Animations */
    @keyframes float {
        0%, 100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-6px);
        }
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes loading {
        0% {
            transform: translateX(-100%);
        }

        50% {
            transform: translateX(0);
        }

        100% {
            transform: translateX(100%);
        }
    }
</style>

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\index.html
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\manifest.json
================================================================================
{
  "name": "Storhaugen Eats",
  "short_name": "Storhaugen",
  "start_url": "./",
  "display": "standalone",
  "background_color": "#0f172a",
  "theme_color": "#0f172a",
  "scope": "/StorhaugenWebsite/",
  "orientation": "portrait",
  "icons": [
    {
      "src": "icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\manifest.json
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\App.razor
================================================================================
@using Microsoft.AspNetCore.Components.Authorization
@using StorhaugenWebsite.Shared
@using StorhaugenWebsite.Services
@using MudBlazor

@inject AuthenticationStateProvider AuthStateProvider
@inject IThemeService ThemeService
@inject IDeviceStateService DeviceState
@inject IAuthService AuthService
@inject ICollectionStateService CollectionState

<MudThemeProvider @ref="_themeProvider" @bind-IsDarkMode="@_isDarkMode" Theme="_currentTheme" />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

@if (!_isAuthReady)
{
    <div class="d-flex justify-center align-center" style="height: 100vh; width: 100vw; background-color: var(--mud-palette-background);">
        <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
    </div>
}
else
{
    <CascadingAuthenticationState>
        <Router AppAssembly="@typeof(App).Assembly">
            <Found Context="routeData">
                <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
                    <NotAuthorized>
                        <LayoutView Layout="@typeof(MainLayout)">
                             <div class="login-required-container">
                                 <div class="empty-state">
                                     <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Large" />
                                     <h3>Vennligst logg inn</h3>
                                     <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="login">G til innlogging</MudButton>
                                 </div>
                             </div>
                        </LayoutView>
                    </NotAuthorized>
                </AuthorizeRouteView>
                <FocusOnNavigate RouteData="@routeData" Selector="h1" />
            </Found>
            <NotFound>
                <PageTitle>Not found</PageTitle>
                <LayoutView Layout="@typeof(MainLayout)">
                    <MudContainer MaxWidth="MaxWidth.Small" Class="d-flex flex-column align-center justify-center" Style="height: 60vh;">
                        <MudText Typo="Typo.h4">Page Not Found</MudText>
                    </MudContainer>
                </LayoutView>
            </NotFound>
        </Router>
    </CascadingAuthenticationState>
}

@code {
    private MudThemeProvider? _themeProvider;
    private MudTheme _currentTheme = new();
    private bool _isDarkMode = false;
    
    // Flag to hold the UI until auth is ready
    private bool _isAuthReady = false;

    protected override async Task OnInitializedAsync()
    {
        // 1. Initialize synchronous/basic services
        await DeviceState.InitializeAsync();
        
        // 2. Wait for Auth to restore from LocalStorage
        // We capture the state here so we can check it immediately below
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        
        // 3. IF LOGGED IN: Initialize Collection State immediately
        // This prevents UI flash because we wait for this
        // to finish before setting _isAuthReady = true.
        if (authState.User.Identity?.IsAuthenticated == true)
        {
            await CollectionState.InitializeAsync();
        }
        
        // 4. Mark as ready - UI will now render
        _isAuthReady = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ThemeService.InitializeAsync();
            ThemeService.OnThemeChanged += OnThemeChanged;
            
            _currentTheme = ThemeService.GetCurrentTheme();
            _isDarkMode = ThemeService.IsDarkMode;
            StateHasChanged();
        }
    }

    private void OnThemeChanged()
    {
        _currentTheme = ThemeService.GetCurrentTheme();
        _isDarkMode = ThemeService.IsDarkMode;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        ThemeService.OnThemeChanged -= OnThemeChanged;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\App.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Program.cs
================================================================================
using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using MudBlazor.Services;
using StorhaugenWebsite;
using StorhaugenWebsite.Services;
using StorhaugenWebsite.ApiClient;
using Supabase;
using Microsoft.AspNetCore.Components.Authorization;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");
builder.RootComponents.Add<HeadOutlet>("head::after");

// API HttpClient - Configure base URL for API calls
#if DEBUG
var apiBaseUrl = "https://localhost:64797"; // Local API for development
#else
var apiBaseUrl = "https://storhaugen-eats-api-a7ckh4hwdvcagcb7.westeurope-01.azurewebsites.net"; // Azure API for production
#endif

builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(apiBaseUrl) });

// MudBlazor
builder.Services.AddMudServices();

// Supabase Client
var supabaseUrl = "https://ithuvxvsoozmvdicxedx.supabase.co";
var supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0";

var options = new SupabaseOptions
{
    AutoConnectRealtime = false // We don't need realtime in the frontend
};

builder.Services.AddScoped(sp => new Supabase.Client(supabaseUrl, supabaseAnonKey, options));

// Authentication & API Services
builder.Services.AddScoped<IAuthService, SupabaseAuthService>();
builder.Services.AddScoped<IApiClient, ApiClient>();
builder.Services.AddAuthorizationCore();
builder.Services.AddScoped<AuthenticationStateProvider, SupabaseAuthStateProvider>();
// Other Services
builder.Services.AddScoped<IDeviceStateService, DeviceStateService>();
builder.Services.AddScoped<IThemeService, ThemeService>();
builder.Services.AddScoped<IOcrService, TesseractOcrService>();

// Food Service - Uses ApiClient now for backward compatibility with existing pages
builder.Services.AddScoped<IFoodService, FoodService>();

// User-centric services (new architecture)
builder.Services.AddScoped<IUserRecipeService, UserRecipeService>();
builder.Services.AddScoped<IUserFriendshipService, UserFriendshipService>();
builder.Services.AddScoped<IActivityFeedService, ActivityFeedService>();
builder.Services.AddScoped<ICollectionStateService, CollectionStateService>();
builder.Services.AddSingleton<IUserColorService, UserColorService>();

// HelloFresh sync service (triggers background sync on login)
builder.Services.AddScoped<IHelloFreshSyncService, HelloFreshSyncService>();

var host = builder.Build();
var authService = host.Services.GetRequiredService<IAuthService>();
await authService.InitializeAsync();

// Initialize collection state (will auto-load after auth)
var collectionStateService = host.Services.GetRequiredService<ICollectionStateService>();
await collectionStateService.InitializeAsync();

await host.RunAsync();


================================================================================
FILE END: \StorhaugenWebsite\Program.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\StorhaugenWebsite.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <OverrideHtmlAssetPlaceholders>true</OverrideHtmlAssetPlaceholders>
  </PropertyGroup>

	<Target Name="Make404" AfterTargets="Publish">
		<Copy SourceFiles="$(PublishDir)wwwroot\index.html" DestinationFiles="$(PublishDir)wwwroot\404.html" />
	</Target>

	<ItemGroup>
	  <Compile Remove="Shared\RatingColorExtensions.cs" />
	</ItemGroup>

  <ItemGroup>
    <Content Remove="Components\AddFood.razor" />
    <Content Remove="Components\Archived.razor" />
    <Content Remove="Components\FoodDetail.razor" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="Shared\Extensions\RatingColorExtensions.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Components.Authorization" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="10.0.0" PrivateAssets="all" />
    <PackageReference Include="MudBlazor" Version="8.15.0" />
	  
	<PackageReference Include="Supabase" Version="1.1.1" />
	<PackageReference Include="Supabase.Gotrue" Version="6.0.3" />
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Brokers\" />
    <Folder Include="wwwroot\images\" />
  </ItemGroup>

  <ItemGroup>
    <Content Update="wwwroot\.nojekyll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenWebsite\StorhaugenWebsite.csproj
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\_Imports.razor
================================================================================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components.WebAssembly.Http
@using Microsoft.JSInterop
@using MudBlazor
@using StorhaugenWebsite
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Services


================================================================================
FILE END: \StorhaugenWebsite\_Imports.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// ACTIVITY FEED DTOs
// ==========================================

/// <summary>
/// DTO for a single activity feed item.
/// </summary>
public class ActivityFeedItemDto
{
    public Guid Id { get; set; }

    // User who performed the action
    public Guid UserId { get; set; }
    public string UserDisplayName { get; set; } = string.Empty;
    public string? UserAvatarUrl { get; set; }

    /// <summary>
    /// Type of activity: "rated", "added", "published".
    /// </summary>
    public string ActivityType { get; set; } = string.Empty;

    /// <summary>
    /// Type of target: "user_recipe", "global_recipe".
    /// </summary>
    public string TargetType { get; set; } = string.Empty;

    public Guid TargetId { get; set; }

    // Denormalized data for display
    public string? RecipeName { get; set; }
    public string? RecipeImageUrl { get; set; }
    public decimal? RatingScore { get; set; }

    public DateTime CreatedAt { get; set; }

    /// <summary>
    /// Human-readable activity description.
    /// Example: "Sarah rated Spaghetti Carbonara 9/10"
    /// </summary>
    public string Description => GenerateDescription();

    private string GenerateDescription()
    {
        return ActivityType switch
        {
            "rated" => $"{UserDisplayName} rated {RecipeName ?? "a recipe"} {RatingScore?.ToString("0.0")}/10",
            "added" => $"{UserDisplayName} added {RecipeName ?? "a new recipe"}",
            "published" => $"{UserDisplayName} published {RecipeName ?? "a recipe"} to the community",
            _ => $"{UserDisplayName} did something"
        };
    }
}

/// <summary>
/// Query parameters for the activity feed.
/// </summary>
public class ActivityFeedQuery
{
    /// <summary>
    /// Filter by activity types. If empty, all types are included.
    /// </summary>
    public List<string>? Types { get; set; }

    /// <summary>
    /// Only show activities from specific users. If empty, shows all friends.
    /// </summary>
    public List<Guid>? UserIds { get; set; }

    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}

/// <summary>
/// Paged result for activity feed.
/// </summary>
public class ActivityFeedPagedResult
{
    public List<ActivityFeedItemDto> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasMore => Page < TotalPages;
}

/// <summary>
/// Summary of recent activity for a user.
/// </summary>
public class ActivitySummaryDto
{
    public int TotalActivities { get; set; }
    public int RecipesAdded { get; set; }
    public int RecipesRated { get; set; }
    public int RecipesPublished { get; set; }
    public DateTime? LastActivityDate { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\CollectionDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// COLLECTION DTOs - Recipe Organization
// ==========================================

/// <summary>
/// DTO for returning collection data.
/// </summary>
public class CollectionDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }

    /// <summary>
    /// Visibility: "private" (members only), "friends" (owner's friends can view), "public" (anyone can view)
    /// </summary>
    public string Visibility { get; set; } = "private";

    /// <summary>
    /// Share code for public/friends collections. Can be used to generate share links.
    /// </summary>
    public string? ShareCode { get; set; }

    public Guid OwnerId { get; set; }
    public string OwnerDisplayName { get; set; } = string.Empty;
    public string? OwnerAvatarUrl { get; set; }

    public int RecipeCount { get; set; }
    public int MemberCount { get; set; }

    /// <summary>
    /// Whether the current user is the owner of this collection.
    /// </summary>
    public bool IsOwner { get; set; }

    /// <summary>
    /// Whether the current user is a member of this collection.
    /// </summary>
    public bool IsMember { get; set; }

    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    /// <summary>
    /// Members of the collection.
    /// </summary>
    public List<CollectionMemberDto> Members { get; set; } = new();
}

/// <summary>
/// Simplified collection reference for use in recipe DTOs.
/// </summary>
public class CollectionReferenceDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
}

/// <summary>
/// DTO for collection members.
/// </summary>
public class CollectionMemberDto
{
    public Guid UserId { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public bool IsOwner { get; set; }
    public DateTime CreatedAt { get; set; }
}

/// <summary>
/// DTO for creating a new collection.
/// </summary>
public class CreateCollectionDto
{
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Visibility { get; set; } = "private";
}

/// <summary>
/// DTO for updating a collection.
/// </summary>
public class UpdateCollectionDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public string? Visibility { get; set; }
}

/// <summary>
/// DTO for adding a recipe to a collection.
/// </summary>
public class AddRecipeToCollectionDto
{
    public Guid UserRecipeId { get; set; }
}

/// <summary>
/// DTO for adding a member to a collection.
/// </summary>
public class AddCollectionMemberDto
{
    /// <summary>
    /// The user's unique share ID or email.
    /// </summary>
    public string UserIdentifier { get; set; } = string.Empty;
}

/// <summary>
/// Query parameters for getting recipes in a collection.
/// </summary>
public class GetCollectionRecipesQuery
{
    public string SortBy { get; set; } = "added"; // "added", "name", "rating", "date"
    public bool SortDescending { get; set; } = true;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public string? Search { get; set; }
}

/// <summary>
/// Result for collection recipes with pagination.
/// </summary>
public class CollectionRecipesResult
{
    public CollectionDto Collection { get; set; } = null!;
    public List<UserRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\CollectionDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// USER FRIENDSHIP DTOs
// ==========================================

/// <summary>
/// DTO for a single friendship.
/// </summary>
public class UserFriendshipDto
{
    public Guid Id { get; set; }
    public Guid FriendUserId { get; set; }
    public string FriendDisplayName { get; set; } = string.Empty;
    public string? FriendAvatarUrl { get; set; }
    public string FriendShareId { get; set; } = string.Empty;

    /// <summary>
    /// Status from the current user's perspective:
    /// - "accepted" - You are friends
    /// - "pending_sent" - You sent a request, waiting for response
    /// - "pending_received" - You received a request, needs your response
    /// </summary>
    public string Status { get; set; } = string.Empty;

    public string? Message { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? RespondedAt { get; set; }

    /// <summary>
    /// Number of recipes the friend has (visible to you).
    /// </summary>
    public int RecipeCount { get; set; }
}

/// <summary>
/// DTO containing all friendship lists for a user.
/// </summary>
public class FriendshipListDto
{
    public List<UserFriendshipDto> Friends { get; set; } = new();
    public List<UserFriendshipDto> PendingSent { get; set; } = new();
    public List<UserFriendshipDto> PendingReceived { get; set; } = new();

    public int TotalFriends => Friends.Count;
    public int PendingCount => PendingSent.Count + PendingReceived.Count;
}

/// <summary>
/// DTO for sending a friend request.
/// </summary>
public class SendFriendRequestDto
{
    /// <summary>
    /// Target user ID (if known).
    /// </summary>
    public Guid? TargetUserId { get; set; }

    /// <summary>
    /// Target user's share ID (alternative to UserId).
    /// </summary>
    public string? TargetShareId { get; set; }

    /// <summary>
    /// Optional message to include with the request.
    /// </summary>
    public string? Message { get; set; }
}

/// <summary>
/// DTO for responding to a friend request.
/// </summary>
public class RespondFriendRequestDto
{
    /// <summary>
    /// Action to take: "accept" or "reject".
    /// </summary>
    public string Action { get; set; } = string.Empty;
}

/// <summary>
/// DTO for a friend's basic profile info.
/// </summary>
public class FriendProfileDto
{
    public Guid Id { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public string ShareId { get; set; } = string.Empty;
    public string? Bio { get; set; }
    public bool IsProfilePublic { get; set; }
    public List<string> FavoriteCuisines { get; set; } = new();
    public int RecipeCount { get; set; }
    public DateTime JoinedAt { get; set; }
}

/// <summary>
/// Search result for finding users to friend.
/// </summary>
public class UserSearchResultDto
{
    public Guid Id { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public string ShareId { get; set; } = string.Empty;

    /// <summary>
    /// Current friendship status with this user:
    /// - "none" - No relationship
    /// - "friends" - Already friends
    /// - "pending_sent" - You sent them a request
    /// - "pending_received" - They sent you a request
    /// </summary>
    public string FriendshipStatus { get; set; } = "none";
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class GlobalRecipeDto
{
    public Guid Id { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public string? ImageUrl { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }
    public object? NutritionData { get; set; }
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? TotalTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public List<string> Tags { get; set; } = new();
    public string? Cuisine { get; set; }

    // HelloFresh specific
    public bool IsHellofresh { get; set; }
    public string? HellofreshUuid { get; set; }
    public string? HellofreshSlug { get; set; }
    public string? HellofreshWeek { get; set; }

    // User-created
    public Guid? CreatedByUserId { get; set; }
    public string? CreatedByUserName { get; set; }

    // Aggregated ratings
    public double AverageRating { get; set; }
    public int TotalRatings { get; set; }
    public int TotalTimesAdded { get; set; }

    public DateTime CreatedAt { get; set; }
}

public class CreateGlobalRecipeDto
{
    public required string Name { get; set; }
    public string? Description { get; set; }
    public string? ImageUrl { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }
    public object? NutritionData { get; set; }
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public List<string> Tags { get; set; } = new();
    public string? Cuisine { get; set; }
}

public class BrowseGlobalRecipesQuery
{
    public string? Search { get; set; }
    public string? Cuisine { get; set; }
    public string? Difficulty { get; set; }
    public int? MaxPrepTime { get; set; }
    public List<string>? Tags { get; set; }
    public bool HellofreshOnly { get; set; } = false;
    public string? HellofreshWeek { get; set; } // e.g., "2026-W02" for filtering by week
    public string SortBy { get; set; } = "popular"; // popular, newest, rating, name
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}

public class GlobalRecipePagedResult
{
    public List<GlobalRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\HelloFreshDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class HelloFreshRawResponse
{
    public PageProps PageProps { get; set; }
}

public class PageProps
{
    public SsrPayload SsrPayload { get; set; }
}

public class SsrPayload
{
    public List<HfCourse> Courses { get; set; } = new();
}

public class HfCourse
{
    public HfRecipe Recipe { get; set; }
}

public class HfRecipe
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Headline { get; set; }
    public string ImageLink { get; set; } // e.g. https://d3hvwccx09j84u.cloudfront.net/...
    public string PrepTime { get; set; }  // e.g. PT20M
    public List<HfIngredient> Ingredients { get; set; }
}

public class HfIngredient
{
    public string Name { get; set; }
    public string ImagePath { get; set; }
}

public class HelloFreshSyncResult
{
    public string Message { get; set; } = string.Empty;
    public int RecipesAdded { get; set; }
    public int RecipesUpdated { get; set; }
}

public class HelloFreshSyncStatus
{
    public DateTime? LastSync { get; set; }
    public string? Status { get; set; }
    public int RecipesAdded { get; set; }
    public int RecipesUpdated { get; set; }
    public string? BuildId { get; set; }
    public string? WeeksSynced { get; set; }
    public string? ErrorMessage { get; set; }
    public string? Message { get; set; }
}

================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\HelloFreshDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UploadImageDto
{
    public required string FileName { get; set; }
    public required string Base64Data { get; set; }
    public string Bucket { get; set; } = "recipe-images";
}

public class UploadImageResultDto
{
    public required string Url { get; set; }
    public required string FileName { get; set; }
}

public class DeleteImageDto
{
    public required string FileName { get; set; }
    public string Bucket { get; set; } = "recipe-images";
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// TAG DTOs - Personal Recipe Organization
// ==========================================

/// <summary>
/// DTO representing a recipe tag/category.
/// </summary>
public class TagDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
    public string? Icon { get; set; }
    public int RecipeCount { get; set; }
    public DateTime CreatedAt { get; set; }
}

/// <summary>
/// DTO for creating a new tag.
/// </summary>
public class CreateTagDto
{
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
    public string? Icon { get; set; }
}

/// <summary>
/// DTO for updating a tag.
/// </summary>
public class UpdateTagDto
{
    public string? Name { get; set; }
    public string? Color { get; set; }
    public string? Icon { get; set; }
}

/// <summary>
/// DTO for adding/removing tags from a recipe.
/// </summary>
public class UpdateRecipeTagsDto
{
    /// <summary>
    /// List of tag IDs to set on the recipe (replaces existing tags).
    /// </summary>
    public List<Guid> TagIds { get; set; } = new();
}

/// <summary>
/// Simplified tag reference for use in recipe DTOs.
/// </summary>
public class TagReferenceDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UserDto
{
    public Guid Id { get; set; }
    public required string Email { get; set; }
    public required string DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
    public required string UniqueShareId { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class CreateUserDto
{
    public required string Email { get; set; }
    public required string DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
}

public class UpdateUserDto
{
    public string? DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UserRatingDto
{
    public Guid? GlobalRecipeId { get; set; }
    public Guid? UserRecipeId { get; set; }
    public string RecipeTitle { get; set; } = "";
    public string? ImageUrl { get; set; }
    public decimal Score { get; set; }
    public string? Comment { get; set; }
    public DateTime RatedAt { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// USER RECIPE DTOs
// ==========================================

/// <summary>
/// DTO for returning user recipe data.
/// </summary>
public class UserRecipeDto
{
    public Guid Id { get; set; }
    public Guid UserId { get; set; }
    public string UserDisplayName { get; set; } = string.Empty;
    public string? UserAvatarUrl { get; set; }

    // Recipe data (resolved from local or global)
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }

    // HelloFresh metadata (from global recipe if linked)
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public string? Cuisine { get; set; }
    public List<string> RecipeTags { get; set; } = new();
    public object? NutritionData { get; set; }
    public bool IsHellofresh { get; set; }
    public string? HellofreshWeek { get; set; }

    // Link status
    public Guid? GlobalRecipeId { get; set; }
    public string? GlobalRecipeName { get; set; }
    public bool IsLinkedToGlobal => GlobalRecipeId.HasValue;
    public bool IsPublished { get; set; }

    // Metadata
    public string Visibility { get; set; } = "private";
    public string? PersonalNotes { get; set; }
    public bool IsArchived { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    // Ratings
    public decimal? MyRating { get; set; }
    public double AverageRating { get; set; }
    public int RatingCount { get; set; }
    public Dictionary<string, decimal?> MemberRatings { get; set; } = new();

    // Tags (personal organization)
    public List<TagReferenceDto> Tags { get; set; } = new();

    // Collections this recipe belongs to
    public List<CollectionReferenceDto> Collections { get; set; } = new();
}

/// <summary>
/// DTO for creating a new user recipe.
/// </summary>
public class CreateUserRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public object? Ingredients { get; set; }
    public string? PersonalNotes { get; set; }
    public Guid? GlobalRecipeId { get; set; }
    public string Visibility { get; set; } = "private";

    // HelloFresh metadata (stored locally when copying)
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public string? Cuisine { get; set; }
    public List<string>? Tags { get; set; }
    public object? NutritionData { get; set; }

    // Tags (personal organization)
    public List<Guid>? TagIds { get; set; }

    // Collections to add this recipe to
    public List<Guid>? CollectionIds { get; set; }

    // --- Dictionary of UserID -> Score (0.0-10.0) ---
    public Dictionary<Guid, decimal>? MemberRatings { get; set; }
}

/// <summary>
/// DTO for updating a user recipe.
/// </summary>
public class UpdateUserRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public object? Ingredients { get; set; }
    public string? PersonalNotes { get; set; }
    public string? Visibility { get; set; }

    // Metadata fields (editable for non-HelloFresh, non-published recipes)
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public string? Cuisine { get; set; }

    // Tags (personal organization)
    public List<Guid>? TagIds { get; set; }

    // Collections (replaces current collections if provided)
    public List<Guid>? CollectionIds { get; set; }
}

/// <summary>
/// DTO for publishing a recipe result.
/// </summary>
public class PublishRecipeResultDto
{
    public UserRecipeDto UserRecipe { get; set; } = null!;
    public Guid GlobalRecipeId { get; set; }
    public string Message { get; set; } = string.Empty;
}

/// <summary>
/// Query parameters for getting user recipes.
/// </summary>
public class GetUserRecipesQuery
{
    public string? Visibility { get; set; }
    public bool IncludeArchived { get; set; } = false;
    public string SortBy { get; set; } = "date";
    public bool SortDescending { get; set; } = true;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;

    // Tag filtering
    public List<Guid>? TagIds { get; set; }
    public string? Search { get; set; }
}

/// <summary>
/// Paged result for user recipes.
/// </summary>
public class UserRecipePagedResult
{
    public List<UserRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.ComponentModel.Annotations" Version="5.0.0" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj
================================================================================

