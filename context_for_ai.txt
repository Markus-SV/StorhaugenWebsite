================================================================================
PROJECT CONTEXT FILE
Generated on: 12/13/2025 21:14:04
================================================================================
PROJECT STRUCTURE:
==================
\database\schema.sql
\StorhaugenEats.API\Controllers\FeedController.cs
\StorhaugenEats.API\Controllers\FriendshipsController.cs
\StorhaugenEats.API\Controllers\GlobalRecipesController.cs
\StorhaugenEats.API\Controllers\HelloFreshController.cs
\StorhaugenEats.API\Controllers\HouseholdFriendshipsController.cs
\StorhaugenEats.API\Controllers\HouseholdRecipesController.cs
\StorhaugenEats.API\Controllers\HouseholdsController.cs
\StorhaugenEats.API\Controllers\RatingsController.cs
\StorhaugenEats.API\Controllers\StorageController.cs
\StorhaugenEats.API\Controllers\TagsController.cs
\StorhaugenEats.API\Controllers\UserRecipesController.cs
\StorhaugenEats.API\Controllers\UsersController.cs
\StorhaugenEats.API\Data\AppDbContext.cs
\StorhaugenEats.API\Helpers\JsonHelper.cs
\StorhaugenEats.API\Models\ActivityFeedItem.cs
\StorhaugenEats.API\Models\EtlSyncLog.cs
\StorhaugenEats.API\Models\GlobalRecipe.cs
\StorhaugenEats.API\Models\Household.cs
\StorhaugenEats.API\Models\HouseholdFriendship.cs
\StorhaugenEats.API\Models\HouseholdInvite.cs
\StorhaugenEats.API\Models\HouseholdMember.cs
\StorhaugenEats.API\Models\HouseholdRecipe.cs
\StorhaugenEats.API\Models\Rating.cs
\StorhaugenEats.API\Models\RecipeTag.cs
\StorhaugenEats.API\Models\User.cs
\StorhaugenEats.API\Models\UserFriendship.cs
\StorhaugenEats.API\Models\UserRecipe.cs
\StorhaugenEats.API\Services\ActivityFeedService.cs
\StorhaugenEats.API\Services\CurrentUserService.cs
\StorhaugenEats.API\Services\GlobalRecipeService.cs
\StorhaugenEats.API\Services\HelloFreshScraperService.cs
\StorhaugenEats.API\Services\HouseholdRecipeService.cs
\StorhaugenEats.API\Services\HouseholdService.cs
\StorhaugenEats.API\Services\IActivityFeedService.cs
\StorhaugenEats.API\Services\ICurrentUserService.cs
\StorhaugenEats.API\Services\IGlobalRecipeService.cs
\StorhaugenEats.API\Services\IHelloFreshScraperService.cs
\StorhaugenEats.API\Services\IHouseholdRecipeService.cs
\StorhaugenEats.API\Services\IHouseholdService.cs
\StorhaugenEats.API\Services\IRatingService.cs
\StorhaugenEats.API\Services\IStorageService.cs
\StorhaugenEats.API\Services\ITagService.cs
\StorhaugenEats.API\Services\IUserFriendshipService.cs
\StorhaugenEats.API\Services\IUserRecipeService.cs
\StorhaugenEats.API\Services\IUserService.cs
\StorhaugenEats.API\Services\RatingService.cs
\StorhaugenEats.API\Services\SupabaseStorageService.cs
\StorhaugenEats.API\Services\TagService.cs
\StorhaugenEats.API\Services\UserFriendshipService.cs
\StorhaugenEats.API\Services\UserRecipeService.cs
\StorhaugenEats.API\Services\UserService.cs
\StorhaugenEats.API\appsettings.json
\StorhaugenEats.API\Program.cs
\StorhaugenEats.API\StorhaugenEats.API.csproj
\StorhaugenWebsite\ApiClient\ApiClient.cs
\StorhaugenWebsite\ApiClient\IApiClient.cs
\StorhaugenWebsite\Components\ActivityFeed.razor
\StorhaugenWebsite\Components\HouseholdMembersDialog.razor
\StorhaugenWebsite\Components\HouseholdSelector.razor
\StorhaugenWebsite\Components\InviteMemberDialog.razor
\StorhaugenWebsite\Components\MyRecipes.razor
\StorhaugenWebsite\Components\NotificationBell.razor
\StorhaugenWebsite\Components\PublishRecipeDialog.razor
\StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
\StorhaugenWebsite\Models\AppConfig.cs
\StorhaugenWebsite\Models\DeviceSettings.cs
\StorhaugenWebsite\Models\FoodItem.cs
\StorhaugenWebsite\Models\ThemeColors.cs
\StorhaugenWebsite\Pages\AddFood.razor
\StorhaugenWebsite\Pages\Archived.razor
\StorhaugenWebsite\Pages\Browse.razor
\StorhaugenWebsite\Pages\BrowseDetails.razor
\StorhaugenWebsite\Pages\CookBook.razor
\StorhaugenWebsite\Pages\FoodDetails.razor
\StorhaugenWebsite\Pages\FriendRatings.razor
\StorhaugenWebsite\Pages\Friends.razor
\StorhaugenWebsite\Pages\Home.razor
\StorhaugenWebsite\Pages\Household.razor
\StorhaugenWebsite\Pages\Login.razor
\StorhaugenWebsite\Pages\NotFound.razor
\StorhaugenWebsite\Pages\Settings.razor
\StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
\StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
\StorhaugenWebsite\Services\Authentication\IAuthService.cs
\StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
\StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
\StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
\StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
\StorhaugenWebsite\Services\Food\FoodService.cs
\StorhaugenWebsite\Services\Food\IFoodService.cs
\StorhaugenWebsite\Services\Household\HouseholdStateService.cs
\StorhaugenWebsite\Services\Household\IHouseholdStateService.cs
\StorhaugenWebsite\Services\Ocr\IOcrService.cs
\StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
\StorhaugenWebsite\Services\Theme\IThemeService.cs
\StorhaugenWebsite\Services\Theme\ThemeService.cs
\StorhaugenWebsite\Services\User\IUserFriendshipService.cs
\StorhaugenWebsite\Services\User\IUserRecipeService.cs
\StorhaugenWebsite\Services\User\UserFriendshipService.cs
\StorhaugenWebsite\Services\User\UserRecipeService.cs
\StorhaugenWebsite\Shared\Authorization.razor
\StorhaugenWebsite\Shared\Authorization.razor.css
\StorhaugenWebsite\Shared\MainLayout.razor
\StorhaugenWebsite\Shared\MainLayout.razor.css
\StorhaugenWebsite\wwwroot\css\app.css
\StorhaugenWebsite\wwwroot\css\Food.css
\StorhaugenWebsite\wwwroot\css\Layout.css
\StorhaugenWebsite\wwwroot\css\Login.css
\StorhaugenWebsite\wwwroot\js\deviceState.js
\StorhaugenWebsite\wwwroot\js\ocrInterop.js
\StorhaugenWebsite\wwwroot\appsettings.json
\StorhaugenWebsite\wwwroot\index.html
\StorhaugenWebsite\wwwroot\manifest.json
\StorhaugenWebsite\App.razor
\StorhaugenWebsite\Program.cs
\StorhaugenWebsite\StorhaugenWebsite.csproj
\StorhaugenWebsite\_Imports.razor
\StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
\StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
\StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
\StorhaugenWebsite.Shared\DTOs\HouseholdAggregationDTOs.cs
\StorhaugenWebsite.Shared\DTOs\HouseholdDTOs.cs
\StorhaugenWebsite.Shared\DTOs\HouseholdFriendshipDTOs.cs
\StorhaugenWebsite.Shared\DTOs\HouseholdRecipeDTOs.cs
\StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
\StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
\StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj




================================================================================
FILE START: \database\schema.sql
================================================================================
-- ============================================
-- Storhaugen Eats - Multi-Tenant Database Schema
-- Database: PostgreSQL (Supabase)
-- ============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLE: households
-- Represents a group/family sharing a meal list
-- ============================================
CREATE TABLE households (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    leader_id UUID, -- Foreign key to users (set after users table created)
    settings JSONB DEFAULT '{}', -- Theme, preferences, etc.
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- TABLE: users
-- Individual user accounts (integrated with Supabase Auth)
-- ============================================
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, -- Links to Supabase Auth
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    avatar_url TEXT,
    unique_share_id VARCHAR(12) UNIQUE NOT NULL, -- For household invites (e.g., "ABC123XYZ")
    current_household_id UUID REFERENCES households(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add foreign key constraint to households.leader_id now that users exists
ALTER TABLE households ADD CONSTRAINT fk_household_leader
    FOREIGN KEY (leader_id) REFERENCES users(id) ON DELETE SET NULL;

-- ============================================
-- TABLE: global_recipes
-- Source of truth for all HelloFresh items and public user-created recipes
-- ============================================
CREATE TABLE global_recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    image_url TEXT, -- Hosted on Supabase Storage
    ingredients JSONB NOT NULL DEFAULT '[]', -- [{ name, amount, unit, image }]
    nutrition_data JSONB, -- { calories, protein, carbs, fat, etc. }
    cook_time_minutes INTEGER,
    difficulty VARCHAR(50), -- "Easy", "Medium", "Hard"

    -- Source tracking
    is_hellofresh BOOLEAN DEFAULT FALSE,
    hellofresh_uuid VARCHAR(255) UNIQUE, -- Original HelloFresh ID
    created_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL, -- NULL if HelloFresh

    -- Visibility
    is_public BOOLEAN DEFAULT FALSE, -- Only relevant for user-created items

    -- Aggregated ratings (denormalized for performance)
    average_rating DECIMAL(3,2) DEFAULT 0.00, -- Calculated from ratings table
    rating_count INTEGER DEFAULT 0,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for common queries
CREATE INDEX idx_global_recipes_hellofresh ON global_recipes(is_hellofresh) WHERE is_hellofresh = TRUE;
CREATE INDEX idx_global_recipes_public ON global_recipes(is_public) WHERE is_public = TRUE;
CREATE INDEX idx_global_recipes_rating ON global_recipes(average_rating DESC);
CREATE INDEX idx_global_recipes_hellofresh_uuid ON global_recipes(hellofresh_uuid);

-- ============================================
-- TABLE: household_recipes
-- Local instances of recipes in a household's list
-- Implements "Reference vs Fork" logic via global_recipe_id
-- ============================================
CREATE TABLE household_recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,

    -- Reference/Fork Logic
    global_recipe_id UUID REFERENCES global_recipes(id) ON DELETE SET NULL,
    -- If global_recipe_id IS NOT NULL → "Linked Mode" (display global data + personal notes)
    -- If global_recipe_id IS NULL → "Forked Mode" (completely local data)

    -- Local data (used when forked, or as personal notes when linked)
    local_title VARCHAR(255), -- Only used if forked
    local_description TEXT,
    local_ingredients JSONB, -- Only used if forked
    local_image_url TEXT, -- Only used if forked
    personal_notes TEXT, -- ALWAYS displayed (even in linked mode)

    -- Metadata
    added_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    is_archived BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Ensure household can't have duplicate global recipes (unless forked)
    UNIQUE NULLS NOT DISTINCT (household_id, global_recipe_id)
);

-- Indexes
CREATE INDEX idx_household_recipes_household ON household_recipes(household_id);
CREATE INDEX idx_household_recipes_global ON household_recipes(global_recipe_id);
CREATE INDEX idx_household_recipes_archived ON household_recipes(is_archived);

-- ============================================
-- TABLE: ratings
-- User ratings for global recipes
-- ============================================
CREATE TABLE ratings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    global_recipe_id UUID NOT NULL REFERENCES global_recipes(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    score INTEGER NOT NULL CHECK (score >= 0 AND score <= 10),
    comment TEXT,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- One rating per user per recipe
    UNIQUE(global_recipe_id, user_id)
);

-- Indexes
CREATE INDEX idx_ratings_global_recipe ON ratings(global_recipe_id);
CREATE INDEX idx_ratings_user ON ratings(user_id);

-- ============================================
-- TABLE: household_invites
-- Pending invitations to join households
-- ============================================
CREATE TABLE household_invites (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,
    invited_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    invited_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'

    -- For merge requests (when invited user already has a household)
    merge_requested BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(household_id, invited_user_id)
);

-- ============================================
-- TABLE: etl_sync_log
-- Tracks HelloFresh ETL scraper runs
-- ============================================
CREATE TABLE etl_sync_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sync_type VARCHAR(50) DEFAULT 'hellofresh', -- Future: other sources
    status VARCHAR(20), -- 'success', 'failed', 'partial'
    recipes_added INTEGER DEFAULT 0,
    recipes_updated INTEGER DEFAULT 0,
    error_message TEXT,
    build_id VARCHAR(255), -- HelloFresh build ID used
    weeks_synced VARCHAR(255), -- e.g., "2025-W51,2025-W52"

    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Index for checking last sync
CREATE INDEX idx_etl_sync_log_started ON etl_sync_log(started_at DESC);

-- ============================================
-- FUNCTIONS & TRIGGERS
-- ============================================

-- Function: Update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to all tables with updated_at
CREATE TRIGGER update_households_updated_at BEFORE UPDATE ON households
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_global_recipes_updated_at BEFORE UPDATE ON global_recipes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_household_recipes_updated_at BEFORE UPDATE ON household_recipes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ratings_updated_at BEFORE UPDATE ON ratings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function: Recalculate global recipe ratings
CREATE OR REPLACE FUNCTION recalculate_global_recipe_rating(recipe_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE global_recipes
    SET
        average_rating = COALESCE((
            SELECT AVG(score)::DECIMAL(3,2)
            FROM ratings
            WHERE global_recipe_id = recipe_id
        ), 0.00),
        rating_count = (
            SELECT COUNT(*)
            FROM ratings
            WHERE global_recipe_id = recipe_id
        )
    WHERE id = recipe_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-update ratings when rating is inserted/updated/deleted
CREATE OR REPLACE FUNCTION update_recipe_rating_on_change()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM recalculate_global_recipe_rating(OLD.global_recipe_id);
    ELSE
        PERFORM recalculate_global_recipe_rating(NEW.global_recipe_id);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ratings_update_recipe_stats
AFTER INSERT OR UPDATE OR DELETE ON ratings
FOR EACH ROW EXECUTE FUNCTION update_recipe_rating_on_change();

-- ============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- Enable RLS for multi-tenancy security
-- ============================================

-- Enable RLS on all tables
ALTER TABLE households ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE global_recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE household_recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE household_invites ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own data
CREATE POLICY users_select_own ON users
    FOR SELECT USING (auth.uid() = id);

-- Policy: Users can update their own data
CREATE POLICY users_update_own ON users
    FOR UPDATE USING (auth.uid() = id);

-- Policy: Users can read their household
CREATE POLICY households_select_member ON households
    FOR SELECT USING (
        id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Household leaders can update household
CREATE POLICY households_update_leader ON households
    FOR UPDATE USING (leader_id = auth.uid());

-- Policy: Anyone can read public global recipes
CREATE POLICY global_recipes_select_public ON global_recipes
    FOR SELECT USING (is_hellofresh = TRUE OR is_public = TRUE);

-- Policy: Users can read their household's recipes
CREATE POLICY household_recipes_select_own ON household_recipes
    FOR SELECT USING (
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Users can insert/update/delete recipes in their household
CREATE POLICY household_recipes_modify_own ON household_recipes
    FOR ALL USING (
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- Policy: Users can read all ratings for public recipes
CREATE POLICY ratings_select_all ON ratings
    FOR SELECT USING (TRUE);

-- Policy: Users can insert/update their own ratings
CREATE POLICY ratings_modify_own ON ratings
    FOR ALL USING (user_id = auth.uid());

-- Policy: Users can see invites to their household or invites they sent
CREATE POLICY invites_select_relevant ON household_invites
    FOR SELECT USING (
        invited_user_id = auth.uid() OR
        invited_by_user_id = auth.uid() OR
        household_id IN (SELECT current_household_id FROM users WHERE id = auth.uid())
    );

-- ============================================
-- INITIAL DATA & HELPER FUNCTIONS
-- ============================================

-- Function: Generate unique share ID (12 chars, alphanumeric)
CREATE OR REPLACE FUNCTION generate_unique_share_id()
RETURNS VARCHAR(12) AS $$
DECLARE
    chars VARCHAR := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- Exclude confusing chars
    result VARCHAR := '';
    i INTEGER;
    random_index INTEGER;
BEGIN
    FOR i IN 1..12 LOOP
        random_index := floor(random() * length(chars) + 1)::INTEGER;
        result := result || substr(chars, random_index, 1);
    END LOOP;
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function: Create household and set user as leader
CREATE OR REPLACE FUNCTION create_household_for_user(
    user_id UUID,
    household_name VARCHAR(255)
)
RETURNS UUID AS $$
DECLARE
    new_household_id UUID;
BEGIN
    -- Create household
    INSERT INTO households (name, leader_id)
    VALUES (household_name, user_id)
    RETURNING id INTO new_household_id;

    -- Assign user to household
    UPDATE users
    SET current_household_id = new_household_id
    WHERE id = user_id;

    RETURN new_household_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VIEWS FOR COMMON QUERIES
-- ============================================

-- View: Household recipes with global data joined
CREATE OR REPLACE VIEW household_recipes_full AS
SELECT
    hr.id,
    hr.household_id,
    hr.global_recipe_id,
    hr.personal_notes,
    hr.is_archived,
    hr.added_by_user_id,
    hr.created_at,
    hr.updated_at,

    -- Display logic: Use global data if linked, local data if forked
    COALESCE(hr.local_title, gr.title) AS title,
    COALESCE(hr.local_description, gr.description) AS description,
    COALESCE(hr.local_image_url, gr.image_url) AS image_url,
    COALESCE(hr.local_ingredients, gr.ingredients) AS ingredients,

    -- Global recipe metadata (NULL if forked)
    gr.is_hellofresh,
    gr.average_rating,
    gr.rating_count,
    gr.nutrition_data,
    gr.cook_time_minutes,
    gr.difficulty,

    -- Linked/Forked indicator
    CASE
        WHEN hr.global_recipe_id IS NOT NULL THEN 'linked'
        ELSE 'forked'
    END AS recipe_mode

FROM household_recipes hr
LEFT JOIN global_recipes gr ON hr.global_recipe_id = gr.id;

COMMENT ON VIEW household_recipes_full IS 'Combines household recipes with global recipe data, handling linked vs forked logic';

-- ============================================
-- INDEXES FOR PERFORMANCE
-- ============================================

-- Additional indexes for joins
CREATE INDEX idx_users_household ON users(current_household_id);
CREATE INDEX idx_users_share_id ON users(unique_share_id);

-- ============================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================

COMMENT ON TABLE households IS 'Groups/families sharing a meal list';
COMMENT ON TABLE users IS 'Individual user accounts linked to Supabase Auth';
COMMENT ON TABLE global_recipes IS 'Source of truth for HelloFresh and public recipes';
COMMENT ON TABLE household_recipes IS 'Local instances of recipes in household lists (linked or forked)';
COMMENT ON TABLE ratings IS 'User ratings for global recipes (1-10 scale)';
COMMENT ON TABLE household_invites IS 'Pending household invitations and merge requests';
COMMENT ON TABLE etl_sync_log IS 'Tracks HelloFresh scraper sync runs';

COMMENT ON COLUMN household_recipes.global_recipe_id IS 'NULL = forked/local recipe, NOT NULL = linked to global recipe';
COMMENT ON COLUMN household_recipes.personal_notes IS 'Always displayed, even for linked recipes';


================================================================================
FILE END: \database\schema.sql
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\FeedController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/feed")]
[Authorize]
public class FeedController : ControllerBase
{
    private readonly IActivityFeedService _activityFeedService;
    private readonly ICurrentUserService _currentUserService;

    public FeedController(
        IActivityFeedService activityFeedService,
        ICurrentUserService currentUserService)
    {
        _activityFeedService = activityFeedService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get the activity feed (friend activities).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<ActivityFeedPagedResult>> GetFeed([FromQuery] ActivityFeedQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _activityFeedService.GetFeedAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get the current user's activity history.
    /// </summary>
    [HttpGet("my-activity")]
    public async Task<ActionResult<ActivityFeedPagedResult>> GetMyActivity([FromQuery] int page = 1, [FromQuery] int pageSize = 20)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _activityFeedService.GetUserActivityAsync(userId, page, pageSize);
        return Ok(result);
    }

    /// <summary>
    /// Get a summary of the current user's activity.
    /// </summary>
    [HttpGet("summary")]
    public async Task<ActionResult<ActivitySummaryDto>> GetActivitySummary()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var summary = await _activityFeedService.GetActivitySummaryAsync(userId);
        return Ok(summary);
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\FeedController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\FriendshipsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/friendships")]
[Authorize]
public class FriendshipsController : ControllerBase
{
    private readonly IUserFriendshipService _friendshipService;
    private readonly ICurrentUserService _currentUserService;

    public FriendshipsController(
        IUserFriendshipService friendshipService,
        ICurrentUserService currentUserService)
    {
        _friendshipService = friendshipService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all friendships (accepted, pending sent, pending received).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<FriendshipListDto>> GetFriendships()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _friendshipService.GetFriendshipsAsync(userId);
        return Ok(result);
    }

    /// <summary>
    /// Get list of accepted friends only.
    /// </summary>
    [HttpGet("friends")]
    public async Task<ActionResult<List<FriendProfileDto>>> GetFriends()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var friends = await _friendshipService.GetFriendsAsync(userId);
        return Ok(friends);
    }

    /// <summary>
    /// Get a specific friendship by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserFriendshipDto>> GetFriendship(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var friendship = await _friendshipService.GetFriendshipAsync(id, userId);

        if (friendship == null)
            return NotFound(new { message = "Friendship not found" });

        return Ok(friendship);
    }

    /// <summary>
    /// Send a friend request.
    /// </summary>
    [HttpPost("request")]
    public async Task<ActionResult<UserFriendshipDto>> SendFriendRequest([FromBody] SendFriendRequestDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var friendship = await _friendshipService.SendFriendRequestAsync(userId, dto);
            return CreatedAtAction(nameof(GetFriendship), new { id = friendship.Id }, friendship);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Respond to a friend request (accept or reject).
    /// </summary>
    [HttpPost("{id}/respond")]
    public async Task<ActionResult<UserFriendshipDto>> RespondToRequest(Guid id, [FromBody] RespondFriendRequestDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var friendship = await _friendshipService.RespondToRequestAsync(id, userId, dto.Action);
            return Ok(friendship);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a friendship or cancel a pending request.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> RemoveFriendship(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _friendshipService.RemoveFriendshipAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Search for users to add as friends.
    /// </summary>
    [HttpGet("search")]
    public async Task<ActionResult<List<UserSearchResultDto>>> SearchUsers([FromQuery] string query, [FromQuery] int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(query) || query.Length < 2)
            return Ok(new List<UserSearchResultDto>());

        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var results = await _friendshipService.SearchUsersAsync(userId, query, limit);
        return Ok(results);
    }

    /// <summary>
    /// Get a user's public profile.
    /// </summary>
    [HttpGet("profile/{profileUserId}")]
    public async Task<ActionResult<FriendProfileDto>> GetUserProfile(Guid profileUserId)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var profile = await _friendshipService.GetUserProfileAsync(profileUserId, userId);

        if (profile == null)
            return NotFound(new { message = "User not found or profile is private" });

        return Ok(profile);
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\FriendshipsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\GlobalRecipesController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using StorhaugenEats.API.Services;
using StorhaugenEats.API.Helpers;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/global-recipes")]
public class GlobalRecipesController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public GlobalRecipesController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Browse global recipes with filters, search, and pagination
    /// </summary>
    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipePagedResult>> BrowseRecipes([FromQuery] BrowseGlobalRecipesQuery query)
    {
        var queryable = _context.GlobalRecipes.AsQueryable();

        // Filter: HelloFresh only
        if (query.HellofreshOnly)
        {
            queryable = queryable.Where(gr => gr.IsHellofresh);
        }

        // Filter: Search by name or description
        if (!string.IsNullOrWhiteSpace(query.Search))
        {
            var searchLower = query.Search.ToLower();
            queryable = queryable.Where(gr =>
                gr.Title.ToLower().Contains(searchLower) ||
                (gr.Description != null && gr.Description.ToLower().Contains(searchLower))
            );
        }

        // Filter: Cuisine
        if (!string.IsNullOrWhiteSpace(query.Cuisine))
        {
            queryable = queryable.Where(gr => gr.Cuisine == query.Cuisine);
        }

        // Filter: Difficulty
        if (!string.IsNullOrWhiteSpace(query.Difficulty))
        {
            queryable = queryable.Where(gr => gr.Difficulty == query.Difficulty);
        }

        // Filter: Max prep time
        if (query.MaxPrepTime.HasValue)
        {
            queryable = queryable.Where(gr =>
                gr.PrepTimeMinutes.HasValue && gr.PrepTimeMinutes.Value <= query.MaxPrepTime.Value
            );
        }

        // Filter: Tags (if any tag matches)
        // Note: Tags are stored as JSON strings, so we need to filter in memory after fetching
        // TODO: Implement PostgreSQL JSONB queries for better performance
        var filterTags = query.Tags != null && query.Tags.Count > 0 ? query.Tags : null;

        // Get total count before pagination
        var totalCount = await queryable.CountAsync();

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "newest" => queryable.OrderByDescending(gr => gr.CreatedAt),
            "rating" => queryable.OrderByDescending(gr => gr.AverageRating).ThenByDescending(gr => gr.TotalRatings),
            "popular" => queryable.OrderByDescending(gr => gr.TotalTimesAdded),
            "name" => queryable.OrderBy(gr => gr.Title),
            _ => queryable.OrderByDescending(gr => gr.TotalTimesAdded) // Default: popular
        };

        // Pagination
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        // Apply tag filtering in memory if needed
        if (filterTags != null)
        {
            recipes = recipes.Where(gr =>
            {
                var recipeTags = JsonHelper.JsonToList(gr.Tags);
                return filterTags.Any(tag => recipeTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)));
            }).ToList();
        }

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(new GlobalRecipePagedResult
        {
            Recipes = recipeDtos,
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        });
    }

    /// <summary>
    /// Get a specific global recipe by ID
    /// </summary>
    [HttpGet("{id}")]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipeDto>> GetRecipe(Guid id)
    {
        var recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstOrDefaultAsync(gr => gr.Id == id);

        if (recipe == null)
            return NotFound();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Search global recipes by name/description
    /// </summary>
    [HttpGet("search")]
    [AllowAnonymous]
    public async Task<ActionResult<List<GlobalRecipeDto>>> SearchRecipes(
        [FromQuery] string q,
        [FromQuery] int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(q))
            return BadRequest(new { message = "Search query is required" });

        if (limit > 100) limit = 100;

        var searchLower = q.ToLower();
        var recipes = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .Where(gr =>
                gr.Title.ToLower().Contains(searchLower) ||
                (gr.Description != null && gr.Description.ToLower().Contains(searchLower))
            )
            .OrderByDescending(gr => gr.TotalTimesAdded)
            .Take(limit)
            .ToListAsync();

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(recipeDtos);
    }

    /// <summary>
    /// Get only HelloFresh recipes
    /// </summary>
    [HttpGet("hellofresh")]
    [AllowAnonymous]
    public async Task<ActionResult<GlobalRecipePagedResult>> GetHelloFreshRecipes(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20,
        [FromQuery] string sortBy = "newest")
    {
        if (pageSize > 100) pageSize = 100;

        var query = _context.GlobalRecipes.Where(gr => gr.IsHellofresh);

        var totalCount = await query.CountAsync();

        // Sorting
        query = sortBy.ToLower() switch
        {
            "newest" => query.OrderByDescending(gr => gr.CreatedAt),
            "rating" => query.OrderByDescending(gr => gr.AverageRating),
            "name" => query.OrderBy(gr => gr.Title),
            _ => query.OrderByDescending(gr => gr.CreatedAt)
        };

        var recipes = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        var recipeDtos = recipes.Select(gr => MapToDto(gr)).ToList();

        return Ok(new GlobalRecipePagedResult
        {
            Recipes = recipeDtos,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        });
    }

    /// <summary>
    /// Create a user-contributed global recipe
    /// </summary>
    [HttpPost]
    [Authorize]
    public async Task<ActionResult<GlobalRecipeDto>> CreateRecipe([FromBody] CreateGlobalRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = new GlobalRecipe
        {
            Title = dto.Name,
            Description = dto.Description,
            ImageUrl = dto.ImageUrl,
            ImageUrls = JsonHelper.ListToJson(dto.ImageUrls),
            Ingredients = JsonHelper.ObjectToJson(dto.Ingredients) ?? "[]",
            NutritionData = JsonHelper.ObjectToJson(dto.NutritionData),
            PrepTimeMinutes = dto.PrepTimeMinutes,
            CookTimeMinutes = dto.CookTimeMinutes,
            TotalTimeMinutes = (dto.PrepTimeMinutes ?? 0) + (dto.CookTimeMinutes ?? 0),
            Servings = dto.Servings,
            Difficulty = dto.Difficulty,
            Tags = JsonHelper.ListToJson(dto.Tags),
            Cuisine = dto.Cuisine,
            IsHellofresh = false,
            CreatedByUserId = userId,
            AverageRating = 0,
            TotalRatings = 0,
            TotalTimesAdded = 0,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.GlobalRecipes.Add(recipe);
        await _context.SaveChangesAsync();

        // Reload with user info
        recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstAsync(gr => gr.Id == recipe.Id);

        return CreatedAtAction(nameof(GetRecipe), new { id = recipe.Id }, MapToDto(recipe));
    }

    /// <summary>
    /// Update a user-contributed recipe (only creator can update)
    /// </summary>
    [HttpPut("{id}")]
    [Authorize]
    public async Task<ActionResult<GlobalRecipeDto>> UpdateRecipe(Guid id, [FromBody] CreateGlobalRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = await _context.GlobalRecipes
            .Include(gr => gr.CreatedByUser)
            .FirstOrDefaultAsync(gr => gr.Id == id);

        if (recipe == null)
            return NotFound();

        // Only creator can update
        if (recipe.CreatedByUserId != userId)
            return Forbid();

        // Can't update HelloFresh recipes
        if (recipe.IsHellofresh)
            return BadRequest(new { message = "Cannot update HelloFresh recipes" });

        recipe.Title = dto.Name;
        recipe.Description = dto.Description;
        recipe.ImageUrl = dto.ImageUrl;
        recipe.ImageUrls = JsonHelper.ListToJson(dto.ImageUrls);
        recipe.Ingredients = JsonHelper.ObjectToJson(dto.Ingredients) ?? "[]";
        recipe.NutritionData = JsonHelper.ObjectToJson(dto.NutritionData);
        recipe.PrepTimeMinutes = dto.PrepTimeMinutes;
        recipe.CookTimeMinutes = dto.CookTimeMinutes;
        recipe.TotalTimeMinutes = (dto.PrepTimeMinutes ?? 0) + (dto.CookTimeMinutes ?? 0);
        recipe.Servings = dto.Servings;
        recipe.Difficulty = dto.Difficulty;
        recipe.Tags = JsonHelper.ListToJson(dto.Tags);
        recipe.Cuisine = dto.Cuisine;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Delete a user-contributed recipe (only creator can delete)
    /// </summary>
    [HttpDelete("{id}")]
    [Authorize]
    public async Task<IActionResult> DeleteRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var recipe = await _context.GlobalRecipes.FindAsync(id);

        if (recipe == null)
            return NotFound();

        // Only creator can delete
        if (recipe.CreatedByUserId != userId)
            return Forbid();

        // Can't delete HelloFresh recipes
        if (recipe.IsHellofresh)
            return BadRequest(new { message = "Cannot delete HelloFresh recipes" });

        // Check if any households are using this recipe
        var usageCount = await _context.HouseholdRecipes.CountAsync(hr => hr.GlobalRecipeId == id);
        if (usageCount > 0)
            return BadRequest(new { message = $"Cannot delete recipe that is used by {usageCount} household(s). They would need to fork it first." });

        _context.GlobalRecipes.Remove(recipe);
        await _context.SaveChangesAsync();

        return Ok(new { message = "Recipe deleted" });
    }

    /// <summary>
    /// Get available filter options (cuisines, difficulties, tags)
    /// </summary>
    [HttpGet("filters")]
    [AllowAnonymous]
    public async Task<IActionResult> GetFilterOptions()
    {
        var cuisines = await _context.GlobalRecipes
            .Where(gr => gr.Cuisine != null)
            .Select(gr => gr.Cuisine!)
            .Distinct()
            .OrderBy(c => c)
            .ToListAsync();

        var difficulties = await _context.GlobalRecipes
            .Where(gr => gr.Difficulty != null)
            .Select(gr => gr.Difficulty!)
            .Distinct()
            .OrderBy(d => d)
            .ToListAsync();

        // Extract tags from JSON strings (done in memory)
        var allRecipes = await _context.GlobalRecipes
            .Where(gr => gr.Tags != null && gr.Tags != "[]")
            .Select(gr => gr.Tags)
            .ToListAsync();

        var allTags = allRecipes
            .SelectMany(jsonTags => JsonHelper.JsonToList(jsonTags))
            .Distinct()
            .OrderBy(t => t)
            .ToList();

        return Ok(new
        {
            cuisines,
            difficulties,
            tags = allTags
        });
    }

    private static GlobalRecipeDto MapToDto(GlobalRecipe recipe)
    {
        return new GlobalRecipeDto
        {
            Id = recipe.Id,
            Name = recipe.Title,
            Description = recipe.Description,
            ImageUrl = recipe.ImageUrl,
            ImageUrls = JsonHelper.JsonToList(recipe.ImageUrls),
            Ingredients = JsonHelper.JsonToObject(recipe.Ingredients),
            NutritionData = JsonHelper.JsonToObject(recipe.NutritionData),
            PrepTimeMinutes = recipe.PrepTimeMinutes,
            CookTimeMinutes = recipe.CookTimeMinutes,
            TotalTimeMinutes = recipe.TotalTimeMinutes,
            Servings = recipe.Servings,
            Difficulty = recipe.Difficulty,
            Tags = JsonHelper.JsonToList(recipe.Tags),
            Cuisine = recipe.Cuisine,
            IsHellofresh = recipe.IsHellofresh,
            HellofreshUuid = recipe.HellofreshUuid,
            HellofreshSlug = recipe.HellofreshSlug,
            CreatedByUserId = recipe.CreatedByUserId,
            CreatedByUserName = recipe.CreatedByUser?.DisplayName,
            AverageRating = (double)recipe.AverageRating,
            TotalRatings = recipe.TotalRatings,
            TotalTimesAdded = recipe.TotalTimesAdded,
            CreatedAt = recipe.CreatedAt
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\GlobalRecipesController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\HelloFreshController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class HelloFreshController : ControllerBase
{
    private readonly IHelloFreshScraperService _scraperService;
    private readonly AppDbContext _context;

    public HelloFreshController(IHelloFreshScraperService scraperService, AppDbContext context)
    {
        _scraperService = scraperService;
        _context = context;
    }

    [HttpPost("sync")]
    [AllowAnonymous] // Allow unauthenticated access for testing
    public async Task<IActionResult> TriggerSync([FromQuery] bool force = false)
    {
        try
        {
            if (!force)
            {
                var shouldRun = await _scraperService.ShouldRunSyncAsync();
                if (!shouldRun)
                {
                    return Ok(new { message = "Sync not needed yet. Use ?force=true to force sync." });
                }
            }

            var (added, updated) = await _scraperService.SyncRecipesAsync();

            return Ok(new
            {
                message = "Sync completed successfully",
                recipesAdded = added,
                recipesUpdated = updated
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Sync failed", error = ex.Message });
        }
    }

    [HttpGet("sync-status")]
    [AllowAnonymous]
    public async Task<IActionResult> GetSyncStatus()
    {
        var lastSync = await _context.EtlSyncLogs
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        if (lastSync == null)
        {
            return Ok(new { message = "No sync has been performed yet" });
        }

        return Ok(new
        {
            lastSync = lastSync.StartedAt,
            status = lastSync.Status,
            recipesAdded = lastSync.RecipesAdded,
            recipesUpdated = lastSync.RecipesUpdated,
            buildId = lastSync.BuildId,
            weeksSynced = lastSync.WeeksSynced,
            errorMessage = lastSync.ErrorMessage
        });
    }

    [HttpGet("build-id")]
    [AllowAnonymous]
    public async Task<IActionResult> GetBuildId()
    {
        try
        {
            var buildId = await _scraperService.GetBuildIdAsync();
            return Ok(new { buildId });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to get build ID", error = ex.Message });
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\HelloFreshController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\HouseholdFriendshipsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

/// <summary>
/// DEPRECATED: This controller manages friendships between households.
/// Use FriendshipsController for user-to-user friendship management instead.
/// This controller is maintained for backward compatibility during migration.
/// </summary>
[Obsolete("Use FriendshipsController instead. This controller will be removed after migration is complete.")]
[ApiController]
[Route("api/household-friendships")]
[Authorize]
public class HouseholdFriendshipsController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public HouseholdFriendshipsController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    [HttpGet]
    public async Task<ActionResult<List<HouseholdFriendshipDto>>> GetFriendships()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);
        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var householdId = user.CurrentHouseholdId.Value;

        var friendships = await _context.HouseholdFriendships
            .Include(f => f.RequesterHousehold)
            .Include(f => f.TargetHousehold)
            .Where(f => f.RequesterHouseholdId == householdId || f.TargetHouseholdId == householdId)
            .OrderByDescending(f => f.CreatedAt)
            .ToListAsync();

        return friendships.Select(MapToDto).ToList();
    }

    //[HttpPost("request")]
    //public async Task<ActionResult<HouseholdFriendshipDto>> RequestFriendship([FromBody] SendHouseholdFriendRequestDto dto)
    //{
    //    var userId = await _currentUserService.GetOrCreateUserIdAsync();
    //    var user = await _context.Users.FindAsync(userId);
    //    if (user?.CurrentHouseholdId == null)
    //        return BadRequest(new { message = "You must select a household first" });

    //    var requesterHouseholdId = user.CurrentHouseholdId.Value;

    //    Guid? targetHouseholdId = dto.HouseholdId;
    //    if (!targetHouseholdId.HasValue && !string.IsNullOrWhiteSpace(dto.HouseholdShareId))
    //    {
    //        var target = await _context.Households
    //            .FirstOrDefaultAsync(h => h.UniqueShareId == dto.HouseholdShareId.Trim().ToUpperInvariant());
    //        targetHouseholdId = target?.Id;
    //    }

    //    if (!targetHouseholdId.HasValue)
    //        return BadRequest(new { message = "Target household not found" });

    //    if (targetHouseholdId.Value == requesterHouseholdId)
    //        return BadRequest(new { message = "Cannot friend your own household" });

    //    // Prevent sending requests to private households unless using share ID
    //    var targetHousehold = await _context.Households.FindAsync(targetHouseholdId.Value);
    //    if (targetHousehold == null)
    //        return NotFound(new { message = "Target household not found" });

    //    if (targetHousehold.IsPrivate && string.IsNullOrWhiteSpace(dto.HouseholdShareId))
    //        return BadRequest(new { message = "This household is private" });

    //    var existing = await _context.HouseholdFriendships
    //        .FirstOrDefaultAsync(f => f.RequesterHouseholdId == requesterHouseholdId && f.TargetHouseholdId == targetHouseholdId.Value);
    //    if (existing != null)
    //        return Conflict(new { message = "A request already exists" });

    //    var friendship = new HouseholdFriendship
    //    {
    //        RequesterHouseholdId = requesterHouseholdId,
    //        TargetHouseholdId = targetHouseholdId.Value,
    //        Status = "pending",
    //        CreatedAt = DateTime.UtcNow,
    //        RequestedByUserId = userId,
    //        Message = dto.Message
    //    };

    //    _context.HouseholdFriendships.Add(friendship);
    //    await _context.SaveChangesAsync();

    //    friendship = await _context.HouseholdFriendships
    //        .Include(f => f.RequesterHousehold)
    //        .Include(f => f.TargetHousehold)
    //        .FirstAsync(f => f.Id == friendship.Id);

    //    return CreatedAtAction(nameof(GetFriendships), MapToDto(friendship));
    //}

    //[HttpPost("{id}/respond")]
    //public async Task<ActionResult<HouseholdFriendshipDto>> Respond(Guid id, [FromBody] RespondHouseholdFriendRequestDto dto)
    //{
    //    var userId = await _currentUserService.GetOrCreateUserIdAsync();
    //    var user = await _context.Users.FindAsync(userId);
    //    if (user?.CurrentHouseholdId == null)
    //        return BadRequest(new { message = "You must select a household first" });

    //    var friendship = await _context.HouseholdFriendships
    //        .Include(f => f.RequesterHousehold)
    //        .Include(f => f.TargetHousehold)
    //        .FirstOrDefaultAsync(f => f.Id == id);

    //    if (friendship == null)
    //        return NotFound();

    //    if (friendship.TargetHouseholdId != user.CurrentHouseholdId.Value && friendship.RequesterHouseholdId != user.CurrentHouseholdId.Value)
    //        return Forbid();

    //    if (friendship.Status != "pending")
    //        return BadRequest(new { message = "Request already processed" });

    //    var action = dto.Action.ToLowerInvariant();
    //    if (action == "accept")
    //    {
    //        friendship.Status = "accepted";
    //    }
    //    else if (action == "reject")
    //    {
    //        friendship.Status = "rejected";
    //    }
    //    else
    //    {
    //        return BadRequest(new { message = "Invalid action" });
    //    }

    //    friendship.RespondedAt = DateTime.UtcNow;
    //    friendship.RespondedByUserId = userId;
    //    await _context.SaveChangesAsync();

    //    return MapToDto(friendship);
    //}

    private static HouseholdFriendshipDto MapToDto(HouseholdFriendship friendship)
    {
        return new HouseholdFriendshipDto
        {
            Id = friendship.Id,
            RequesterHouseholdId = friendship.RequesterHouseholdId,
            TargetHouseholdId = friendship.TargetHouseholdId,
            Status = friendship.Status,
            Message = friendship.Message,
            CreatedAt = friendship.CreatedAt,
            RespondedAt = friendship.RespondedAt,
            RequesterHouseholdName = friendship.RequesterHousehold?.Name ?? string.Empty,
            TargetHouseholdName = friendship.TargetHousehold?.Name ?? string.Empty
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\HouseholdFriendshipsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\HouseholdRecipesController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using StorhaugenEats.API.Services;
using StorhaugenEats.API.Helpers;

namespace StorhaugenEats.API.Controllers;

/// <summary>
/// DEPRECATED: This controller manages recipes at the household level.
/// Use UserRecipesController for user-centric recipe management instead.
/// This controller is maintained for backward compatibility during migration.
/// </summary>
[Obsolete("Use UserRecipesController instead. This controller will be removed after migration is complete.")]
[ApiController]
[Route("api/household-recipes")]
[Authorize]
public class HouseholdRecipesController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public HouseholdRecipesController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all recipes for the current household (optionally include archived)
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<List<HouseholdRecipeDto>>> GetRecipes([FromQuery] bool includeArchived = false)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var query = _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Household)
            .Include(hr => hr.ArchivedBy)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .Where(hr => hr.HouseholdId == user.CurrentHouseholdId);

        if (!includeArchived)
            query = query.Where(hr => !hr.IsArchived);

        var recipes = await query
            .OrderByDescending(hr => hr.CreatedAt)
            .ToListAsync();

        var recipeDtos = recipes.Select(hr => MapToDto(hr)).ToList();

        return Ok(recipeDtos);
    }

    /// <summary>
    /// Get a specific recipe by ID
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<HouseholdRecipeDto>> GetRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.ArchivedBy)
            .Include(hr => hr.Household)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        return Ok(MapToDto(recipe));
    }

  

    /// <summary>
    /// Add a new recipe to the household (custom or from global)
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<HouseholdRecipeDto>> CreateRecipe([FromBody] CreateHouseholdRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        HouseholdRecipe recipe;

        if (dto.GlobalRecipeId.HasValue)
        {
            // Adding from global recipe
            var globalRecipe = await _context.GlobalRecipes.FindAsync(dto.GlobalRecipeId.Value);
            if (globalRecipe == null)
                return NotFound(new { message = "Global recipe not found" });

            recipe = new HouseholdRecipe
            {
                HouseholdId = user.CurrentHouseholdId.Value,
                GlobalRecipeId = dto.Fork ? null : dto.GlobalRecipeId.Value,
                PersonalNotes = dto.PersonalNotes,
                AddedByUserId = userId,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                IsArchived = false,
                IsPublic = dto.IsPublic
            };

            if (dto.Fork)
            {
                // Fork: Copy data from global recipe
                recipe.LocalTitle = dto.Name ?? globalRecipe.Title;
                recipe.LocalDescription = dto.Description ?? globalRecipe.Description;
                recipe.LocalImageUrl = dto.ImageUrls?.Count > 0 ? dto.ImageUrls[0] : (dto.ImageUrl ?? globalRecipe.ImageUrl);
            }
            else
            {
                // Link: Use global recipe data, only store personal notes
                recipe.LocalTitle = null; // Will use global recipe title
                recipe.LocalDescription = null;
                recipe.LocalImageUrl = null;
            }

            // Increment global recipe counter
            globalRecipe.TotalTimesAdded++;
            globalRecipe.UpdatedAt = DateTime.UtcNow;
        }
        else
        {
            // Custom recipe
            recipe = new HouseholdRecipe
            {
                HouseholdId = user.CurrentHouseholdId.Value,
                LocalTitle = dto.Name,
                LocalDescription = dto.Description,
                LocalImageUrl = dto.ImageUrls?.Count > 0
                ? System.Text.Json.JsonSerializer.Serialize(dto.ImageUrls)
                : null,
                PersonalNotes = dto.PersonalNotes,
                AddedByUserId = userId,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                IsArchived = false,
                GlobalRecipeId = null,
                IsPublic = dto.IsPublic
            };
        }
        recipe.IsPublic = dto.IsPublic;

        _context.HouseholdRecipes.Add(recipe);
        await _context.SaveChangesAsync();

        // Reload with includes
        recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Household)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstAsync(hr => hr.Id == recipe.Id);

        return CreatedAtAction(nameof(GetRecipe), new { id = recipe.Id }, MapToDto(recipe));
    }

    /// <summary>
    /// Update a recipe (name, description, notes, images)
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<HouseholdRecipeDto>> UpdateRecipe(Guid id, [FromBody] UpdateHouseholdRecipeDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.ArchivedBy)
            .Include(hr => hr.Household)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        // Only update fields that are provided
        if (dto.Name != null)
        {
            // Can only update name if recipe is forked or custom (not linked to global)
            if (recipe.GlobalRecipeId == null)
                recipe.LocalTitle = dto.Name;
            else
                return BadRequest(new { message = "Cannot update name of linked recipe. Fork it first." });
        }

        if (dto.Description != null)
        {
            if (recipe.GlobalRecipeId == null)
                recipe.LocalDescription = dto.Description;
            else
                return BadRequest(new { message = "Cannot update description of linked recipe. Fork it first." });
        }

        if (dto.ImageUrls != null)
        {
            if (recipe.GlobalRecipeId == null)
            {
                recipe.LocalImageUrl = dto.ImageUrls.Count > 0
                    ? System.Text.Json.JsonSerializer.Serialize(dto.ImageUrls)
                    : null;
            }
            else
                return BadRequest(new { message = "Cannot update images of linked recipe..." });
        }

        if (dto.PersonalNotes != null)
        {
            // Personal notes can always be updated
            recipe.PersonalNotes = dto.PersonalNotes;
        }

        if (dto.IsPublic.HasValue)
        {
            recipe.IsPublic = dto.IsPublic.Value;
        }

        await _context.SaveChangesAsync();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Archive a recipe
    /// </summary>
    [HttpPost("{id}/archive")]
    public async Task<IActionResult> ArchiveRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        recipe.IsArchived = true;
        recipe.ArchivedDate = DateTime.UtcNow;
        recipe.ArchivedByUserId = userId;

        await _context.SaveChangesAsync();

        return Ok(new { message = "Recipe archived" });
    }

    /// <summary>
    /// Restore an archived recipe
    /// </summary>
    [HttpPost("{id}/restore")]
    public async Task<IActionResult> RestoreRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        recipe.IsArchived = false;
        recipe.ArchivedDate = null;
        recipe.ArchivedByUserId = null;

        await _context.SaveChangesAsync();

        return Ok(new { message = "Recipe restored" });
    }

    /// <summary>
    /// Rate a recipe (0-10 scale)
    /// </summary>
    [HttpPost("{id}/rate")]
    public async Task<ActionResult<HouseholdRecipeDto>> RateRecipe(Guid id, [FromBody] RateRecipeDto dto)
    {
        if (dto.Rating < 0 || dto.Rating > 10)
            return BadRequest(new { message = "Rating must be between 0 and 10" });

        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Household)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        // Check if rating already exists
        var existingRating = await _context.Ratings
            .FirstOrDefaultAsync(r => r.HouseholdRecipeId == id && r.UserId == userId);

        if (existingRating != null)
        {
            // Update existing rating
            existingRating.Score = dto.Rating;
            existingRating.CreatedAt = DateTime.UtcNow; // Update timestamp
        }
        else
        {
            // Create new rating
            var newRating = new Rating
            {
                HouseholdRecipeId = id,
                GlobalRecipeId = recipe.GlobalRecipeId, // Use recipe's global ID (null for custom recipes)
                UserId = userId,
                Score = dto.Rating,
                CreatedAt = DateTime.UtcNow
            };
            _context.Ratings.Add(newRating);
        }

        await _context.SaveChangesAsync();

        // If recipe is linked to global, also update global rating
        if (recipe.GlobalRecipeId.HasValue)
        {
            var globalRecipe = await _context.GlobalRecipes.FindAsync(recipe.GlobalRecipeId.Value);
            if (globalRecipe != null)
            {
                // Recalculate global average
                var allRatings = await _context.Ratings
                    .Where(r => r.HouseholdRecipe!.GlobalRecipeId == recipe.GlobalRecipeId.Value)
                    .Select(r => r.Score)
                    .ToListAsync();

                globalRecipe.AverageRating = allRatings.Count > 0 ? (decimal)allRatings.Average() : 0;
                globalRecipe.TotalRatings = allRatings.Count;
                globalRecipe.UpdatedAt = DateTime.UtcNow;

                await _context.SaveChangesAsync();
            }
        }

        // Reload recipe with updated ratings
        recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstAsync(hr => hr.Id == id);

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Fork a linked recipe (convert to editable copy)
    /// </summary>
    [HttpPost("{id}/fork")]
    public async Task<ActionResult<HouseholdRecipeDto>> ForkRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Household)
            .Include(hr => hr.Ratings).ThenInclude(r => r.User)
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        if (recipe.GlobalRecipeId == null)
            return BadRequest(new { message = "Recipe is not linked to a global recipe" });

        if (!recipe.GlobalRecipeId.HasValue)
            return BadRequest(new { message = "Recipe is already forked" });

        // Copy data from global recipe and remove link (making it forked)
        var globalRecipe = recipe.GlobalRecipe;
        recipe.LocalTitle = globalRecipe!.Title;
        recipe.LocalDescription = globalRecipe.Description;
        recipe.LocalImageUrl = globalRecipe.ImageUrl;
        recipe.GlobalRecipeId = null; // Remove link to make it forked

        await _context.SaveChangesAsync();

        return Ok(MapToDto(recipe));
    }

    /// <summary>
    /// Browse public recipes across all households
    /// </summary>
    [HttpGet("public")]
    [AllowAnonymous]
    public async Task<ActionResult<PublicRecipePagedResult>> GetPublicRecipes(
        [FromQuery] string? search = null,
        [FromQuery] string sortBy = "newest",
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20)
    {
        if (page < 1) page = 1;
        if (pageSize < 1) pageSize = 20;

        // FIX 1: Filter out the current user's household
        // We need the current user ID to determine their household
        Guid? currentUserHouseholdId = null;
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var user = await _context.Users.FindAsync(userId);
            currentUserHouseholdId = user?.CurrentHouseholdId;
        }
        catch { /* Allow anonymous access if implemented, otherwise catch auth issues */ }

        var query = _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Ratings)
            .Where(hr => hr.IsPublic && !hr.IsArchived);

        // APPLY FIX: Exclude own household
        if (currentUserHouseholdId.HasValue)
        {
            query = query.Where(hr => hr.HouseholdId != currentUserHouseholdId.Value);
        }

        if (!string.IsNullOrWhiteSpace(search))
        {
            var term = search.Trim().ToLower();
            query = query.Where(hr =>
                (hr.LocalTitle != null && hr.LocalTitle.ToLower().Contains(term)) ||
                (hr.GlobalRecipe != null && hr.GlobalRecipe.Title.ToLower().Contains(term)) ||
                (hr.Household != null && hr.Household.Name.ToLower().Contains(term)));
        }

        query = sortBy switch
        {
            "rating" => query.OrderByDescending(hr => hr.Ratings.Any() ? hr.Ratings.Average(r => r.Score) : 0)
                               .ThenByDescending(hr => hr.CreatedAt),
            _ => query.OrderByDescending(hr => hr.CreatedAt)
        };

        var totalCount = await query.CountAsync();
        var recipes = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        var dto = new PublicRecipePagedResult
        {
            Page = page,
            PageSize = pageSize,
            TotalCount = totalCount,
            Recipes = recipes.Select(r => new PublicRecipeDto
            {
                Id = r.Id,
                Name = r.DisplayTitle,
                Description = r.LocalDescription ?? r.GlobalRecipe?.Description,
                ImageUrls = !string.IsNullOrEmpty(r.LocalImageUrl)
                    ? new List<string> { r.LocalImageUrl }
                    : (r.GlobalRecipe?.ImageUrls != null ? Helpers.JsonHelper.JsonToList(r.GlobalRecipe.ImageUrls) : new List<string>()),
                AverageRating = r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0,
                RatingCount = r.Ratings.Count,
                DateAdded = r.CreatedAt,
                HouseholdName = r.Household?.Name ?? string.Empty,
                AddedByName = r.AddedByUser?.DisplayName,
                HouseholdId = r.HouseholdId,
                GlobalRecipeId = r.GlobalRecipeId
            }).ToList()
        };

        return Ok(dto);
    }

    /// <summary>
    /// Delete a recipe permanently
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user?.CurrentHouseholdId == null)
            return BadRequest(new { message = "You must select a household first" });

        var recipe = await _context.HouseholdRecipes
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.HouseholdId == user.CurrentHouseholdId);

        if (recipe == null)
            return NotFound();

        // Delete associated ratings
        var ratings = await _context.Ratings.Where(r => r.HouseholdRecipeId == id).ToListAsync();
        _context.Ratings.RemoveRange(ratings);

        _context.HouseholdRecipes.Remove(recipe);
        await _context.SaveChangesAsync();

        return Ok(new { message = "Recipe deleted" });
    }

    /// <summary>
    /// Get a specific PUBLIC recipe by ID (AllowAnonymous)
    /// </summary>
    [HttpGet("public/{id}")]
    [AllowAnonymous]
    public async Task<ActionResult<PublicRecipeDto>> GetPublicRecipe(Guid id)
    {
        var recipe = await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .Include(hr => hr.Ratings)
            .FirstOrDefaultAsync(hr => hr.Id == id && hr.IsPublic && !hr.IsArchived);

        if (recipe == null)
            return NotFound();

        return Ok(new PublicRecipeDto
        {
            Id = recipe.Id,
            Name = recipe.DisplayTitle,
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = !string.IsNullOrEmpty(recipe.LocalImageUrl)
                ? new List<string> { recipe.LocalImageUrl } // Basic handling, improve if storing JSON array
                : (recipe.GlobalRecipe?.ImageUrls != null ? Helpers.JsonHelper.JsonToList(recipe.GlobalRecipe.ImageUrls) : new List<string>()),
            AverageRating = recipe.Ratings.Any() ? recipe.Ratings.Average(rt => rt.Score) : 0,
            RatingCount = recipe.Ratings.Count,
            DateAdded = recipe.CreatedAt,
            HouseholdName = recipe.Household?.Name ?? string.Empty,
            AddedByName = recipe.AddedByUser?.DisplayName,
            HouseholdId = recipe.HouseholdId,
            GlobalRecipeId = recipe.GlobalRecipeId
        });
    }

    private static HouseholdRecipeDto MapToDto(HouseholdRecipe recipe)
    {
        // Calculate average rating from household members
        var ratings = recipe.Ratings?
            .Where(r => r.User != null)
            .GroupBy(r => r.User.DisplayName ?? r.User.Email ?? "Unknown")
            .ToDictionary(g => g.Key, g => (int?)g.First().Score)
            ?? new Dictionary<string, int?>();

        var averageRating = ratings.Values.Where(r => r.HasValue).Any()
            ? ratings.Values.Where(r => r.HasValue).Average(r => r!.Value)
            : 0;

        var imageUrls = new List<string>();

        if (!string.IsNullOrEmpty(recipe.LocalImageUrl))
        {
            try
            {
                if (recipe.LocalImageUrl.Trim().StartsWith("["))
                {
                    var list = System.Text.Json.JsonSerializer.Deserialize<List<string>>(recipe.LocalImageUrl);
                    if (list != null) imageUrls.AddRange(list);
                }
                else
                {
                    imageUrls.Add(recipe.LocalImageUrl);
                }
            }
            catch
            {
                imageUrls.Add(recipe.LocalImageUrl);
            }
        }
        else if (recipe.GlobalRecipe?.ImageUrls != null)
        {
            imageUrls = JsonHelper.JsonToList(recipe.GlobalRecipe.ImageUrls);
        }

        return new HouseholdRecipeDto
        {
            Id = recipe.Id,
            HouseholdId = recipe.HouseholdId,
            Name = recipe.LocalTitle ?? recipe.GlobalRecipe?.Title ?? "Ukjent",
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = imageUrls,
            Ratings = ratings,
            AverageRating = averageRating,
            DateAdded = recipe.CreatedAt,
            AddedByUserId = recipe.AddedByUserId ?? Guid.Empty,
            AddedByName = recipe.AddedBy?.DisplayName,
            IsArchived = recipe.IsArchived,
            ArchivedDate = recipe.ArchivedDate,
            ArchivedByUserId = recipe.ArchivedByUserId,
            ArchivedByName = recipe.ArchivedBy?.DisplayName,
            GlobalRecipeId = recipe.GlobalRecipeId,
            GlobalRecipeName = recipe.GlobalRecipe?.Title,
            IsForked = false,
            PersonalNotes = recipe.PersonalNotes,
            IsPublic = recipe.IsPublic,
            HouseholdName = recipe.Household?.Name
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\HouseholdRecipesController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\HouseholdsController.cs
================================================================================
using System.Linq;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

/// <summary>
/// LEGACY: This controller manages household entities.
/// While households still exist for grouping users, the application is transitioning
/// to a user-centric model. New features should use user-level APIs.
/// Recipe management should use UserRecipesController.
/// Friendships should use FriendshipsController.
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class HouseholdsController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;
    private readonly IUserRecipeService _userRecipeService;

    public HouseholdsController(
        AppDbContext context,
        ICurrentUserService currentUserService,
        IUserRecipeService userRecipeService)
    {
        _context = context;
        _currentUserService = currentUserService;
        _userRecipeService = userRecipeService;
    }

    /// <summary>
    /// Get all households the current user is a member of
    /// </summary>
    [HttpGet("my")]
    public async Task<ActionResult<List<HouseholdDto>>> GetMyHouseholds()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var households = await _context.Households
            .Where(h => h.HouseholdMembers.Any(m => m.UserId == userId))
            .Select(h => new HouseholdDto
            {
                Id = h.Id,
                Name = h.Name,
                CreatedById = h.LeaderId ?? Guid.Empty,
                CreatedByName = h.Leader != null ? h.Leader.DisplayName : null,
                CreatedAt = h.CreatedAt,
                UniqueShareId = h.UniqueShareId,
                IsPrivate = h.IsPrivate,
                Members = h.HouseholdMembers.Select(m => new HouseholdMemberDto
                {
                    UserId = m.UserId,
                    Email = m.User.Email,
                    DisplayName = m.User.DisplayName,
                    AvatarUrl = m.User.AvatarUrl,
                    JoinedAt = m.JoinedAt
                }).ToList()
            })
            .ToListAsync();

        return Ok(households);
    }

    /// <summary>
    /// Get a specific household by ID
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<HouseholdDto>> GetHousehold(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var household = await _context.Households
            .Where(h => h.Id == id && h.HouseholdMembers.Any(m => m.UserId == userId))
            .Select(h => new HouseholdDto
            {
                Id = h.Id,
                Name = h.Name,
                CreatedById = h.LeaderId ?? Guid.Empty,
                CreatedByName = h.Leader != null ? h.Leader.DisplayName : null,
                CreatedAt = h.CreatedAt,
                UniqueShareId = h.UniqueShareId,
                IsPrivate = h.IsPrivate,
                Members = h.HouseholdMembers.Select(m => new HouseholdMemberDto
                {
                    UserId = m.UserId,
                    Email = m.User.Email,
                    DisplayName = m.User.DisplayName,
                    AvatarUrl = m.User.AvatarUrl,
                    JoinedAt = m.JoinedAt
                }).ToList()
            })
            .FirstOrDefaultAsync();

        if (household == null)
            return NotFound(new { message = "Household not found or you are not a member" });

        return Ok(household);
    }

    [HttpPut("{id}/settings")]
    public async Task<ActionResult<HouseholdDto>> UpdateHouseholdSettings(Guid id, [FromBody] UpdateHouseholdSettingsDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var household = await _context.Households.FirstOrDefaultAsync(h => h.Id == id && h.LeaderId == userId);

        if (household == null) return NotFound(new { message = "Household not found or you are not the leader" });

        if (dto.IsPrivate.HasValue) household.IsPrivate = dto.IsPrivate.Value;

        // Generate Share ID if it doesn't exist and we're saving settings
        if (string.IsNullOrEmpty(household.UniqueShareId))
        {
            household.UniqueShareId = await GenerateUniqueHouseholdShareIdAsync();
        }

        await _context.SaveChangesAsync();

        // Return full DTO (re-query or map existing)
        // ... existing mapping logic ...
        return Ok(new HouseholdDto
        {
            Id = household.Id,
            Name = household.Name,
            IsPrivate = household.IsPrivate,
            UniqueShareId = household.UniqueShareId
            /* map other fields */
        });
    }

    /// <summary>
    /// Create a new household
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<HouseholdDto>> CreateHousehold([FromBody] CreateHouseholdDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        // 1. Generate the ID here and assign it to the entity
        var household = new Household
        {
            Name = dto.Name,
            LeaderId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
            UniqueShareId = await GenerateUniqueHouseholdShareIdAsync(),
            IsPrivate = false
        };

        _context.Households.Add(household);
        await _context.SaveChangesAsync(); // Now it's saved to the DB

        var member = new HouseholdMember
        {
            HouseholdId = household.Id,
            UserId = userId,
            JoinedAt = DateTime.UtcNow
        };
        _context.HouseholdMembers.Add(member);

        if (user != null)
        {
            user.CurrentHouseholdId = household.Id;
            user.UpdatedAt = DateTime.UtcNow;
        }

        await _context.SaveChangesAsync();

        // 2. Read it from the entity for the DTO
        var householdDto = new HouseholdDto
        {
            Id = household.Id,
            Name = household.Name,
            CreatedById = userId,
            CreatedByName = user?.DisplayName,
            CreatedAt = household.CreatedAt,
            UniqueShareId = household.UniqueShareId,
            IsPrivate = household.IsPrivate,
            Members = new List<HouseholdMemberDto>
        {
            new HouseholdMemberDto
            {
                UserId = userId,
                Email = user?.Email ?? "",
                DisplayName = user?.DisplayName,
                AvatarUrl = user?.AvatarUrl,
                JoinedAt = member.JoinedAt
            }
        }
        };

        return CreatedAtAction(nameof(GetHousehold), new { id = household.Id }, householdDto);
    }

    /// <summary>
    /// Update household name
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<HouseholdDto>> UpdateHousehold(Guid id, [FromBody] UpdateHouseholdDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var household = await _context.Households
            .FirstOrDefaultAsync(h => h.Id == id && h.LeaderId == userId);

        if (household == null)
            return NotFound(new { message = "Household not found or you are not the creator" });

        household.Name = dto.Name;
        household.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return await GetHousehold(id);
    }

    /// <summary>
    /// Send an invitation to join the household (by email or unique share ID)
    /// </summary>
    [HttpPost("{id}/invites")]
    public async Task<ActionResult<HouseholdInviteDto>> InviteToHousehold(Guid id, [FromBody] InviteToHouseholdDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        // Verify user is member of household
        var isMember = await _context.HouseholdMembers
            .AnyAsync(hm => hm.HouseholdId == id && hm.UserId == userId);

        if (!isMember)
            return Forbid();

        var household = await _context.Households.FindAsync(id);
        if (household == null)
            return NotFound();

        // Determine email from dto.Email or by looking up UniqueShareId
        string? invitedEmail = dto.Email;

        if (string.IsNullOrWhiteSpace(invitedEmail) && !string.IsNullOrWhiteSpace(dto.UniqueShareId))
        {
            // Look up user by UniqueShareId
            var targetUser = await _context.Users
                .FirstOrDefaultAsync(u => u.UniqueShareId == dto.UniqueShareId.Trim().ToUpperInvariant());

            if (targetUser == null)
                return NotFound(new { message = "User with that share ID not found" });

            invitedEmail = targetUser.Email;
        }

        if (string.IsNullOrWhiteSpace(invitedEmail))
            return BadRequest(new { message = "Either email or share ID is required" });

        // Check if user is already a member
        var existingMember = await _context.HouseholdMembers
            .Include(hm => hm.User)
            .FirstOrDefaultAsync(hm => hm.HouseholdId == id && hm.User.Email == invitedEmail);

        if (existingMember != null)
            return BadRequest(new { message = "User is already a member of this household" });

        // Check if invite already exists
        var existingInvite = await _context.HouseholdInvites
            .FirstOrDefaultAsync(i => i.HouseholdId == id && i.InvitedEmail == invitedEmail && i.Status == "pending");

        if (existingInvite != null)
            return BadRequest(new { message = "An invite is already pending for this user" });

        // Create invite
        var invite = new HouseholdInvite
        {
            HouseholdId = id,
            InvitedByUserId = userId,
            InvitedEmail = invitedEmail,
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.HouseholdInvites.Add(invite);
        await _context.SaveChangesAsync();

        var inviter = await _context.Users.FindAsync(userId);

        return Ok(new HouseholdInviteDto
        {
            Id = invite.Id,
            HouseholdId = household.Id,
            HouseholdName = household.Name,
            InvitedById = userId,
            InvitedByName = inviter?.DisplayName ?? "Unknown",
            InvitedEmail = invitedEmail,
            Status = "pending",
            CreatedAt = invite.CreatedAt
        });
    }

    /// <summary>
    /// Get pending invites for the current user
    /// </summary>
    [HttpGet("invites/pending")]
    public async Task<ActionResult<List<HouseholdInviteDto>>> GetPendingInvites()
    {
        var email = _currentUserService.GetUserEmail();
        if (string.IsNullOrEmpty(email))
            return Unauthorized();

        var invites = await _context.HouseholdInvites
            .Where(i => i.InvitedEmail == email && i.Status == "pending")
            .Select(i => new HouseholdInviteDto
            {
                Id = i.Id,
                HouseholdId = i.HouseholdId,
                HouseholdName = i.Household.Name,
                InvitedById = i.InvitedByUserId,
                InvitedByName = i.InvitedByUser.DisplayName,
                InvitedEmail = i.InvitedEmail ?? string.Empty,
                Status = i.Status,
                CreatedAt = i.CreatedAt
            })
            .ToListAsync();

        return Ok(invites);
    }

    /// <summary>
    /// Accept an invitation
    /// </summary>
    [HttpPost("invites/{inviteId}/accept")]
    public async Task<ActionResult<HouseholdDto>> AcceptInvite(Guid inviteId)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var email = _currentUserService.GetUserEmail();

        var invite = await _context.HouseholdInvites
            .FirstOrDefaultAsync(i => i.Id == inviteId && i.InvitedEmail == email && i.Status == "pending");

        if (invite == null)
            return NotFound(new { message = "Invite not found or already processed" });

        // Add user to household
        var existingMember = await _context.HouseholdMembers
            .FirstOrDefaultAsync(hm => hm.HouseholdId == invite.HouseholdId && hm.UserId == userId);

        if (existingMember == null)
        {
            _context.HouseholdMembers.Add(new HouseholdMember
            {
                HouseholdId = invite.HouseholdId,
                UserId = userId,
                JoinedAt = DateTime.UtcNow
            });
        }

        // Update invite status
        invite.Status = "accepted";
        invite.UpdatedAt = DateTime.UtcNow;

        // Set as user's current household
        var user = await _context.Users.FindAsync(userId);
        if (user != null)
        {
            user.CurrentHouseholdId = invite.HouseholdId;
            user.UpdatedAt = DateTime.UtcNow;
        }

        await _context.SaveChangesAsync();

        return await GetHousehold(invite.HouseholdId);
    }

    /// <summary>
    /// Reject an invitation
    /// </summary>
    [HttpPost("invites/{inviteId}/reject")]
    public async Task<IActionResult> RejectInvite(Guid inviteId)
    {
        var email = _currentUserService.GetUserEmail();

        var invite = await _context.HouseholdInvites
            .FirstOrDefaultAsync(i => i.Id == inviteId && i.InvitedEmail == email && i.Status == "pending");

        if (invite == null)
            return NotFound(new { message = "Invite not found or already processed" });

        invite.Status = "rejected";
        await _context.SaveChangesAsync();

        return Ok(new { message = "Invite rejected" });
    }

    /// <summary>
    /// Switch to a different household (must be a member)
    /// </summary>
    [HttpPost("{id}/switch")]
    public async Task<IActionResult> SwitchHousehold(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        // Verify user is member of household
        var isMember = await _context.HouseholdMembers
            .AnyAsync(hm => hm.HouseholdId == id && hm.UserId == userId);

        if (!isMember)
            return NotFound(new { message = "You are not a member of this household" });

        var user = await _context.Users.FindAsync(userId);
        if (user != null)
        {
            user.CurrentHouseholdId = id;
            user.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
        }

        return Ok(new { message = "Switched household successfully", currentHouseholdId = id });
    }

    /// <summary>
    /// Leave a household
    /// </summary>
    [HttpPost("{id}/leave")]
    public async Task<IActionResult> LeaveHousehold(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        // 1. Get the membership to remove
        var membership = await _context.HouseholdMembers
            .FirstOrDefaultAsync(hm => hm.HouseholdId == id && hm.UserId == userId);

        if (membership == null)
            return NotFound(new { message = "You are not a member of this household" });

        var household = await _context.Households.FindAsync(id);
        if (household == null) return NotFound();

        // 2. Remove the user
        _context.HouseholdMembers.Remove(membership);

        // 3. Handle Ownership Transfer
        if (household.LeaderId == userId)
        {
            // Check if there are ANY other members remaining
            // Note: We haven't saved changes yet, so the current user is technically still in the DB count if we don't filter them out.
            // Better logic: Query for "next best leader"
            var newLeaderCandidate = await _context.HouseholdMembers
                .Where(hm => hm.HouseholdId == id && hm.UserId != userId)
                .OrderBy(hm => hm.JoinedAt) // Oldest member inherits ownership
                .FirstOrDefaultAsync();

            if (newLeaderCandidate != null)
            {
                // Transfer ownership
                household.LeaderId = newLeaderCandidate.UserId;
            }
            else
            {
                // No other members left? Delete the household entirely.
                // Depending on your rules, you might want to soft-delete or just leave it empty.
                // Usually, if the last person leaves, the household dies.
                _context.Households.Remove(household);
            }
        }

        // 4. Update User's Current Household Context
        var user = await _context.Users.FindAsync(userId);
        if (user?.CurrentHouseholdId == id)
        {
            user.CurrentHouseholdId = null;
            user.UpdatedAt = DateTime.UtcNow;
        }

        await _context.SaveChangesAsync();

        return Ok(new { message = "Left household successfully" });
    }

    /// <summary>
    /// Regenerate the household share ID
    /// </summary>
    [HttpPost("{id}/regenerate-share-id")]
    public async Task<ActionResult<HouseholdDto>> RegenerateShareId(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var household = await _context.Households.FirstOrDefaultAsync(h => h.Id == id && h.LeaderId == userId);
        if (household == null)
            return NotFound(new { message = "Household not found or you are not the creator" });

        household.UniqueShareId = await GenerateUniqueHouseholdShareIdAsync();
        household.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return await GetHousehold(id);
    }

    /// <summary>
    /// Search for households (only non-private are returned unless exact share ID match)
    /// </summary>
    [HttpGet("search")]
    [AllowAnonymous]
    public async Task<ActionResult<List<HouseholdSearchResultDto>>> SearchHouseholds([FromQuery] string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return new List<HouseholdSearchResultDto>();

        var normalized = query.Trim().ToUpperInvariant();

        var households = await _context.Households
            .Where(h => (!h.IsPrivate && h.Name.ToUpper().Contains(normalized)) || (h.UniqueShareId == normalized))
            .Select(h => new HouseholdSearchResultDto
            {
                Id = h.Id,
                Name = h.Name,
                UniqueShareId = h.UniqueShareId,
                MemberCount = h.HouseholdMembers.Count,
                CreatedAt = h.CreatedAt,
                IsPrivate = h.IsPrivate
            })
            .OrderBy(h => h.IsPrivate)
            .ThenBy(h => h.Name)
            .ToListAsync();

        return households;
    }

    private async Task<string> GenerateUniqueHouseholdShareIdAsync()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        var random = new Random();
        string shareId;

        do
        {
            shareId = new string(Enumerable.Range(0, 12)
                .Select(_ => chars[random.Next(chars.Length)])
                .ToArray());
        } while (await _context.Households.AnyAsync(h => h.UniqueShareId == shareId));

        return shareId;
    }

    // ==========================================
    // NEW: HOUSEHOLD RECIPE AGGREGATION ENDPOINTS
    // ==========================================

    /// <summary>
    /// Get combined recipes from all household members (the "Family Cookbook" view).
    /// </summary>
    [HttpGet("{id}/combined-recipes")]
    public async Task<ActionResult<AggregatedRecipePagedResult>> GetCombinedRecipes(
        Guid id,
        [FromQuery] GetCombinedRecipesQuery query)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.GetHouseholdRecipesAsync(id, userId, query);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Get "common favorites" - recipes that multiple household members have rated highly.
    /// </summary>
    [HttpGet("{id}/common-favorites")]
    public async Task<ActionResult<List<CommonFavoriteDto>>> GetCommonFavorites(
        Guid id,
        [FromQuery] GetCommonFavoritesQuery query)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.GetCommonFavoritesAsync(id, userId, query);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\HouseholdsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\RatingsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;
using StorhaugenWebsite.Shared.DTOs;
using System.Security.Claims;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/[controller]")]
[Authorize]
public class RatingsController : ControllerBase
{
    private readonly IRatingService _ratingService;
    private readonly IUserFriendshipService _friendshipService;
    private readonly ICurrentUserService _currentUserService; // <--- 1. Add Service
    private readonly AppDbContext _context;

    public RatingsController(
        IRatingService ratingService,
        IUserFriendshipService friendshipService,
        ICurrentUserService currentUserService, // <--- 2. Inject here
        AppDbContext context)
    {
        _ratingService = ratingService;
        _friendshipService = friendshipService;
        _currentUserService = currentUserService; // <--- 3. Assign here
        _context = context;
    }

    // REMOVE THIS METHOD COMPLETELY
    // private Guid GetCurrentUserId() { ... } 

    // Public: ratings for a recipe
    [HttpGet("recipe/{globalRecipeId:guid}")]
    [AllowAnonymous]
    public async Task<IActionResult> GetRatingsForRecipe(Guid globalRecipeId)
    {
        var ratings = await _ratingService.GetRatingsForRecipeAsync(globalRecipeId);
        return Ok(ratings);
    }

    // Private: my rating for a recipe
    [HttpGet("recipe/{globalRecipeId:guid}/my-rating")]
    public async Task<IActionResult> GetMyRating(Guid globalRecipeId)
    {
        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var rating = await _ratingService.GetUserRatingForRecipeAsync(userId, globalRecipeId);
        if (rating == null)
            return NotFound();

        return Ok(rating);
    }

    // Private: upsert my rating
    [HttpPost]
    public async Task<IActionResult> UpsertRating([FromBody] UpsertRatingRequest request)
    {
        if (request.Score < 0 || request.Score > 10)
            return BadRequest(new { message = "Score must be between 0 and 10." });

        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var rating = await _ratingService.UpsertRatingAsync(
            userId,
            request.GlobalRecipeId,
            request.Score,
            request.Comment
        );

        return Ok(rating);
    }

    // Private: delete my rating
    [HttpDelete("recipe/{globalRecipeId:guid}")]
    public async Task<IActionResult> DeleteRating(Guid globalRecipeId)
    {
        // FIX: Use service
        var userId = await _currentUserService.GetOrCreateUserIdAsync();

        var success = await _ratingService.DeleteRatingAsync(userId, globalRecipeId);

        if (!success)
            return NotFound();

        return NoContent();
    }


    [HttpGet("user/{profileUserId:guid}")]
    public async Task<ActionResult<List<UserRatingDto>>> GetUserRatings(
    Guid profileUserId,
    [FromQuery] int skip = 0,
    [FromQuery] int take = 50)
    {
        var requestingUserId = await _currentUserService.GetOrCreateUserIdAsync();
        bool areFriends = false;

        if (requestingUserId != profileUserId)
        {
            areFriends = await _friendshipService.AreFriendsAsync(requestingUserId, profileUserId);
            if (!areFriends) return Forbid();
        }

        if (skip < 0) skip = 0;
        if (take < 1) take = 50;

        // Fetch ratings with includes
        var ratings = await _context.Ratings
            .AsNoTracking()
            .Include(r => r.GlobalRecipe)
            .Include(r => r.UserRecipe)
            .Where(r => r.UserId == profileUserId)
            .OrderByDescending(r => r.UpdatedAt)
            .Skip(skip)
            .Take(take)
            .ToListAsync();

        var result = new List<UserRatingDto>();

        foreach (var r in ratings)
        {
            // 1. Global Recipe Logic (Always visible)
            if (r.GlobalRecipe != null)
            {
                result.Add(new UserRatingDto
                {
                    GlobalRecipeId = r.GlobalRecipeId,
                    RecipeTitle = r.GlobalRecipe.Title,
                    ImageUrl = r.GlobalRecipe.ImageUrl, // Or verify ImageUrls logic
                    Score = r.Score,
                    Comment = r.Comment,
                    RatedAt = r.UpdatedAt
                });
            }
            // 2. User Recipe Logic (Check Visibility)
            else if (r.UserRecipe != null)
            {
                bool isVisible = r.UserRecipe.Visibility == "public" ||
                                 (r.UserRecipe.Visibility == "friends" && areFriends) ||
                                 requestingUserId == profileUserId; // Own profile

                if (isVisible)
                {
                    result.Add(new UserRatingDto
                    {
                        UserRecipeId = r.UserRecipeId,
                        RecipeTitle = r.UserRecipe.DisplayTitle, // Use display helper
                        ImageUrl = r.UserRecipe.DisplayImageUrls != "[]"
                            ? StorhaugenEats.API.Helpers.JsonHelper.JsonToList(r.UserRecipe.DisplayImageUrls).FirstOrDefault()
                            : null,
                        Score = r.Score,
                        Comment = r.Comment,
                        RatedAt = r.UpdatedAt
                    });
                }
            }
        }

        return Ok(result);
    }

}

public record UpsertRatingRequest(Guid GlobalRecipeId, int Score, string? Comment);


================================================================================
FILE END: \StorhaugenEats.API\Controllers\RatingsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\StorageController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/storage")]
[Authorize]
public class StorageController : ControllerBase
{
    private readonly IStorageService _storageService;
    private readonly ICurrentUserService _currentUserService;

    public StorageController(IStorageService storageService, ICurrentUserService currentUserService)
    {
        _storageService = storageService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Upload an image to Supabase Storage
    /// </summary>
    [HttpPost("upload")]
    public async Task<ActionResult<UploadImageResultDto>> UploadImage([FromBody] UploadImageDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Base64Data))
            return BadRequest(new { message = "Image data is required" });

        if (string.IsNullOrWhiteSpace(dto.FileName))
            return BadRequest(new { message = "File name is required" });

        // Validate file extension
        var extension = Path.GetExtension(dto.FileName).ToLowerInvariant();
        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".webp", ".gif" };

        if (!allowedExtensions.Contains(extension))
            return BadRequest(new { message = $"Invalid file type. Allowed: {string.Join(", ", allowedExtensions)}" });

        try
        {
            // Convert base64 to bytes
            var imageBytes = Convert.FromBase64String(dto.Base64Data);

            // Check file size (5MB max)
            const int maxSizeBytes = 5 * 1024 * 1024; // 5MB
            if (imageBytes.Length > maxSizeBytes)
                return BadRequest(new { message = "Image size must be less than 5MB" });

            // Generate unique filename
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var uniqueFileName = $"{userId}_{Guid.NewGuid()}{extension}";

            // Upload to storage
            using var imageStream = new MemoryStream(imageBytes);
            var url = await _storageService.UploadImageAsync(imageStream, uniqueFileName, dto.Bucket ?? "recipe-images");

            return Ok(new UploadImageResultDto
            {
                Url = url,
                FileName = uniqueFileName
            });
        }
        catch (FormatException)
        {
            return BadRequest(new { message = "Invalid base64 image data" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to upload image", error = ex.Message });
        }
    }

    /// <summary>
    /// Delete an image from Supabase Storage
    /// </summary>
    [HttpDelete("{fileName}")]
    public async Task<IActionResult> DeleteImage(string fileName, [FromQuery] string bucket = "recipe-images")
    {
        if (string.IsNullOrWhiteSpace(fileName))
            return BadRequest(new { message = "File name is required" });

        try
        {
            // Extract user ID from filename (format: {userId}_{guid}.ext)
            var parts = fileName.Split('_');
            if (parts.Length < 2 || !Guid.TryParse(parts[0], out var fileUserId))
                return BadRequest(new { message = "Invalid file name format" });

            // Verify user owns the file
            var currentUserId = await _currentUserService.GetOrCreateUserIdAsync();
            if (fileUserId != currentUserId)
                return Forbid();

            // DeleteImageAsync expects a URL, so we need to construct it
            // For now, just pass the fileName as the URL (storage service will handle it)
            await _storageService.DeleteImageAsync(fileName);

            return Ok(new { message = "Image deleted successfully" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Failed to delete image", error = ex.Message });
        }
    }

    /// <summary>
    /// Get a signed URL for uploading directly to storage (for large files)
    /// </summary>
    [HttpPost("upload-url")]
    public async Task<IActionResult> GetUploadUrl([FromBody] GetUploadUrlDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var uniqueFileName = $"{userId}_{Guid.NewGuid()}{Path.GetExtension(dto.FileName)}";

        // In a full implementation, you'd generate a signed URL from Supabase Storage
        // For now, return the file name that should be used
        return Ok(new
        {
            fileName = uniqueFileName,
            message = "Use POST /api/storage/upload endpoint for file upload"
        });
    }
}

public record GetUploadUrlDto(string FileName);


================================================================================
FILE END: \StorhaugenEats.API\Controllers\StorageController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\TagsController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

/// <summary>
/// Controller for managing personal recipe tags/categories.
/// Tags are used for personal organization and are private to each user.
/// </summary>
[ApiController]
[Route("api/tags")]
[Authorize]
public class TagsController : ControllerBase
{
    private readonly ITagService _tagService;
    private readonly ICurrentUserService _currentUserService;

    public TagsController(ITagService tagService, ICurrentUserService currentUserService)
    {
        _tagService = tagService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all tags for the current user.
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<List<TagDto>>> GetMyTags()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var tags = await _tagService.GetUserTagsAsync(userId);
        return Ok(tags);
    }

    /// <summary>
    /// Get a specific tag by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<TagDto>> GetTag(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var tag = await _tagService.GetTagAsync(id, userId);

        if (tag == null)
            return NotFound(new { message = "Tag not found" });

        return Ok(tag);
    }

    /// <summary>
    /// Create a new tag.
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<TagDto>> CreateTag([FromBody] CreateTagDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tag = await _tagService.CreateTagAsync(userId, dto);
            return CreatedAtAction(nameof(GetTag), new { id = tag.Id }, tag);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Update a tag.
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<TagDto>> UpdateTag(Guid id, [FromBody] UpdateTagDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tag = await _tagService.UpdateTagAsync(id, userId, dto);
            return Ok(tag);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Delete a tag.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> DeleteTag(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.DeleteTagAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    // ==========================================
    // RECIPE-TAG MANAGEMENT
    // ==========================================

    /// <summary>
    /// Get tags for a specific recipe.
    /// </summary>
    [HttpGet("recipe/{recipeId}")]
    public async Task<ActionResult<List<TagReferenceDto>>> GetRecipeTags(Guid recipeId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var tags = await _tagService.GetRecipeTagsAsync(recipeId, userId);
            return Ok(tags);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Set tags for a recipe (replaces existing tags).
    /// </summary>
    [HttpPut("recipe/{recipeId}")]
    public async Task<ActionResult> SetRecipeTags(Guid recipeId, [FromBody] UpdateRecipeTagsDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.SetRecipeTagsAsync(recipeId, userId, dto.TagIds);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Add a tag to a recipe.
    /// </summary>
    [HttpPost("recipe/{recipeId}/tag/{tagId}")]
    public async Task<ActionResult> AddTagToRecipe(Guid recipeId, Guid tagId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.AddTagToRecipeAsync(recipeId, tagId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove a tag from a recipe.
    /// </summary>
    [HttpDelete("recipe/{recipeId}/tag/{tagId}")]
    public async Task<ActionResult> RemoveTagFromRecipe(Guid recipeId, Guid tagId)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _tagService.RemoveTagFromRecipeAsync(recipeId, tagId, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\TagsController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\UserRecipesController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/user-recipes")]
[Authorize]
public class UserRecipesController : ControllerBase
{
    private readonly IUserRecipeService _userRecipeService;
    private readonly ICurrentUserService _currentUserService;

    public UserRecipesController(
        IUserRecipeService userRecipeService,
        ICurrentUserService currentUserService)
    {
        _userRecipeService = userRecipeService;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get all recipes for the current user.
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<UserRecipePagedResult>> GetMyRecipes([FromQuery] GetUserRecipesQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _userRecipeService.GetUserRecipesAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get recipes from friends that are visible to the current user.
    /// </summary>
    [HttpGet("friends")]
    public async Task<ActionResult<UserRecipePagedResult>> GetFriendsRecipes([FromQuery] GetUserRecipesQuery query)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var result = await _userRecipeService.GetFriendsRecipesAsync(userId, query);
        return Ok(result);
    }

    /// <summary>
    /// Get a specific recipe by ID.
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserRecipeDto>> GetRecipe(Guid id)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var recipe = await _userRecipeService.GetRecipeAsync(id, userId);

        if (recipe == null)
            return NotFound(new { message = "Recipe not found or you don't have permission to view it" });

        return Ok(recipe);
    }

    /// <summary>
    /// Create a new recipe.
    /// </summary>
    [HttpPost]
    public async Task<ActionResult<UserRecipeDto>> CreateRecipe([FromBody] CreateUserRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.CreateRecipeAsync(userId, dto);
            return CreatedAtAction(nameof(GetRecipe), new { id = recipe.Id }, recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Update a recipe.
    /// </summary>
    [HttpPut("{id}")]
    public async Task<ActionResult<UserRecipeDto>> UpdateRecipe(Guid id, [FromBody] UpdateUserRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.UpdateRecipeAsync(id, userId, dto);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Delete a recipe.
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<ActionResult> DeleteRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _userRecipeService.DeleteRecipeAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Publish a local recipe to the global recipe catalog.
    /// </summary>
    [HttpPost("{id}/publish")]
    public async Task<ActionResult<PublishRecipeResultDto>> PublishRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.PublishRecipeAsync(id, userId);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Detach a recipe from its linked global recipe (hard fork).
    /// </summary>
    [HttpPost("{id}/detach")]
    public async Task<ActionResult<UserRecipeDto>> DetachRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.DetachRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Rate a recipe.
    /// </summary>
    [HttpPost("{id}/rate")]
    public async Task<ActionResult<UserRecipeDto>> RateRecipe(Guid id, [FromBody] RateRecipeDto dto)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.RateRecipeAsync(id, userId, dto.Rating, dto.Comment);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Remove rating from a recipe.
    /// </summary>
    [HttpDelete("{id}/rate")]
    public async Task<ActionResult> RemoveRating(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            await _userRecipeService.RemoveRatingAsync(id, userId);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Archive a recipe.
    /// </summary>
    [HttpPost("{id}/archive")]
    public async Task<ActionResult<UserRecipeDto>> ArchiveRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.ArchiveRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Restore an archived recipe.
    /// </summary>
    [HttpPost("{id}/restore")]
    public async Task<ActionResult<UserRecipeDto>> RestoreRecipe(Guid id)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var recipe = await _userRecipeService.RestoreRecipeAsync(id, userId);
            return Ok(recipe);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    // ==========================================
    // MULTI-GROUP AGGREGATION ENDPOINTS
    // ==========================================

    /// <summary>
    /// Get combined recipes from multiple groups (households).
    /// This endpoint aggregates recipes from all members of the selected groups.
    /// </summary>
    [HttpPost("groups/aggregate")]
    public async Task<ActionResult<AggregatedRecipePagedResult>> GetGroupsCombinedRecipes(
        [FromBody] GetMultiGroupRecipesQuery query)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.GetGroupsCombinedRecipesAsync(userId, query);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }

    /// <summary>
    /// Get common favorites from multiple groups - recipes that multiple members have rated highly.
    /// </summary>
    [HttpPost("groups/common-favorites")]
    public async Task<ActionResult<List<CommonFavoriteDto>>> GetGroupsCommonFavorites(
        [FromBody] GetMultiGroupFavoritesQuery query)
    {
        try
        {
            var userId = await _currentUserService.GetOrCreateUserIdAsync();
            var result = await _userRecipeService.GetGroupsCommonFavoritesAsync(userId, query);
            return Ok(result);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { message = ex.Message });
        }
    }
}

/// <summary>
/// DTO for rating a recipe.
/// </summary>
public class RateRecipeDto
{
    public int Rating { get; set; }
    public string? Comment { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\UserRecipesController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Controllers\UsersController.cs
================================================================================
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Services;

namespace StorhaugenEats.API.Controllers;

[ApiController]
[Route("api/users")]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUserService;

    public UsersController(AppDbContext context, ICurrentUserService currentUserService)
    {
        _context = context;
        _currentUserService = currentUserService;
    }

    /// <summary>
    /// Get current user's profile
    /// </summary>
    [HttpGet("me")]
    public async Task<ActionResult<UserDto>> GetMyProfile()
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user == null)
            return NotFound();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            CurrentHouseholdId = user.CurrentHouseholdId,
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Update current user's profile
    /// </summary>
    [HttpPut("me")]
    public async Task<ActionResult<UserDto>> UpdateMyProfile([FromBody] UpdateUserDto dto)
    {
        var userId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(userId);

        if (user == null)
            return NotFound();

        if (dto.DisplayName != null)
            user.DisplayName = dto.DisplayName;

        if (dto.AvatarUrl != null)
            user.AvatarUrl = dto.AvatarUrl;

        if (dto.CurrentHouseholdId.HasValue)
        {
            // Verify user is a member of the household
            var isMember = await _context.HouseholdMembers
                .AnyAsync(hm => hm.HouseholdId == dto.CurrentHouseholdId.Value && hm.UserId == userId);

            if (!isMember)
                return BadRequest(new { message = "You are not a member of that household" });

            user.CurrentHouseholdId = dto.CurrentHouseholdId.Value;
        }

        user.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            CurrentHouseholdId = user.CurrentHouseholdId,
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Get a user's public profile (for household members)
    /// </summary>
    [HttpGet("{id}")]
    public async Task<ActionResult<UserDto>> GetUserProfile(Guid id)
    {
        var currentUserId = await _currentUserService.GetOrCreateUserIdAsync();
        var user = await _context.Users.FindAsync(id);

        if (user == null)
            return NotFound();

        // Check if current user shares a household with this user
        var sharedHousehold = await _context.HouseholdMembers
            .Where(hm => hm.UserId == currentUserId)
            .Select(hm => hm.HouseholdId)
            .Intersect(
                _context.HouseholdMembers
                    .Where(hm => hm.UserId == id)
                    .Select(hm => hm.HouseholdId)
            )
            .AnyAsync();

        if (!sharedHousehold && currentUserId != id)
            return Forbid();

        return Ok(new UserDto
        {
            Id = user.Id,
            Email = user.Email,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            CurrentHouseholdId = null, // Don't expose current household for privacy
            UniqueShareId = user.UniqueShareId,
            CreatedAt = user.CreatedAt
        });
    }

    /// <summary>
    /// Trigger HelloFresh ETL sync (checks 24-hour limit)
    /// </summary>
    [HttpPost("trigger-hellofresh-sync")]
    [AllowAnonymous] // Called on login, before auth
    public async Task<IActionResult> TriggerHelloFreshSync()
    {
        // Check last sync time from etl_sync_log
        var lastSync = await _context.EtlSyncLogs
            .Where(log => log.Status == "success")
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        var shouldSync = lastSync == null || (DateTime.UtcNow - lastSync.StartedAt).TotalHours > 24;

        if (!shouldSync)
        {
            return Ok(new
            {
                message = "HelloFresh sync not needed yet",
                lastSync = lastSync?.StartedAt,
                nextSync = lastSync?.StartedAt.AddHours(24)
            });
        }

        // Return a message to trigger sync via the HelloFresh controller
        return Ok(new
        {
            message = "HelloFresh sync is due",
            shouldSync = true,
            lastSync = lastSync?.StartedAt
        });

        // Note: Actual sync should be triggered via POST /api/HelloFresh/sync
        // This endpoint just checks if sync is needed
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Controllers\UsersController.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Data\AppDbContext.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Data;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
    {
    }

    public DbSet<User> Users { get; set; }
    public DbSet<Household> Households { get; set; }
    public DbSet<HouseholdMember> HouseholdMembers { get; set; }
    public DbSet<GlobalRecipe> GlobalRecipes { get; set; }
    public DbSet<HouseholdRecipe> HouseholdRecipes { get; set; }
    public DbSet<Rating> Ratings { get; set; }
    public DbSet<HouseholdInvite> HouseholdInvites { get; set; }
    public DbSet<HouseholdFriendship> HouseholdFriendships { get; set; }
    public DbSet<EtlSyncLog> EtlSyncLogs { get; set; }

    // New user-centric tables
    public DbSet<UserRecipe> UserRecipes { get; set; }
    public DbSet<UserFriendship> UserFriendships { get; set; }
    public DbSet<ActivityFeedItem> ActivityFeedItems { get; set; }

    // Tags for personal recipe organization
    public DbSet<RecipeTag> RecipeTags { get; set; }
    public DbSet<UserRecipeTag> UserRecipeTags { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure table names (match PostgreSQL schema)
        modelBuilder.Entity<User>().ToTable("users");
        modelBuilder.Entity<Household>().ToTable("households");
        modelBuilder.Entity<HouseholdMember>().ToTable("household_members");
        modelBuilder.Entity<GlobalRecipe>().ToTable("global_recipes");
        modelBuilder.Entity<HouseholdRecipe>().ToTable("household_recipes");
        modelBuilder.Entity<Rating>().ToTable("ratings");
        modelBuilder.Entity<HouseholdInvite>().ToTable("household_invites");
        modelBuilder.Entity<HouseholdFriendship>().ToTable("household_friendships");
        modelBuilder.Entity<EtlSyncLog>().ToTable("etl_sync_log");

        // New user-centric tables
        modelBuilder.Entity<UserRecipe>().ToTable("user_recipes");
        modelBuilder.Entity<UserFriendship>().ToTable("user_friendships");
        modelBuilder.Entity<ActivityFeedItem>().ToTable("activity_feed");

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.DisplayName).IsRequired().HasMaxLength(255);
            entity.Property(e => e.UniqueShareId).IsRequired().HasMaxLength(12);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.UniqueShareId).IsUnique();

            entity.HasOne(e => e.CurrentHousehold)
                .WithMany(h => h.Members)
                .HasForeignKey(e => e.CurrentHouseholdId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // Household configuration
        modelBuilder.Entity<Household>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(255);
            entity.Property(e => e.IsPrivate).HasDefaultValue(false);
            entity.Property(e => e.UniqueShareId).HasMaxLength(12);
            entity.HasIndex(e => e.UniqueShareId).IsUnique();
            entity.Property(e => e.Settings)
                .HasColumnType("jsonb")
                .HasDefaultValue("{}");

            entity.HasOne(e => e.Leader)
                .WithMany()
                .HasForeignKey(e => e.LeaderId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // HouseholdMember configuration
        modelBuilder.Entity<HouseholdMember>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Role).IsRequired().HasMaxLength(20).HasDefaultValue("member");

            entity.HasOne(e => e.Household)
                .WithMany(h => h.HouseholdMembers)
                .HasForeignKey(e => e.HouseholdId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasIndex(e => new { e.HouseholdId, e.UserId }).IsUnique();
        });

        // GlobalRecipe configuration
        modelBuilder.Entity<GlobalRecipe>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).IsRequired().HasMaxLength(255);
            entity.Property(e => e.Ingredients)
                .HasColumnType("jsonb")
                .IsRequired()
                .HasDefaultValue("[]");
            entity.Property(e => e.NutritionData).HasColumnType("jsonb");
            entity.Property(e => e.AverageRating).HasColumnType("decimal(3,2)").HasDefaultValue(0.00m);
            entity.Property(e => e.RatingCount).HasDefaultValue(0);
            entity.Property(e => e.HellofreshUuid).HasMaxLength(255);

            entity.HasIndex(e => e.IsHellofresh).HasFilter("is_hellofresh = true");
            entity.HasIndex(e => e.IsPublic).HasFilter("is_public = true");
            entity.HasIndex(e => e.AverageRating);
            entity.HasIndex(e => e.HellofreshUuid).IsUnique();

            entity.HasOne(e => e.CreatedByUser)
                .WithMany()
                .HasForeignKey(e => e.CreatedByUserId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // HouseholdRecipe configuration
        modelBuilder.Entity<HouseholdRecipe>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.LocalTitle).HasMaxLength(255);
            entity.Property(e => e.LocalIngredients).HasColumnType("jsonb");
            entity.Property(e => e.IsArchived).HasDefaultValue(false);
            entity.Property(e => e.IsPublic).HasDefaultValue(false);

            // Unique constraint: household can't have duplicate global recipes
            entity.HasIndex(e => new { e.HouseholdId, e.GlobalRecipeId })
                .IsUnique()
                .HasFilter("global_recipe_id IS NOT NULL");

            entity.HasIndex(e => e.IsPublic).HasFilter("is_public = true");

            entity.HasOne(e => e.Household)
                .WithMany(h => h.HouseholdRecipes)
                .HasForeignKey(e => e.HouseholdId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.GlobalRecipe)
                .WithMany()
                .HasForeignKey(e => e.GlobalRecipeId)
                .OnDelete(DeleteBehavior.SetNull);

            entity.HasOne(e => e.AddedByUser)
                .WithMany()
                .HasForeignKey(e => e.AddedByUserId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // HouseholdFriendship configuration
        modelBuilder.Entity<HouseholdFriendship>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(20).HasDefaultValue("pending");

            // Prevent duplicate requests between the same two households
            entity.HasIndex(e => new { e.RequesterHouseholdId, e.TargetHouseholdId }).IsUnique();

            entity.HasOne(e => e.RequesterHousehold)
                .WithMany(h => h.SentFriendRequests)
                .HasForeignKey(e => e.RequesterHouseholdId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.TargetHousehold)
                .WithMany(h => h.ReceivedFriendRequests)
                .HasForeignKey(e => e.TargetHouseholdId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Rating configuration
        modelBuilder.Entity<Rating>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Score).IsRequired();
            entity.ToTable(t => t.HasCheckConstraint("CK_Rating_Score", "score >= 0 AND score <= 10"));

            // Unique constraint: one rating per user per recipe
            entity.HasIndex(e => new { e.GlobalRecipeId, e.UserId }).IsUnique();

            entity.HasOne(e => e.GlobalRecipe)
                .WithMany(r => r.Ratings)
                .HasForeignKey(e => e.GlobalRecipeId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // HouseholdInvite configuration
        modelBuilder.Entity<HouseholdInvite>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(20).HasDefaultValue("pending");
            entity.Property(e => e.MergeRequested).HasDefaultValue(false);
            entity.Property(e => e.InvitedEmail).HasMaxLength(255);

            entity.HasOne(e => e.Household)
                .WithMany()
                .HasForeignKey(e => e.HouseholdId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.InvitedUser)
                .WithMany()
                .HasForeignKey(e => e.InvitedUserId)
                .OnDelete(DeleteBehavior.SetNull)
                .IsRequired(false);

            entity.HasOne(e => e.InvitedByUser)
                .WithMany()
                .HasForeignKey(e => e.InvitedByUserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // EtlSyncLog configuration
        modelBuilder.Entity<EtlSyncLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.SyncType).HasMaxLength(50).HasDefaultValue("hellofresh");
            entity.Property(e => e.Status).HasMaxLength(20);
            entity.Property(e => e.RecipesAdded).HasDefaultValue(0);
            entity.Property(e => e.RecipesUpdated).HasDefaultValue(0);
            entity.Property(e => e.BuildId).HasMaxLength(255);
            entity.Property(e => e.WeeksSynced).HasMaxLength(255);

            entity.HasIndex(e => e.StartedAt);
        });

        // ==========================================
        // NEW USER-CENTRIC ENTITY CONFIGURATIONS
        // ==========================================

        // UserRecipe configuration
        modelBuilder.Entity<UserRecipe>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.LocalTitle).HasMaxLength(255);
            entity.Property(e => e.LocalIngredients).HasColumnType("jsonb");
            entity.Property(e => e.LocalImageUrls).HasColumnType("jsonb").HasDefaultValue("[]");
            entity.Property(e => e.Visibility).IsRequired().HasMaxLength(20).HasDefaultValue("private");
            entity.Property(e => e.IsArchived).HasDefaultValue(false);

            // Indexes for common queries
            entity.HasIndex(e => e.UserId);
            entity.HasIndex(e => e.GlobalRecipeId);
            entity.HasIndex(e => e.Visibility);
            entity.HasIndex(e => e.CreatedAt);

            // Relationships
            entity.HasOne(e => e.User)
                .WithMany(u => u.UserRecipes)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.GlobalRecipe)
                .WithMany()
                .HasForeignKey(e => e.GlobalRecipeId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // UserFriendship configuration
        modelBuilder.Entity<UserFriendship>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(20).HasDefaultValue("pending");
            entity.Property(e => e.Message).HasMaxLength(255);

            // Prevent duplicate friend requests between the same two users
            entity.HasIndex(e => new { e.RequesterUserId, e.TargetUserId }).IsUnique();

            // Indexes for common queries
            entity.HasIndex(e => e.RequesterUserId);
            entity.HasIndex(e => e.TargetUserId);
            entity.HasIndex(e => e.Status);

            // Prevent self-friending at database level
            entity.ToTable(t => t.HasCheckConstraint("CK_UserFriendship_NoSelf", "requester_user_id != target_user_id"));

            // Relationships
            entity.HasOne(e => e.RequesterUser)
                .WithMany(u => u.SentFriendRequests)
                .HasForeignKey(e => e.RequesterUserId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.TargetUser)
                .WithMany(u => u.ReceivedFriendRequests)
                .HasForeignKey(e => e.TargetUserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // ActivityFeedItem configuration
        modelBuilder.Entity<ActivityFeedItem>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.ActivityType).IsRequired().HasMaxLength(50);
            entity.Property(e => e.TargetType).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Metadata).HasColumnType("jsonb").HasDefaultValue("{}");

            // Indexes for efficient feed queries
            entity.HasIndex(e => e.UserId);
            entity.HasIndex(e => e.CreatedAt).IsDescending();
            entity.HasIndex(e => e.ActivityType);

            // Composite index for feed pagination
            entity.HasIndex(e => new { e.UserId, e.CreatedAt });

            // Relationships
            entity.HasOne(e => e.User)
                .WithMany(u => u.Activities)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Update Rating to support UserRecipe
        modelBuilder.Entity<Rating>(entity =>
        {
            entity.HasOne(e => e.UserRecipe)
                .WithMany(r => r.Ratings)
                .HasForeignKey(e => e.UserRecipeId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Update GlobalRecipe for publishing relationship
        modelBuilder.Entity<GlobalRecipe>(entity =>
        {
            entity.Property(e => e.IsEditable).HasDefaultValue(true);

            entity.HasOne(e => e.PublishedFromUserRecipe)
                .WithMany()
                .HasForeignKey(e => e.PublishedFromUserRecipeId)
                .OnDelete(DeleteBehavior.SetNull);
        });

        // Update User with new fields
        modelBuilder.Entity<User>(entity =>
        {
            entity.Property(e => e.IsProfilePublic).HasDefaultValue(true);
            entity.Property(e => e.Bio).HasMaxLength(500);
            entity.Property(e => e.FavoriteCuisines).HasColumnType("jsonb").HasDefaultValue("[]");
        });

        // ==========================================
        // RECIPE TAGS FOR PERSONAL ORGANIZATION
        // ==========================================

        modelBuilder.Entity<RecipeTag>().ToTable("recipe_tags");
        modelBuilder.Entity<UserRecipeTag>().ToTable("user_recipe_tags");

        // RecipeTag configuration
        modelBuilder.Entity<RecipeTag>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Color).HasMaxLength(7);
            entity.Property(e => e.Icon).HasMaxLength(50);

            // Unique tag names per user
            entity.HasIndex(e => new { e.UserId, e.Name }).IsUnique();

            // Index for user's tags
            entity.HasIndex(e => e.UserId);

            // Relationship
            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // UserRecipeTag (join table) configuration
        modelBuilder.Entity<UserRecipeTag>(entity =>
        {
            entity.HasKey(e => e.Id);

            // Unique constraint: a recipe can only have each tag once
            entity.HasIndex(e => new { e.UserRecipeId, e.TagId }).IsUnique();

            // Relationships
            entity.HasOne(e => e.UserRecipe)
                .WithMany(r => r.UserRecipeTags)
                .HasForeignKey(e => e.UserRecipeId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.Tag)
                .WithMany(t => t.UserRecipeTags)
                .HasForeignKey(e => e.TagId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Data\AppDbContext.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Helpers\JsonHelper.cs
================================================================================
using System.Text.Json;

namespace StorhaugenEats.API.Helpers;

public static class JsonHelper
{
    /// <summary>
    /// Converts a JSON string to a List of strings
    /// </summary>
    public static List<string> JsonToList(string? json)
    {
        if (string.IsNullOrWhiteSpace(json) || json == "[]")
        {
            return new List<string>();
        }

        try
        {
            return JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>();
        }
        catch
        {
            return new List<string>();
        }
    }

    /// <summary>
    /// Converts a List of strings to a JSON string
    /// </summary>
    public static string ListToJson(List<string>? list)
    {
        if (list == null || list.Count == 0)
        {
            return "[]";
        }

        return JsonSerializer.Serialize(list);
    }

    /// <summary>
    /// Safely gets a string from a nullable value, returns empty string if null
    /// </summary>
    public static string SafeString(string? value)
    {
        return value ?? string.Empty;
    }

    /// <summary>
    /// Converts an object to a JSON string, returns null if object is null
    /// </summary>
    public static string? ObjectToJson(object? obj)
    {
        if (obj == null)
        {
            return null;
        }

        try
        {
            return JsonSerializer.Serialize(obj);
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Converts a JSON string to an object, returns null if string is null or invalid
    /// </summary>
    public static object? JsonToObject(string? json)
    {
        if (string.IsNullOrWhiteSpace(json))
        {
            return null;
        }

        try
        {
            return JsonSerializer.Deserialize<object>(json);
        }
        catch
        {
            return null;
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Helpers\JsonHelper.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\ActivityFeedItem.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents an activity item in the social feed.
/// Activities are denormalized for fast query performance.
/// </summary>
[Table("activity_feed")]
public class ActivityFeedItem
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who performed the activity.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Type of activity: 'rated', 'added', 'published', 'joined_household'
    /// </summary>
    [Required]
    [Column("activity_type")]
    [MaxLength(50)]
    public string ActivityType { get; set; } = string.Empty;

    /// <summary>
    /// Type of target entity: 'user_recipe', 'global_recipe', 'household'
    /// </summary>
    [Required]
    [Column("target_type")]
    [MaxLength(50)]
    public string TargetType { get; set; } = string.Empty;

    /// <summary>
    /// ID of the target entity.
    /// </summary>
    [Required]
    [Column("target_id")]
    public Guid TargetId { get; set; }

    /// <summary>
    /// Additional metadata as JSON (recipe name, rating score, household name, etc.)
    /// Example: { "recipeName": "Spaghetti", "rating": 8, "imageUrl": "..." }
    /// </summary>
    [Column("metadata", TypeName = "jsonb")]
    public string Metadata { get; set; } = "{}";

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;

    // Static factory methods for creating activities
    public static ActivityFeedItem CreateRatingActivity(Guid userId, Guid recipeId, string recipeName, int rating, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["rating"] = rating,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "rated",
            TargetType = "user_recipe",
            TargetId = recipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }

    public static ActivityFeedItem CreateAddedRecipeActivity(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "added",
            TargetType = "user_recipe",
            TargetId = recipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }

    public static ActivityFeedItem CreatePublishedActivity(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["recipeName"] = recipeName,
            ["imageUrl"] = imageUrl
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "published",
            TargetType = "global_recipe",
            TargetId = globalRecipeId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }

    public static ActivityFeedItem CreateJoinedHouseholdActivity(Guid userId, Guid householdId, string householdName)
    {
        var metadata = new Dictionary<string, object?>
        {
            ["householdName"] = householdName
        };

        return new ActivityFeedItem
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            ActivityType = "joined_household",
            TargetType = "household",
            TargetId = householdId,
            Metadata = System.Text.Json.JsonSerializer.Serialize(metadata),
            CreatedAt = DateTime.UtcNow
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\ActivityFeedItem.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\EtlSyncLog.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("etl_sync_log")]
public class EtlSyncLog
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Column("sync_type")]
    [MaxLength(50)]
    public string SyncType { get; set; } = "hellofresh";

    [Column("status")]
    [MaxLength(20)]
    public string? Status { get; set; } // "success", "failed", "partial"

    [Column("recipes_added")]
    public int RecipesAdded { get; set; } = 0;

    [Column("recipes_updated")]
    public int RecipesUpdated { get; set; } = 0;

    [Column("error_message")]
    public string? ErrorMessage { get; set; }

    [Column("build_id")]
    [MaxLength(255)]
    public string? BuildId { get; set; }

    [Column("weeks_synced")]
    [MaxLength(255)]
    public string? WeeksSynced { get; set; }

    [Column("started_at")]
    public DateTime StartedAt { get; set; } = DateTime.UtcNow;

    [Column("completed_at")]
    public DateTime? CompletedAt { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\EtlSyncLog.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\GlobalRecipe.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("global_recipes")]
public class GlobalRecipe
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("title")]
    [MaxLength(255)]
    public string Title { get; set; } = string.Empty;

    [Column("description")]
    public string? Description { get; set; }

    [Column("image_url")]
    public string? ImageUrl { get; set; }

    [Required]
    [Column("ingredients", TypeName = "jsonb")]
    public string Ingredients { get; set; } = "[]";

    [Column("nutrition_data", TypeName = "jsonb")]
    public string? NutritionData { get; set; }

    [Column("cook_time_minutes")]
    public int? CookTimeMinutes { get; set; }

    [Column("difficulty")]
    [MaxLength(50)]
    public string? Difficulty { get; set; }

    // Source tracking
    [Column("is_hellofresh")]
    public bool IsHellofresh { get; set; } = false;

    [Column("hellofresh_uuid")]
    [MaxLength(255)]
    public string? HellofreshUuid { get; set; }

    [Column("created_by_user_id")]
    public Guid? CreatedByUserId { get; set; }

    // Visibility
    [Column("is_public")]
    public bool IsPublic { get; set; } = false;

    // Aggregated ratings
    [Column("average_rating")]
    public decimal AverageRating { get; set; } = 0.00m;

    [Column("rating_count")]
    public int RatingCount { get; set; } = 0;

    [Column("tags", TypeName = "jsonb")]
    public string Tags { get; set; } = "[]";

    [Column("cuisine")]
    [MaxLength(100)]
    public string? Cuisine { get; set; }

    [Column("servings")]
    public int? Servings { get; set; }

    [Column("prep_time_minutes")]
    public int? PrepTimeMinutes { get; set; }

    [Column("total_time_minutes")]
    public int? TotalTimeMinutes { get; set; }

    [Column("hellofresh_slug")]
    [MaxLength(255)]
    public string? HellofreshSlug { get; set; }

    [Column("total_ratings")]
    public int TotalRatings { get; set; } = 0;

    [Column("total_times_added")]
    public int TotalTimesAdded { get; set; } = 0;

    [Column("image_urls", TypeName = "jsonb")]
    public string ImageUrls { get; set; } = "[]";

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Publishing-related fields
    /// <summary>
    /// Reference to the original UserRecipe this was published from (if any).
    /// </summary>
    [Column("published_from_user_recipe_id")]
    public Guid? PublishedFromUserRecipeId { get; set; }

    /// <summary>
    /// Whether this recipe can be edited. HelloFresh recipes are not editable.
    /// </summary>
    [Column("is_editable")]
    public bool IsEditable { get; set; } = true;

    // Navigation properties
    public User? CreatedByUser { get; set; }
    public UserRecipe? PublishedFromUserRecipe { get; set; }
    public ICollection<Rating> Ratings { get; set; } = new List<Rating>();

    // Backward compatibility properties
    [NotMapped]
    public string Name
    {
        get => Title;
        set => Title = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\GlobalRecipe.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\Household.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("households")]
public class Household
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("name")]
    [MaxLength(255)]
    public string Name { get; set; } = string.Empty;

    [Column("leader_id")]
    public Guid? LeaderId { get; set; }

    [Column("settings", TypeName = "jsonb")]
    public string Settings { get; set; } = "{}";

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("is_private")]
    public bool IsPrivate { get; set; } = false;

    [Column("unique_share_id")]
    [MaxLength(12)]
    public string? UniqueShareId { get; set; }

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User? Leader { get; set; }
    public ICollection<User> Members { get; set; } = new List<User>();
    public ICollection<HouseholdRecipe> HouseholdRecipes { get; set; } = new List<HouseholdRecipe>();
    public ICollection<HouseholdMember> HouseholdMembers { get; set; } = new List<HouseholdMember>();
    public ICollection<HouseholdFriendship> SentFriendRequests { get; set; } = new List<HouseholdFriendship>();
    public ICollection<HouseholdFriendship> ReceivedFriendRequests { get; set; } = new List<HouseholdFriendship>();

    // Backward compatibility properties
    [NotMapped]
    public Guid? CreatedById
    {
        get => LeaderId;
        set => LeaderId = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\Household.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\HouseholdFriendship.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// DEPRECATED: Friendships between households.
/// Use UserFriendship for user-to-user friendships.
/// This model is maintained for backward compatibility and migration purposes.
/// </summary>
[Obsolete("Use UserFriendship instead. This model will be removed after migration is complete.")]
[Table("household_friendships")]
public class HouseholdFriendship
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("requester_household_id")]
    public Guid RequesterHouseholdId { get; set; }

    [Required]
    [Column("target_household_id")]
    public Guid TargetHouseholdId { get; set; }

    [Required]
    [Column("status")]
    [MaxLength(20)]
    public string Status { get; set; } = "pending";

    [Column("requested_by_user_id")]
    public Guid RequestedByUserId { get; set; }

    [Column("responded_by_user_id")]
    public Guid? RespondedByUserId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("responded_at")]
    public DateTime? RespondedAt { get; set; }

    [Column("message")]
    [MaxLength(255)]
    public string? Message { get; set; }

    public Household? RequesterHousehold { get; set; }
    public Household? TargetHousehold { get; set; }
    public User? RequestedByUser { get; set; }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\HouseholdFriendship.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\HouseholdInvite.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("household_invites")]
public class HouseholdInvite
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("household_id")]
    public Guid HouseholdId { get; set; }

    [Column("invited_user_id")]
    public Guid? InvitedUserId { get; set; }

    [Column("invited_email")]
    [MaxLength(255)]
    public string? InvitedEmail { get; set; }

    [Required]
    [Column("invited_by_user_id")]
    public Guid InvitedByUserId { get; set; }

    [Required]
    [Column("status")]
    [MaxLength(20)]
    public string Status { get; set; } = "pending"; // "pending", "accepted", "rejected"

    [Column("merge_requested")]
    public bool MergeRequested { get; set; } = false;

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Household Household { get; set; } = null!;
    public User? InvitedUser { get; set; }
    public User InvitedByUser { get; set; } = null!;

    // Backward compatibility properties
    [NotMapped]
    public Guid InvitedById
    {
        get => InvitedByUserId;
        set => InvitedByUserId = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\HouseholdInvite.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\HouseholdMember.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("household_members")]
public class HouseholdMember
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("household_id")]
    public Guid HouseholdId { get; set; }

    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    [Required]
    [Column("role")]
    [MaxLength(20)]
    public string Role { get; set; } = "member"; // "admin", "member"

    [Column("joined_at")]
    public DateTime JoinedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Household Household { get; set; } = null!;
    public User User { get; set; } = null!;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\HouseholdMember.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\HouseholdRecipe.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// DEPRECATED: Recipes scoped to a household.
/// Use UserRecipe for user-centric recipe ownership.
/// This model is maintained for backward compatibility and migration purposes.
/// </summary>
[Obsolete("Use UserRecipe instead. This model will be removed after migration is complete.")]
[Table("household_recipes")]
public class HouseholdRecipe
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("household_id")]
    public Guid HouseholdId { get; set; }

    // Reference/Fork Logic
    [Column("global_recipe_id")]
    public Guid? GlobalRecipeId { get; set; }

    // Local data (used when forked, or as personal notes when linked)
    [Column("local_title")]
    [MaxLength(255)]
    public string? LocalTitle { get; set; }

    [Column("local_description")]
    public string? LocalDescription { get; set; }

    [Column("local_ingredients", TypeName = "jsonb")]
    public string? LocalIngredients { get; set; }

    [Column("is_public")]
    public bool IsPublic { get; set; } = false;

    [Column("local_image_url")]
    public string? LocalImageUrl { get; set; }

    [Column("personal_notes")]
    public string? PersonalNotes { get; set; }

    // Metadata
    [Column("added_by_user_id")]
    public Guid? AddedByUserId { get; set; }

    [Column("is_archived")]
    public bool IsArchived { get; set; } = false;

    [Column("archived_date")]
    public DateTime? ArchivedDate { get; set; }

    [Column("archived_by_user_id")]
    public Guid? ArchivedByUserId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Household Household { get; set; } = null!;
    public GlobalRecipe? GlobalRecipe { get; set; }
    public User? AddedByUser { get; set; }
    public User? ArchivedBy { get; set; }
    public ICollection<Rating> Ratings { get; set; } = new List<Rating>();

    // Helper property to determine mode
    [NotMapped]
    public string RecipeMode => GlobalRecipeId.HasValue ? "linked" : "forked";

    // Helper to get display title
    [NotMapped]
    public string DisplayTitle => LocalTitle ?? GlobalRecipe?.Title ?? "Untitled Recipe";

    // Backward compatibility properties
    [NotMapped]
    public string? Name
    {
        get => LocalTitle ?? GlobalRecipe?.Title;
        set => LocalTitle = value;
    }

    [NotMapped]
    public string? Description
    {
        get => LocalDescription ?? GlobalRecipe?.Description;
        set => LocalDescription = value;
    }

    [NotMapped]
    public string? ImageUrls
    {
        get => LocalImageUrl != null ? $"[\"{LocalImageUrl}\"]" : GlobalRecipe?.ImageUrls;
        set => LocalImageUrl = value;
    }

    [NotMapped]
    public User? AddedBy => AddedByUser;

    [NotMapped]
    public DateTime DateAdded => CreatedAt;

    [NotMapped]
    public bool IsForked => !GlobalRecipeId.HasValue;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\HouseholdRecipe.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\Rating.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("ratings")]
public class Rating
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Column("global_recipe_id")]
    public Guid? GlobalRecipeId { get; set; }

    [Column("household_recipe_id")]
    public Guid? HouseholdRecipeId { get; set; }

    /// <summary>
    /// Reference to the user recipe being rated (new user-centric model).
    /// </summary>
    [Column("user_recipe_id")]
    public Guid? UserRecipeId { get; set; }

    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    [Required]
    [Column("score")]
    [Range(0, 10)]
    public int Score { get; set; }

    [Column("comment")]
    public string? Comment { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public GlobalRecipe? GlobalRecipe { get; set; }
    public HouseholdRecipe? HouseholdRecipe { get; set; }
    public UserRecipe? UserRecipe { get; set; }
    public User User { get; set; } = null!;

    // Backward compatibility properties
    [NotMapped]
    public int RatingValue
    {
        get => Score;
        set => Score = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\Rating.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\RecipeTag.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a personal tag/category for organizing recipes.
/// Tags are user-owned and only visible to the owner.
/// Examples: "Kylling", "Rask middag", "Grill", "Søndag"
/// </summary>
[Table("recipe_tags")]
public class RecipeTag
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who owns this tag.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// The tag name (e.g., "Kylling", "Rask")
    /// </summary>
    [Required]
    [Column("name")]
    [MaxLength(50)]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Optional color for visual distinction (hex code).
    /// </summary>
    [Column("color")]
    [MaxLength(7)]
    public string? Color { get; set; }

    /// <summary>
    /// Optional icon name (Material Icons).
    /// </summary>
    [Column("icon")]
    [MaxLength(50)]
    public string? Icon { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public ICollection<UserRecipeTag> UserRecipeTags { get; set; } = new List<UserRecipeTag>();
}

/// <summary>
/// Join table linking UserRecipes to RecipeTags.
/// Allows a recipe to have multiple tags and a tag to be applied to multiple recipes.
/// </summary>
[Table("user_recipe_tags")]
public class UserRecipeTag
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("user_recipe_id")]
    public Guid UserRecipeId { get; set; }

    [Required]
    [Column("tag_id")]
    public Guid TagId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public UserRecipe UserRecipe { get; set; } = null!;
    public RecipeTag Tag { get; set; } = null!;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\RecipeTag.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\User.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

[Table("users")]
public class User
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    [Required]
    [Column("email")]
    [MaxLength(255)]
    public string Email { get; set; } = string.Empty;

    [Required]
    [Column("display_name")]
    [MaxLength(255)]
    public string DisplayName { get; set; } = string.Empty;

    [Column("avatar_url")]
    public string? AvatarUrl { get; set; }

    [Required]
    [Column("unique_share_id")]
    [MaxLength(12)]
    public string UniqueShareId { get; set; } = string.Empty;

    [Column("current_household_id")]
    public Guid? CurrentHouseholdId { get; set; }

    [Column("supabase_user_id")]
    [MaxLength(255)]
    public string? SupabaseUserId { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // New fields for user-centric social features
    [Column("is_profile_public")]
    public bool IsProfilePublic { get; set; } = true;

    [Column("bio")]
    [MaxLength(500)]
    public string? Bio { get; set; }

    [Column("favorite_cuisines", TypeName = "jsonb")]
    public string FavoriteCuisines { get; set; } = "[]";

    // Navigation properties
    public Household? CurrentHousehold { get; set; }
    public ICollection<UserRecipe> UserRecipes { get; set; } = new List<UserRecipe>();
    public ICollection<UserFriendship> SentFriendRequests { get; set; } = new List<UserFriendship>();
    public ICollection<UserFriendship> ReceivedFriendRequests { get; set; } = new List<UserFriendship>();
    public ICollection<ActivityFeedItem> Activities { get; set; } = new List<ActivityFeedItem>();

    // Backward compatibility properties
    [NotMapped]
    public Guid UserId => Id;
}


================================================================================
FILE END: \StorhaugenEats.API\Models\User.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\UserFriendship.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a friendship connection between two users.
/// This enables the social features of the app - users can see what their friends
/// are cooking and rating.
/// </summary>
[Table("user_friendships")]
public class UserFriendship
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who initiated the friend request.
    /// </summary>
    [Required]
    [Column("requester_user_id")]
    public Guid RequesterUserId { get; set; }

    /// <summary>
    /// The user who received the friend request.
    /// </summary>
    [Required]
    [Column("target_user_id")]
    public Guid TargetUserId { get; set; }

    /// <summary>
    /// Status of the friendship: 'pending', 'accepted', 'rejected', 'blocked'
    /// </summary>
    [Required]
    [Column("status")]
    [MaxLength(20)]
    public string Status { get; set; } = "pending";

    /// <summary>
    /// Optional message sent with the friend request.
    /// </summary>
    [Column("message")]
    [MaxLength(255)]
    public string? Message { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("responded_at")]
    public DateTime? RespondedAt { get; set; }

    // Navigation properties
    public User RequesterUser { get; set; } = null!;
    public User TargetUser { get; set; } = null!;

    // Helper properties
    [NotMapped]
    public bool IsPending => Status == "pending";

    [NotMapped]
    public bool IsAccepted => Status == "accepted";

    /// <summary>
    /// Gets the "other" user from the perspective of the given user ID.
    /// </summary>
    public User? GetOtherUser(Guid currentUserId)
    {
        if (currentUserId == RequesterUserId)
            return TargetUser;
        if (currentUserId == TargetUserId)
            return RequesterUser;
        return null;
    }

    /// <summary>
    /// Gets the ID of the "other" user from the perspective of the given user ID.
    /// </summary>
    public Guid GetOtherUserId(Guid currentUserId)
    {
        return currentUserId == RequesterUserId ? TargetUserId : RequesterUserId;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\UserFriendship.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Models\UserRecipe.cs
================================================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace StorhaugenEats.API.Models;

/// <summary>
/// Represents a recipe owned by a user. This is the new user-centric model that replaces
/// the household-centric HouseholdRecipe. Users own their recipes directly, and households
/// see an aggregated view of their members' recipes.
/// </summary>
[Table("user_recipes")]
public class UserRecipe
{
    [Key]
    [Column("id")]
    public Guid Id { get; set; }

    /// <summary>
    /// The user who owns this recipe.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Optional link to a global recipe. When set, this recipe references the global recipe.
    /// When null, the recipe uses local data only.
    /// </summary>
    [Column("global_recipe_id")]
    public Guid? GlobalRecipeId { get; set; }

    // Local recipe data (used when not linked or when user has customizations)
    [Column("local_title")]
    [MaxLength(255)]
    public string? LocalTitle { get; set; }

    [Column("local_description")]
    public string? LocalDescription { get; set; }

    [Column("local_ingredients", TypeName = "jsonb")]
    public string? LocalIngredients { get; set; }

    [Column("local_image_url")]
    public string? LocalImageUrl { get; set; }

    [Column("local_image_urls", TypeName = "jsonb")]
    public string LocalImageUrls { get; set; } = "[]";

    /// <summary>
    /// Personal notes visible only to the owner.
    /// </summary>
    [Column("personal_notes")]
    public string? PersonalNotes { get; set; }

    /// <summary>
    /// Visibility level: 'private', 'household', 'friends', 'public'
    /// - private: Only the owner can see
    /// - household: Members of user's households can see
    /// - friends: User's friends can see
    /// - public: Everyone can see (and it appears in browse)
    /// </summary>
    [Required]
    [Column("visibility")]
    [MaxLength(20)]
    public string Visibility { get; set; } = "private";

    [Column("is_archived")]
    public bool IsArchived { get; set; } = false;

    [Column("archived_date")]
    public DateTime? ArchivedDate { get; set; }

    [Column("created_at")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [Column("updated_at")]
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public GlobalRecipe? GlobalRecipe { get; set; }
    public ICollection<Rating> Ratings { get; set; } = new List<Rating>();
    public ICollection<UserRecipeTag> UserRecipeTags { get; set; } = new List<UserRecipeTag>();

    // Helper properties
    [NotMapped]
    public bool IsLinkedToGlobal => GlobalRecipeId.HasValue;

    [NotMapped]
    public string DisplayTitle => LocalTitle ?? GlobalRecipe?.Title ?? "Untitled Recipe";

    [NotMapped]
    public string? DisplayDescription => LocalDescription ?? GlobalRecipe?.Description;

    [NotMapped]
    public string DisplayImageUrls => !string.IsNullOrEmpty(LocalImageUrl)
        ? $"[\"{LocalImageUrl}\"]"
        : (!string.IsNullOrEmpty(LocalImageUrls) && LocalImageUrls != "[]"
            ? LocalImageUrls
            : GlobalRecipe?.ImageUrls ?? "[]");

    // Backward compatibility
    [NotMapped]
    public string? Name
    {
        get => LocalTitle ?? GlobalRecipe?.Title;
        set => LocalTitle = value;
    }

    [NotMapped]
    public string? Description
    {
        get => LocalDescription ?? GlobalRecipe?.Description;
        set => LocalDescription = value;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Models\UserRecipe.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ActivityFeedService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using System.Text.Json;

namespace StorhaugenEats.API.Services;

public class ActivityFeedService : IActivityFeedService
{
    private readonly AppDbContext _context;
    private readonly IUserFriendshipService _friendshipService;

    public ActivityFeedService(AppDbContext context, IUserFriendshipService friendshipService)
    {
        _context = context;
        _friendshipService = friendshipService;
    }

    public async Task<ActivityFeedPagedResult> GetFeedAsync(Guid userId, ActivityFeedQuery query)
    {
        // Get friend IDs
        var friendIds = await _friendshipService.GetFriendIdsAsync(userId);

        // If no friends, return empty feed
        if (!friendIds.Any())
        {
            return new ActivityFeedPagedResult
            {
                Items = new List<ActivityFeedItemDto>(),
                TotalCount = 0,
                Page = query.Page,
                PageSize = query.PageSize
            };
        }

        // Filter by specific users if provided, otherwise show all friends
        var targetUserIds = query.UserIds?.Any() == true
            ? query.UserIds.Intersect(friendIds).ToList()
            : friendIds;

        var queryable = _context.ActivityFeedItems
            .Include(a => a.User)
            .Where(a => targetUserIds.Contains(a.UserId));

        // Filter by activity types
        if (query.Types?.Any() == true)
        {
            queryable = queryable.Where(a => query.Types.Contains(a.ActivityType));
        }

        queryable = queryable.OrderByDescending(a => a.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var items = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new ActivityFeedPagedResult
        {
            Items = items.Select(MapToDto).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<ActivityFeedPagedResult> GetUserActivityAsync(Guid userId, int page = 1, int pageSize = 20)
    {
        var queryable = _context.ActivityFeedItems
            .Include(a => a.User)
            .Where(a => a.UserId == userId)
            .OrderByDescending(a => a.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var items = await queryable
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return new ActivityFeedPagedResult
        {
            Items = items.Select(MapToDto).ToList(),
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        };
    }

    public async Task<ActivitySummaryDto> GetActivitySummaryAsync(Guid userId)
    {
        var activities = await _context.ActivityFeedItems
            .Where(a => a.UserId == userId)
            .ToListAsync();

        return new ActivitySummaryDto
        {
            TotalActivities = activities.Count,
            RecipesAdded = activities.Count(a => a.ActivityType == "added"),
            RecipesRated = activities.Count(a => a.ActivityType == "rated"),
            RecipesPublished = activities.Count(a => a.ActivityType == "published"),
            LastActivityDate = activities.OrderByDescending(a => a.CreatedAt).FirstOrDefault()?.CreatedAt
        };
    }

    public async Task RecordRatingActivityAsync(Guid userId, Guid recipeId, string recipeName, int rating, string? imageUrl = null)
    {
        var activity = ActivityFeedItem.CreateRatingActivity(userId, recipeId, recipeName, rating, imageUrl);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task RecordAddedRecipeActivityAsync(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null)
    {
        var activity = ActivityFeedItem.CreateAddedRecipeActivity(userId, recipeId, recipeName, imageUrl);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task RecordPublishedActivityAsync(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null)
    {
        var activity = ActivityFeedItem.CreatePublishedActivity(userId, globalRecipeId, recipeName, imageUrl);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task RecordJoinedHouseholdActivityAsync(Guid userId, Guid householdId, string householdName)
    {
        var activity = ActivityFeedItem.CreateJoinedHouseholdActivity(userId, householdId, householdName);
        _context.ActivityFeedItems.Add(activity);
        await _context.SaveChangesAsync();
    }

    public async Task CleanupOldActivitiesAsync(int daysToKeep = 90)
    {
        var cutoffDate = DateTime.UtcNow.AddDays(-daysToKeep);

        var oldActivities = await _context.ActivityFeedItems
            .Where(a => a.CreatedAt < cutoffDate)
            .ToListAsync();

        if (oldActivities.Any())
        {
            _context.ActivityFeedItems.RemoveRange(oldActivities);
            await _context.SaveChangesAsync();
        }
    }

    private ActivityFeedItemDto MapToDto(ActivityFeedItem activity)
    {
        var metadata = ParseMetadata(activity.Metadata);

        return new ActivityFeedItemDto
        {
            Id = activity.Id,
            UserId = activity.UserId,
            UserDisplayName = activity.User?.DisplayName ?? "Unknown",
            UserAvatarUrl = activity.User?.AvatarUrl,
            ActivityType = activity.ActivityType,
            TargetType = activity.TargetType,
            TargetId = activity.TargetId,
            RecipeName = metadata.GetValueOrDefault("recipeName")?.ToString(),
            RecipeImageUrl = metadata.GetValueOrDefault("imageUrl")?.ToString(),
            RatingScore = metadata.TryGetValue("rating", out var ratingObj) && ratingObj is JsonElement elem
                ? elem.TryGetInt32(out var rating) ? rating : null
                : null,
            HouseholdName = metadata.GetValueOrDefault("householdName")?.ToString(),
            CreatedAt = activity.CreatedAt
        };
    }

    private static Dictionary<string, object?> ParseMetadata(string json)
    {
        try
        {
            return JsonSerializer.Deserialize<Dictionary<string, object?>>(json) ?? new();
        }
        catch
        {
            return new Dictionary<string, object?>();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\CurrentUserService.cs
================================================================================
using System.Security.Claims;
using System.Text.Json; // Add this
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class CurrentUserService : ICurrentUserService
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly AppDbContext _context;

    public CurrentUserService(IHttpContextAccessor httpContextAccessor, AppDbContext context)
    {
        _httpContextAccessor = httpContextAccessor;
        _context = context;
    }

    public string? GetUserEmail()
    {
        return _httpContextAccessor.HttpContext?.User?.FindFirst(ClaimTypes.Email)?.Value
            ?? _httpContextAccessor.HttpContext?.User?.FindFirst("email")?.Value;
    }

    public string? GetUserSubject()
    {
        return _httpContextAccessor.HttpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value
            ?? _httpContextAccessor.HttpContext?.User?.FindFirst("sub")?.Value;
    }

    public bool IsAuthenticated()
    {
        return _httpContextAccessor.HttpContext?.User?.Identity?.IsAuthenticated ?? false;
    }

    public async Task<Guid> GetOrCreateUserIdAsync()
    {
        if (!IsAuthenticated())
        {
            throw new UnauthorizedAccessException("User is not authenticated");
        }

        var email = GetUserEmail();
        var subject = GetUserSubject();

        if (string.IsNullOrEmpty(email))
        {
            throw new UnauthorizedAccessException("User email not found in token");
        }

        // 1. Resolve the best possible display name from the token
        var displayName = GetDisplayNameFromToken(email);
        var avatarUrl = GetAvatarFromToken();

        // 2. Check DB
        var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == email);

        if (user == null)
        {
            // --- CREATE NEW USER ---
            user = new User
            {
                Id = Guid.NewGuid(),
                Email = email,
                DisplayName = displayName, // Now uses the parsed name
                AvatarUrl = avatarUrl,
                SupabaseUserId = subject,
                UniqueShareId = GenerateUniqueShareId(),
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
        }
        else
        {
            // --- AUTO-UPDATE EXISTING USER ---
            // If the DB has an email-like name, but we found a real name in the token, update it!
            bool dataChanged = false;

            // Update Name if better one found
            if (user.DisplayName.Contains("@") && !displayName.Contains("@"))
            {
                user.DisplayName = displayName;
                dataChanged = true;
            }

            // Update Avatar if new one found
            if (string.IsNullOrEmpty(user.AvatarUrl) && !string.IsNullOrEmpty(avatarUrl))
            {
                user.AvatarUrl = avatarUrl;
                dataChanged = true;
            }

            if (dataChanged)
            {
                user.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
        }

        return user.Id;
    }

    // --- HELPER METHODS ---

    private string GetDisplayNameFromToken(string email)
    {
        var user = _httpContextAccessor.HttpContext?.User;
        if (user == null) return email.Split('@')[0];

        // 1. Try standard claims
        var name = user.FindFirst("name")?.Value ?? user.FindFirst(ClaimTypes.Name)?.Value;

        // 2. Try parsing Supabase 'user_metadata' claim
        if (string.IsNullOrEmpty(name) || name.Contains("@"))
        {
            var metadata = user.FindFirst("user_metadata")?.Value;
            if (!string.IsNullOrEmpty(metadata))
            {
                try
                {
                    using var doc = JsonDocument.Parse(metadata);
                    if (doc.RootElement.TryGetProperty("name", out var nameProp))
                    {
                        name = nameProp.GetString();
                    }
                    else if (doc.RootElement.TryGetProperty("full_name", out var fullProp))
                    {
                        name = fullProp.GetString();
                    }
                }
                catch { /* Ignore JSON errors */ }
            }
        }

        // 3. Fallback to Email prefix
        return !string.IsNullOrWhiteSpace(name) ? name : email.Split('@')[0];
    }

    private string? GetAvatarFromToken()
    {
        var user = _httpContextAccessor.HttpContext?.User;
        if (user == null) return null;

        // 1. Try standard picture claim
        var avatar = user.FindFirst("picture")?.Value;

        // 2. Try Supabase 'user_metadata'
        if (string.IsNullOrEmpty(avatar))
        {
            var metadata = user.FindFirst("user_metadata")?.Value;
            if (!string.IsNullOrEmpty(metadata))
            {
                try
                {
                    using var doc = JsonDocument.Parse(metadata);
                    if (doc.RootElement.TryGetProperty("avatar_url", out var avProp))
                    {
                        avatar = avProp.GetString();
                    }
                    else if (doc.RootElement.TryGetProperty("picture", out var picProp))
                    {
                        avatar = picProp.GetString();
                    }
                }
                catch { }
            }
        }
        return avatar;
    }

    private string GenerateUniqueShareId()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        var random = new Random();
        return new string(Enumerable.Repeat(chars, 12)
            .Select(s => s[random.Next(s.Length)]).ToArray());
    }
}

================================================================================
FILE END: \StorhaugenEats.API\Services\CurrentUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\GlobalRecipeService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class GlobalRecipeService : IGlobalRecipeService
{
    private readonly AppDbContext _context;

    public GlobalRecipeService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<GlobalRecipe?> GetByIdAsync(Guid id)
    {
        return await _context.GlobalRecipes
            .Include(gr => gr.Ratings)
            .FirstOrDefaultAsync(gr => gr.Id == id);
    }

    public async Task<GlobalRecipe?> GetByHellofreshUuidAsync(string uuid)
    {
        return await _context.GlobalRecipes
            .FirstOrDefaultAsync(gr => gr.HellofreshUuid == uuid);
    }

    public async Task<IEnumerable<GlobalRecipe>> GetPublicRecipesAsync(int skip = 0, int take = 50, string? sortBy = "rating")
    {
        var query = _context.GlobalRecipes
            .Where(gr => gr.IsHellofresh || gr.IsPublic);

        query = sortBy?.ToLower() switch
        {
            "rating" => query.OrderByDescending(gr => gr.AverageRating).ThenByDescending(gr => gr.RatingCount),
            "date" => query.OrderByDescending(gr => gr.CreatedAt),
            "title" => query.OrderBy(gr => gr.Title),
            _ => query.OrderByDescending(gr => gr.AverageRating)
        };

        return await query
            .Skip(skip)
            .Take(take)
            .ToListAsync();
    }

    public async Task<GlobalRecipe> CreateAsync(GlobalRecipe recipe)
    {
        recipe.CreatedAt = DateTime.UtcNow;
        recipe.UpdatedAt = DateTime.UtcNow;
        _context.GlobalRecipes.Add(recipe);
        await _context.SaveChangesAsync();
        return recipe;
    }

    public async Task<GlobalRecipe> UpdateAsync(GlobalRecipe recipe)
    {
        recipe.UpdatedAt = DateTime.UtcNow;
        _context.GlobalRecipes.Update(recipe);
        await _context.SaveChangesAsync();
        return recipe;
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var recipe = await _context.GlobalRecipes.FindAsync(id);
        if (recipe == null) return false;

        _context.GlobalRecipes.Remove(recipe);
        await _context.SaveChangesAsync();
        return true;
    }

    public async Task UpsertHellofreshRecipeAsync(GlobalRecipe recipe)
    {
        var existing = await GetByHellofreshUuidAsync(recipe.HellofreshUuid!);

        if (existing != null)
        {
            // Update existing
            existing.Title = recipe.Title;
            existing.Description = recipe.Description;
            existing.ImageUrl = recipe.ImageUrl;
            existing.Ingredients = recipe.Ingredients;
            existing.NutritionData = recipe.NutritionData;
            existing.CookTimeMinutes = recipe.CookTimeMinutes;
            existing.Difficulty = recipe.Difficulty;
            existing.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
        }
        else
        {
            // Insert new
            recipe.IsHellofresh = true;
            recipe.CreatedAt = DateTime.UtcNow;
            recipe.UpdatedAt = DateTime.UtcNow;
            _context.GlobalRecipes.Add(recipe);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<Dictionary<string, GlobalRecipe>> GetHellofreshRecipesByUuidsAsync(IEnumerable<string> uuids)
    {
        var recipes = await _context.GlobalRecipes
            .Where(gr => gr.IsHellofresh && uuids.Contains(gr.HellofreshUuid!))
            .ToListAsync();

        return recipes.ToDictionary(r => r.HellofreshUuid!, r => r);
    }

    public async Task BatchUpsertHellofreshRecipesAsync(IEnumerable<GlobalRecipe> recipes)
    {
        var recipeList = recipes.ToList();
        if (!recipeList.Any()) return;

        // Get all UUIDs from incoming recipes
        var uuids = recipeList.Select(r => r.HellofreshUuid!).ToList();

        // Fetch all existing recipes in one query
        var existingRecipes = await GetHellofreshRecipesByUuidsAsync(uuids);

        var toAdd = new List<GlobalRecipe>();
        var toUpdate = new List<GlobalRecipe>();

        foreach (var recipe in recipeList)
        {
            if (existingRecipes.TryGetValue(recipe.HellofreshUuid!, out var existing))
            {
                // Update existing
                existing.Title = recipe.Title;
                existing.Description = recipe.Description;
                existing.ImageUrl = recipe.ImageUrl;
                existing.Ingredients = recipe.Ingredients;
                existing.NutritionData = recipe.NutritionData;
                existing.CookTimeMinutes = recipe.CookTimeMinutes;
                existing.Difficulty = recipe.Difficulty;
                existing.UpdatedAt = DateTime.UtcNow;
                toUpdate.Add(existing);
            }
            else
            {
                // Insert new
                recipe.IsHellofresh = true;
                recipe.CreatedAt = DateTime.UtcNow;
                recipe.UpdatedAt = DateTime.UtcNow;
                toAdd.Add(recipe);
            }
        }

        // Batch add new recipes
        if (toAdd.Any())
        {
            await _context.GlobalRecipes.AddRangeAsync(toAdd);
        }

        // Save all changes in one transaction
        await _context.SaveChangesAsync();
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\GlobalRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\HelloFreshScraperService.cs
================================================================================
using HtmlAgilityPack;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using System.Globalization;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace StorhaugenEats.API.Services;

public class HelloFreshScraperService : IHelloFreshScraperService
{
    private readonly HttpClient _httpClient;
    private readonly AppDbContext _context;
    private readonly IGlobalRecipeService _globalRecipeService;
    private readonly IStorageService _storageService;
    private readonly IConfiguration _configuration;

    private const string BaseUrl = "https://www.hellofresh.no";

    public HelloFreshScraperService(
        HttpClient httpClient,
        AppDbContext context,
        IGlobalRecipeService globalRecipeService,
        IStorageService storageService,
        IConfiguration configuration)
    {
        _httpClient = httpClient;
        _context = context;
        _globalRecipeService = globalRecipeService;
        _storageService = storageService;
        _configuration = configuration;
    }

    public async Task<bool> ShouldRunSyncAsync()
    {
        var syncIntervalHours = _configuration.GetValue<int>("HelloFresh:SyncIntervalHours", 24);

        var lastSync = await _context.EtlSyncLogs
            .Where(log => log.SyncType == "hellofresh" && log.Status == "success")
            .OrderByDescending(log => log.StartedAt)
            .FirstOrDefaultAsync();

        if (lastSync == null) return true;

        var hoursSinceLastSync = (DateTime.UtcNow - lastSync.StartedAt).TotalHours;
        return hoursSinceLastSync >= syncIntervalHours;
    }

    public async Task<string> GetBuildIdAsync()
    {
        var response = await _httpClient.GetStringAsync(BaseUrl);

        // Extract build ID from HTML
        // Pattern: /_next/static/[BUILD_ID]/_buildManifest.js
        var buildIdPattern = @"/_next/static/([^/]+)/_buildManifest\.js";
        var match = Regex.Match(response, buildIdPattern);

        if (!match.Success)
            throw new Exception("Failed to extract HelloFresh build ID");

        return match.Groups[1].Value;
    }

    public async Task<(int added, int updated)> SyncRecipesAsync()
    {
        var syncLog = new EtlSyncLog
        {
            Id = Guid.NewGuid(),
            SyncType = "hellofresh",
            StartedAt = DateTime.UtcNow
        };

        try
        {
            // Step 1: Get Build ID
            var buildId = await GetBuildIdAsync();
            syncLog.BuildId = buildId;

            // Step 2: Generate weeks to fetch
            var weeksToFetch = _configuration.GetValue<int>("HelloFresh:WeeksToFetch", 4);
            var weeks = GenerateWeeks(weeksToFetch);
            syncLog.WeeksSynced = string.Join(",", weeks);

            // Step 3: Fetch data for all weeks and collect recipes
            var allRecipes = new List<GlobalRecipe>();

            foreach (var week in weeks)
            {
                var url = $"{BaseUrl}/_next/data/{buildId}/menus/{week}.json";

                try
                {
                    var json = await _httpClient.GetStringAsync(url);
                    var weekRecipes = await ParseWeekDataAsync(json, week);
                    allRecipes.AddRange(weekRecipes);
                }
                catch (Exception ex)
                {
                    // Log error but continue with other weeks
                    Console.WriteLine($"Error fetching week {week}: {ex.Message}");
                }
            }

            // Step 4: Batch upsert all recipes in one operation
            int recipesAdded = 0;
            int recipesUpdated = 0;

            if (allRecipes.Any())
            {
                // Get existing recipes to count adds vs updates
                var uuids = allRecipes.Select(r => r.HellofreshUuid!).ToList();
                var existing = await _globalRecipeService.GetHellofreshRecipesByUuidsAsync(uuids);

                recipesAdded = allRecipes.Count(r => !existing.ContainsKey(r.HellofreshUuid!));
                recipesUpdated = allRecipes.Count(r => existing.ContainsKey(r.HellofreshUuid!));

                // Batch upsert
                await _globalRecipeService.BatchUpsertHellofreshRecipesAsync(allRecipes);
            }

            syncLog.RecipesAdded = recipesAdded;
            syncLog.RecipesUpdated = recipesUpdated;
            syncLog.Status = "success";
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            return (recipesAdded, recipesUpdated);
        }
        catch (Exception ex)
        {
            syncLog.Status = "failed";
            syncLog.ErrorMessage = ex.Message;
            syncLog.CompletedAt = DateTime.UtcNow;

            _context.EtlSyncLogs.Add(syncLog);
            await _context.SaveChangesAsync();

            throw;
        }
    }

    private async Task<List<GlobalRecipe>> ParseWeekDataAsync(string jsonData, string week)
    {
        var recipes = new List<GlobalRecipe>();

        using var doc = JsonDocument.Parse(jsonData);
        var root = doc.RootElement;

        // Navigate to courses: pageProps.ssrPayload.courses
        if (!root.TryGetProperty("pageProps", out var pageProps) ||
            !pageProps.TryGetProperty("ssrPayload", out var ssrPayload) ||
            !ssrPayload.TryGetProperty("courses", out var courses))
        {
            return recipes;
        }

        foreach (var course in courses.EnumerateArray())
        {
            try
            {
                // Extract recipe data
                var recipe = await ParseHelloFreshRecipeAsync(course);

                if (recipe != null)
                {
                    recipes.Add(recipe);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing recipe: {ex.Message}");
            }
        }

        return recipes;
    }

    private async Task<GlobalRecipe?> ParseHelloFreshRecipeAsync(JsonElement course)
    {
        try
        {
            // Extract the recipe object from the course
            if (!course.TryGetProperty("recipe", out var recipeElement))
            {
                return null;
            }

            // Extract basic data from recipe object
            if (!recipeElement.TryGetProperty("uuid", out var uuidElement) ||
                !recipeElement.TryGetProperty("name", out var nameElement))
            {
                return null;
            }

            var uuid = uuidElement.GetString();
            var title = nameElement.GetString();

            if (string.IsNullOrEmpty(uuid) || string.IsNullOrEmpty(title))
                return null;

            // Extract description (use headline as description)
            string? description = null;
            if (recipeElement.TryGetProperty("headline", out var descElement))
            {
                description = descElement.GetString();
            }

            // Extract image URL (use HelloFresh URL directly to reduce requests)
            string? imageUrl = null;
            if (recipeElement.TryGetProperty("imageLink", out var imageElement))
            {
                imageUrl = imageElement.GetString();
            }

            // Extract ingredients
            var ingredients = new List<object>();
            if (recipeElement.TryGetProperty("ingredients", out var ingredientsElement))
            {
                foreach (var ing in ingredientsElement.EnumerateArray())
                {
                    var ingredient = new Dictionary<string, string>();

                    // Safely extract each property, handling both string and number types
                    if (ing.TryGetProperty("name", out var ingName))
                        ingredient["name"] = SafeGetString(ingName);

                    if (ing.TryGetProperty("quantity", out var quantity))
                        ingredient["amount"] = SafeGetString(quantity);

                    if (ing.TryGetProperty("unit", out var unit))
                        ingredient["unit"] = SafeGetString(unit);

                    if (ing.TryGetProperty("imagePath", out var ingImage))
                        ingredient["image"] = SafeGetString(ingImage);

                    ingredients.Add(ingredient);
                }
            }

            // Extract nutrition data
            Dictionary<string, object>? nutritionData = null;
            if (recipeElement.TryGetProperty("nutrition", out var nutritionElement))
            {
                nutritionData = new Dictionary<string, object>();

                // Handle both array and object formats
                if (nutritionElement.ValueKind == JsonValueKind.Array)
                {
                    // Nutrition is an array of objects
                    foreach (var item in nutritionElement.EnumerateArray())
                    {
                        if (item.TryGetProperty("name", out var nameEl) &&
                            item.TryGetProperty("amount", out var amountEl))
                        {
                            var name = nameEl.GetString();
                            if (!string.IsNullOrEmpty(name))
                            {
                                // Safely extract amount value based on its type
                                object amountValue = amountEl.ValueKind switch
                                {
                                    JsonValueKind.Number => amountEl.GetDouble(),
                                    JsonValueKind.String => amountEl.GetString() ?? "",
                                    _ => amountEl.GetRawText()
                                };
                                nutritionData[name] = amountValue;
                            }
                        }
                    }
                }
                else if (nutritionElement.ValueKind == JsonValueKind.Object)
                {
                    // Nutrition is an object
                    foreach (var prop in nutritionElement.EnumerateObject())
                    {
                        // Safely extract value based on its type
                        object value = prop.Value.ValueKind switch
                        {
                            JsonValueKind.Number => prop.Value.GetDouble(),
                            JsonValueKind.String => prop.Value.GetString() ?? "",
                            _ => prop.Value.GetRawText()
                        };
                        nutritionData[prop.Name] = value;
                    }
                }
            }

            // Extract cook time
            int? cookTime = null;
            if (recipeElement.TryGetProperty("prepTime", out var prepTimeElement))
            {
                // Handle both number and string formats
                if (prepTimeElement.ValueKind == JsonValueKind.Number)
                {
                    cookTime = prepTimeElement.GetInt32();
                }
                else if (prepTimeElement.ValueKind == JsonValueKind.String)
                {
                    // Sometimes it's a string like "PT20M" or just a number as string
                    var timeStr = prepTimeElement.GetString();
                    if (!string.IsNullOrEmpty(timeStr))
                    {
                        // Try parsing as direct number first
                        if (int.TryParse(timeStr, out var directParse))
                        {
                            cookTime = directParse;
                        }
                        else
                        {
                            // Try extracting from ISO 8601 duration format
                            var match = Regex.Match(timeStr, @"\d+");
                            if (match.Success && int.TryParse(match.Value, out var parsedTime))
                            {
                                cookTime = parsedTime;
                            }
                        }
                    }
                }
            }

            // Extract difficulty
            string? difficulty = null;
            if (recipeElement.TryGetProperty("difficulty", out var difficultyElement))
            {
                int diffValue = 0;

                // Handle both number and string formats
                if (difficultyElement.ValueKind == JsonValueKind.Number)
                {
                    diffValue = difficultyElement.GetInt32();
                }
                else if (difficultyElement.ValueKind == JsonValueKind.String)
                {
                    int.TryParse(difficultyElement.GetString(), out diffValue);
                }

                difficulty = diffValue switch
                {
                    1 => "Easy",
                    2 => "Medium",
                    3 => "Hard",
                    _ => "Easy"
                };
            }

            return new GlobalRecipe
            {
                Id = Guid.NewGuid(),
                Title = title,
                Description = description,
                ImageUrl = imageUrl,
                Ingredients = JsonSerializer.Serialize(ingredients),
                NutritionData = nutritionData != null ? JsonSerializer.Serialize(nutritionData) : null,
                CookTimeMinutes = cookTime,
                Difficulty = difficulty,
                IsHellofresh = true,
                HellofreshUuid = uuid,
                IsPublic = false,
                CreatedByUserId = null
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing HelloFresh recipe: {ex.Message}");
            return null;
        }
    }

    private List<string> GenerateWeeks(int count)
    {
        var weeks = new List<string>();
        var currentDate = DateTime.UtcNow;

        for (int i = 0; i < count; i++)
        {
            var targetDate = currentDate.AddDays(i * 7);
            var calendar = CultureInfo.CurrentCulture.Calendar;
            var weekNumber = calendar.GetWeekOfYear(
                targetDate,
                CalendarWeekRule.FirstFourDayWeek,
                DayOfWeek.Monday
            );

            var weekString = $"{targetDate.Year}-W{weekNumber:D2}";
            weeks.Add(weekString);
        }

        return weeks;
    }

    /// <summary>
    /// Safely extract string value from JsonElement, handling both string and number types
    /// </summary>
    private string SafeGetString(JsonElement element)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString() ?? "",
            JsonValueKind.Number => element.GetDecimal().ToString(CultureInfo.InvariantCulture),
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "",
            _ => element.GetRawText()
        };
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\HelloFreshScraperService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\HouseholdRecipeService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

/// <summary>
/// DEPRECATED: Use UserRecipeService for user-centric recipe management.
/// This service is maintained for backward compatibility during migration.
/// </summary>
[Obsolete("Use UserRecipeService instead. This service will be removed after migration is complete.")]
public class HouseholdRecipeService : IHouseholdRecipeService
{
    private readonly AppDbContext _context;

    public HouseholdRecipeService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<HouseholdRecipe?> GetByIdAsync(Guid id)
    {
        return await _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.Household)
            .Include(hr => hr.AddedByUser)
            .FirstOrDefaultAsync(hr => hr.Id == id);
    }

    public async Task<IEnumerable<HouseholdRecipe>> GetByHouseholdAsync(Guid householdId, bool includeArchived = false)
    {
        var query = _context.HouseholdRecipes
            .Include(hr => hr.GlobalRecipe)
            .Include(hr => hr.AddedByUser)
            .Where(hr => hr.HouseholdId == householdId);

        if (!includeArchived)
        {
            query = query.Where(hr => !hr.IsArchived);
        }

        return await query.OrderByDescending(hr => hr.CreatedAt).ToListAsync();
    }

    public async Task<HouseholdRecipe> AddLinkedRecipeAsync(Guid householdId, Guid globalRecipeId, Guid addedByUserId, string? personalNotes = null)
    {
        // Check if already exists (prevent duplicates)
        var existing = await _context.HouseholdRecipes
            .FirstOrDefaultAsync(hr => hr.HouseholdId == householdId && hr.GlobalRecipeId == globalRecipeId);

        if (existing != null)
        {
            // Unarchive if was archived
            if (existing.IsArchived)
            {
                existing.IsArchived = false;
                existing.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
            return existing;
        }

        var recipe = new HouseholdRecipe
        {
            Id = Guid.NewGuid(),
            HouseholdId = householdId,
            GlobalRecipeId = globalRecipeId,
            PersonalNotes = personalNotes,
            AddedByUserId = addedByUserId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.HouseholdRecipes.Add(recipe);
        await _context.SaveChangesAsync();

        return await GetByIdAsync(recipe.Id) ?? recipe;
    }

    public async Task<HouseholdRecipe> AddForkedRecipeAsync(Guid householdId, Guid addedByUserId, string title, string? description, string ingredients, string? imageUrl, string? personalNotes = null)
    {
        var recipe = new HouseholdRecipe
        {
            Id = Guid.NewGuid(),
            HouseholdId = householdId,
            GlobalRecipeId = null, // Forked = no global link
            LocalTitle = title,
            LocalDescription = description,
            LocalIngredients = ingredients,
            LocalImageUrl = imageUrl,
            PersonalNotes = personalNotes,
            AddedByUserId = addedByUserId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.HouseholdRecipes.Add(recipe);
        await _context.SaveChangesAsync();

        return recipe;
    }

    public async Task<HouseholdRecipe> UpdateAsync(HouseholdRecipe recipe)
    {
        recipe.UpdatedAt = DateTime.UtcNow;
        _context.HouseholdRecipes.Update(recipe);
        await _context.SaveChangesAsync();
        return recipe;
    }

    public async Task<HouseholdRecipe> ForkRecipeAsync(Guid householdRecipeId)
    {
        var recipe = await GetByIdAsync(householdRecipeId);
        if (recipe == null || recipe.GlobalRecipe == null)
            throw new InvalidOperationException("Recipe not found or already forked");

        // Copy global data to local fields
        recipe.LocalTitle = recipe.GlobalRecipe.Title;
        recipe.LocalDescription = recipe.GlobalRecipe.Description;
        recipe.LocalIngredients = recipe.GlobalRecipe.Ingredients;
        recipe.LocalImageUrl = recipe.GlobalRecipe.ImageUrl;

        // Break the link
        recipe.GlobalRecipeId = null;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return recipe;
    }

    public async Task<bool> ArchiveAsync(Guid id)
    {
        var recipe = await _context.HouseholdRecipes.FindAsync(id);
        if (recipe == null) return false;

        recipe.IsArchived = true;
        recipe.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return true;
    }

    public async Task<bool> UnarchiveAsync(Guid id)
    {
        var recipe = await _context.HouseholdRecipes.FindAsync(id);
        if (recipe == null) return false;

        recipe.IsArchived = false;
        recipe.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return true;
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var recipe = await _context.HouseholdRecipes.FindAsync(id);
        if (recipe == null) return false;

        _context.HouseholdRecipes.Remove(recipe);
        await _context.SaveChangesAsync();

        return true;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\HouseholdRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\HouseholdService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

/// <summary>
/// LEGACY: Manages household entities.
/// While households still exist for grouping users, the application is transitioning
/// to a user-centric model. New features should use user-level services.
/// </summary>
public class HouseholdService : IHouseholdService
{
    private readonly AppDbContext _context;

    public HouseholdService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Household?> GetByIdAsync(Guid id)
    {
        return await _context.Households
            .Include(h => h.Leader)
            .Include(h => h.Members)
            .FirstOrDefaultAsync(h => h.Id == id);
    }

    public async Task<Household> CreateAsync(string name, Guid leaderId)
    {
        var household = new Household
        {
            Id = Guid.NewGuid(),
            Name = name,
            LeaderId = leaderId,
            Settings = "{}",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Households.Add(household);

        // Assign leader to household
        var leader = await _context.Users.FindAsync(leaderId);
        if (leader != null)
        {
            leader.CurrentHouseholdId = household.Id;
            leader.UpdatedAt = DateTime.UtcNow;
        }

        await _context.SaveChangesAsync();

        return household;
    }

    public async Task<Household> UpdateAsync(Household household)
    {
        household.UpdatedAt = DateTime.UtcNow;
        _context.Households.Update(household);
        await _context.SaveChangesAsync();
        return household;
    }

    public async Task<bool> AddMemberAsync(Guid householdId, Guid userId)
    {
        var user = await _context.Users.FindAsync(userId);
        if (user == null) return false;

        user.CurrentHouseholdId = householdId;
        user.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return true;
    }

    public async Task<bool> RemoveMemberAsync(Guid householdId, Guid userId)
    {
        var user = await _context.Users.FindAsync(userId);
        if (user == null || user.CurrentHouseholdId != householdId) return false;

        user.CurrentHouseholdId = null;
        user.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();

        return true;
    }

    public async Task<IEnumerable<User>> GetMembersAsync(Guid householdId)
    {
        return await _context.Users
            .Where(u => u.CurrentHouseholdId == householdId)
            .ToListAsync();
    }

    public async Task<bool> MergeHouseholdsAsync(Guid sourceHouseholdId, Guid targetHouseholdId)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();

        try
        {
            // Move all household recipes
            var recipesToMove = await _context.HouseholdRecipes
                .Where(hr => hr.HouseholdId == sourceHouseholdId)
                .ToListAsync();

            foreach (var recipe in recipesToMove)
            {
                recipe.HouseholdId = targetHouseholdId;
                recipe.UpdatedAt = DateTime.UtcNow;
            }

            // Move all users
            var usersToMove = await _context.Users
                .Where(u => u.CurrentHouseholdId == sourceHouseholdId)
                .ToListAsync();

            foreach (var user in usersToMove)
            {
                user.CurrentHouseholdId = targetHouseholdId;
                user.UpdatedAt = DateTime.UtcNow;
            }

            // Delete source household
            var sourceHousehold = await _context.Households.FindAsync(sourceHouseholdId);
            if (sourceHousehold != null)
            {
                _context.Households.Remove(sourceHousehold);
            }

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return true;
        }
        catch
        {
            await transaction.RollbackAsync();
            return false;
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\HouseholdService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IActivityFeedService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing the social activity feed.
/// </summary>
public interface IActivityFeedService
{
    // Feed queries
    Task<ActivityFeedPagedResult> GetFeedAsync(Guid userId, ActivityFeedQuery query);
    Task<ActivityFeedPagedResult> GetUserActivityAsync(Guid userId, int page = 1, int pageSize = 20);
    Task<ActivitySummaryDto> GetActivitySummaryAsync(Guid userId);

    // Activity creation (called by other services)
    Task RecordRatingActivityAsync(Guid userId, Guid recipeId, string recipeName, int rating, string? imageUrl = null);
    Task RecordAddedRecipeActivityAsync(Guid userId, Guid recipeId, string recipeName, string? imageUrl = null);
    Task RecordPublishedActivityAsync(Guid userId, Guid globalRecipeId, string recipeName, string? imageUrl = null);
    Task RecordJoinedHouseholdActivityAsync(Guid userId, Guid householdId, string householdName);

    // Cleanup
    Task CleanupOldActivitiesAsync(int daysToKeep = 90);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ICurrentUserService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface ICurrentUserService
{
    /// <summary>
    /// Gets the current authenticated user's email from JWT
    /// </summary>
    string? GetUserEmail();

    /// <summary>
    /// Gets the current authenticated user's Supabase UUID from JWT
    /// </summary>
    string? GetUserSubject();

    /// <summary>
    /// Gets or creates the user in the database and returns their ID
    /// </summary>
    Task<Guid> GetOrCreateUserIdAsync();

    /// <summary>
    /// Checks if user is authenticated
    /// </summary>
    bool IsAuthenticated();
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ICurrentUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IGlobalRecipeService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public interface IGlobalRecipeService
{
    Task<GlobalRecipe?> GetByIdAsync(Guid id);
    Task<GlobalRecipe?> GetByHellofreshUuidAsync(string uuid);
    Task<IEnumerable<GlobalRecipe>> GetPublicRecipesAsync(int skip = 0, int take = 50, string? sortBy = "rating");
    Task<GlobalRecipe> CreateAsync(GlobalRecipe recipe);
    Task<GlobalRecipe> UpdateAsync(GlobalRecipe recipe);
    Task<bool> DeleteAsync(Guid id);
    Task UpsertHellofreshRecipeAsync(GlobalRecipe recipe);
    Task<Dictionary<string, GlobalRecipe>> GetHellofreshRecipesByUuidsAsync(IEnumerable<string> uuids);
    Task BatchUpsertHellofreshRecipesAsync(IEnumerable<GlobalRecipe> recipes);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IGlobalRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IHelloFreshScraperService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface IHelloFreshScraperService
{
    Task<(int added, int updated)> SyncRecipesAsync();
    Task<string> GetBuildIdAsync();
    Task<bool> ShouldRunSyncAsync();
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IHelloFreshScraperService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IHouseholdRecipeService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

/// <summary>
/// DEPRECATED: Use IUserRecipeService for user-centric recipe management.
/// This interface is maintained for backward compatibility during migration.
/// </summary>
[Obsolete("Use IUserRecipeService instead. This interface will be removed after migration is complete.")]
public interface IHouseholdRecipeService
{
    Task<HouseholdRecipe?> GetByIdAsync(Guid id);
    Task<IEnumerable<HouseholdRecipe>> GetByHouseholdAsync(Guid householdId, bool includeArchived = false);
    Task<HouseholdRecipe> AddLinkedRecipeAsync(Guid householdId, Guid globalRecipeId, Guid addedByUserId, string? personalNotes = null);
    Task<HouseholdRecipe> AddForkedRecipeAsync(Guid householdId, Guid addedByUserId, string title, string? description, string ingredients, string? imageUrl, string? personalNotes = null);
    Task<HouseholdRecipe> UpdateAsync(HouseholdRecipe recipe);
    Task<HouseholdRecipe> ForkRecipeAsync(Guid householdRecipeId); // Convert linked → forked
    Task<bool> ArchiveAsync(Guid id);
    Task<bool> UnarchiveAsync(Guid id);
    Task<bool> DeleteAsync(Guid id);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IHouseholdRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IHouseholdService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

/// <summary>
/// LEGACY: Manages household entities.
/// While households still exist for grouping users, the application is transitioning
/// to a user-centric model. New features should use user-level services.
/// </summary>
public interface IHouseholdService
{
    Task<Household?> GetByIdAsync(Guid id);
    Task<Household> CreateAsync(string name, Guid leaderId);
    Task<Household> UpdateAsync(Household household);
    Task<bool> AddMemberAsync(Guid householdId, Guid userId);
    Task<bool> RemoveMemberAsync(Guid householdId, Guid userId);
    Task<IEnumerable<User>> GetMembersAsync(Guid householdId);
    Task<bool> MergeHouseholdsAsync(Guid sourceHouseholdId, Guid targetHouseholdId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IHouseholdService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IRatingService.cs
================================================================================
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

public interface IRatingService
{
    Task<Rating?> GetUserRatingForRecipeAsync(Guid userId, Guid globalRecipeId);
    Task<IEnumerable<Rating>> GetRatingsForRecipeAsync(Guid globalRecipeId);
    Task<Rating> UpsertRatingAsync(Guid userId, Guid globalRecipeId, int score, string? comment = null);
    Task<bool> DeleteRatingAsync(Guid userId, Guid globalRecipeId);
    Task<List<UserRatingDto>> GetGlobalRecipeRatingsForUserAsync(Guid userId, int skip = 0, int take = 50);

}


================================================================================
FILE END: \StorhaugenEats.API\Services\IRatingService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IStorageService.cs
================================================================================
namespace StorhaugenEats.API.Services;

public interface IStorageService
{
    Task<string> UploadImageAsync(Stream imageStream, string fileName, string folder = "recipes");
    Task<string> UploadImageFromUrlAsync(string imageUrl, string fileName, string folder = "recipes");
    Task<bool> DeleteImageAsync(string imageUrl);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IStorageService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\ITagService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing personal recipe tags.
/// </summary>
public interface ITagService
{
    // Tag CRUD
    Task<List<TagDto>> GetUserTagsAsync(Guid userId);
    Task<TagDto?> GetTagAsync(Guid tagId, Guid userId);
    Task<TagDto> CreateTagAsync(Guid userId, CreateTagDto dto);
    Task<TagDto> UpdateTagAsync(Guid tagId, Guid userId, UpdateTagDto dto);
    Task DeleteTagAsync(Guid tagId, Guid userId);

    // Recipe-Tag management
    Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId, Guid userId);
    Task SetRecipeTagsAsync(Guid recipeId, Guid userId, List<Guid> tagIds);
    Task AddTagToRecipeAsync(Guid recipeId, Guid tagId, Guid userId);
    Task RemoveTagFromRecipeAsync(Guid recipeId, Guid tagId, Guid userId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\ITagService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserFriendshipService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing user-to-user friendships.
/// </summary>
public interface IUserFriendshipService
{
    // Friendship queries
    Task<FriendshipListDto> GetFriendshipsAsync(Guid userId);
    Task<List<FriendProfileDto>> GetFriendsAsync(Guid userId);
    Task<UserFriendshipDto?> GetFriendshipAsync(Guid friendshipId, Guid userId);

    // Friend requests
    Task<UserFriendshipDto> SendFriendRequestAsync(Guid userId, SendFriendRequestDto dto);
    Task<UserFriendshipDto> RespondToRequestAsync(Guid friendshipId, Guid userId, string action);
    Task RemoveFriendshipAsync(Guid friendshipId, Guid userId);

    // Queries
    Task<List<UserSearchResultDto>> SearchUsersAsync(Guid userId, string query, int limit = 20);
    Task<FriendProfileDto?> GetUserProfileAsync(Guid profileUserId, Guid requestingUserId);

    // Helpers
    Task<bool> AreFriendsAsync(Guid userId1, Guid userId2);
    Task<List<Guid>> GetFriendIdsAsync(Guid userId);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserRecipeService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing user-owned recipes.
/// </summary>
public interface IUserRecipeService
{
    // CRUD Operations
    Task<UserRecipePagedResult> GetUserRecipesAsync(Guid userId, GetUserRecipesQuery query);
    Task<UserRecipeDto?> GetRecipeAsync(Guid recipeId, Guid requestingUserId);
    Task<UserRecipeDto> CreateRecipeAsync(Guid userId, CreateUserRecipeDto dto);
    Task<UserRecipeDto> UpdateRecipeAsync(Guid recipeId, Guid userId, UpdateUserRecipeDto dto);
    Task DeleteRecipeAsync(Guid recipeId, Guid userId);

    // Publishing
    Task<PublishRecipeResultDto> PublishRecipeAsync(Guid recipeId, Guid userId);
    Task<UserRecipeDto> DetachRecipeAsync(Guid recipeId, Guid userId);

    // Rating
    Task<UserRecipeDto> RateRecipeAsync(Guid recipeId, Guid userId, int rating, string? comment = null);
    Task RemoveRatingAsync(Guid recipeId, Guid userId);

    // Archive
    Task<UserRecipeDto> ArchiveRecipeAsync(Guid recipeId, Guid userId);
    Task<UserRecipeDto> RestoreRecipeAsync(Guid recipeId, Guid userId);

    // Visibility checks
    Task<bool> CanUserViewRecipeAsync(Guid recipeId, Guid requestingUserId);

    // Household aggregation (single group)
    Task<AggregatedRecipePagedResult> GetHouseholdRecipesAsync(Guid householdId, Guid requestingUserId, GetCombinedRecipesQuery query);
    Task<List<CommonFavoriteDto>> GetCommonFavoritesAsync(Guid householdId, Guid requestingUserId, GetCommonFavoritesQuery query);

    // Multi-group aggregation
    Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(Guid requestingUserId, GetMultiGroupRecipesQuery query);
    Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(Guid requestingUserId, GetMultiGroupFavoritesQuery query);

    // Friends' recipes
    Task<UserRecipePagedResult> GetFriendsRecipesAsync(Guid userId, GetUserRecipesQuery query);
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\IUserService.cs
================================================================================
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public interface IUserService
{
    Task<User?> GetByIdAsync(Guid id);
    Task<User?> GetByEmailAsync(string email);
    Task<User?> GetByShareIdAsync(string shareId);
    Task<User> CreateAsync(Guid authUserId, string email, string displayName, string? avatarUrl = null);
    Task<User> UpdateAsync(User user);
    Task<string> GenerateUniqueShareIdAsync();
}


================================================================================
FILE END: \StorhaugenEats.API\Services\IUserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\RatingService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;
using Supabase.Gotrue;

namespace StorhaugenEats.API.Services;

public class RatingService : IRatingService
{
    private readonly AppDbContext _context;

    public RatingService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Rating?> GetUserRatingForRecipeAsync(Guid userId, Guid globalRecipeId)
    {
        return await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserId == userId && r.GlobalRecipeId == globalRecipeId);
    }

    public async Task<IEnumerable<Rating>> GetRatingsForRecipeAsync(Guid globalRecipeId)
    {
        return await _context.Ratings
            .Include(r => r.User)
            .Where(r => r.GlobalRecipeId == globalRecipeId)
            .OrderByDescending(r => r.CreatedAt)
            .ToListAsync();
    }

    public async Task<Rating> UpsertRatingAsync(Guid userId, Guid globalRecipeId, int score, string? comment = null)
    {
        if (score < 0 || score > 10)
            throw new ArgumentException("Score must be between 0 and 10");

        var existing = await GetUserRatingForRecipeAsync(userId, globalRecipeId);

        if (existing != null)
        {
            existing.Score = score;
            existing.Comment = comment;
            existing.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return existing;
        }

        var rating = new Rating
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            GlobalRecipeId = globalRecipeId,
            Score = score,
            Comment = comment,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Ratings.Add(rating);
        await _context.SaveChangesAsync();

        // Note: The database trigger will automatically update global_recipes.average_rating

        return rating;
    }

    public async Task<bool> DeleteRatingAsync(Guid userId, Guid globalRecipeId)
    {
        var rating = await GetUserRatingForRecipeAsync(userId, globalRecipeId);
        if (rating == null) return false;

        _context.Ratings.Remove(rating);
        await _context.SaveChangesAsync();

        // Note: The database trigger will automatically update global_recipes.average_rating

        return true;
    }

    public async Task<List<UserRatingDto>> GetGlobalRecipeRatingsForUserAsync(Guid userId, int skip = 0, int take = 50)
    {
        return await _context.Ratings
            .AsNoTracking()
           .Where(r => r.UserId == userId && r.GlobalRecipeId != null)
            .OrderByDescending(r => r.UpdatedAt)
            .Skip(skip)
            .Take(take)
            .Select(r => new UserRatingDto
            {
                GlobalRecipeId = r.GlobalRecipeId!.Value,
                RecipeTitle = r.GlobalRecipe!.Title,
                ImageUrl = r.GlobalRecipe!.ImageUrl,
                Score = r.Score,
                Comment = r.Comment,
                RatedAt = r.UpdatedAt
            })
            .ToListAsync();
    }

}


================================================================================
FILE END: \StorhaugenEats.API\Services\RatingService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\SupabaseStorageService.cs
================================================================================
using Supabase;

namespace StorhaugenEats.API.Services;

public class SupabaseStorageService : IStorageService
{
    private readonly Client _supabaseClient;
    private readonly HttpClient _httpClient;
    private const string BucketName = "recipe-images";

    public SupabaseStorageService(Client supabaseClient, HttpClient httpClient)
    {
        _supabaseClient = supabaseClient;
        _httpClient = httpClient;
    }

    public async Task<string> UploadImageAsync(Stream imageStream, string fileName, string folder = "recipes")
    {
        var path = $"{folder}/{Guid.NewGuid()}_{fileName}";

        // Convert stream to byte array
        using var memoryStream = new MemoryStream();
        await imageStream.CopyToAsync(memoryStream);
        var bytes = memoryStream.ToArray();

        // Upload to Supabase Storage
        await _supabaseClient.Storage
            .From(BucketName)
            .Upload(bytes, path);

        // Get public URL
        var publicUrl = _supabaseClient.Storage
            .From(BucketName)
            .GetPublicUrl(path);

        return publicUrl;
    }

    public async Task<string> UploadImageFromUrlAsync(string imageUrl, string fileName, string folder = "recipes")
    {
        // Download image from URL
        var response = await _httpClient.GetAsync(imageUrl);
        response.EnsureSuccessStatusCode();

        using var stream = await response.Content.ReadAsStreamAsync();
        return await UploadImageAsync(stream, fileName, folder);
    }

    public async Task<bool> DeleteImageAsync(string imageUrl)
    {
        try
        {
            // Extract path from public URL
            var uri = new Uri(imageUrl);
            var pathSegments = uri.AbsolutePath.Split('/');
            var bucketIndex = Array.IndexOf(pathSegments, BucketName);

            if (bucketIndex == -1) return false;

            var path = string.Join("/", pathSegments.Skip(bucketIndex + 1));

            await _supabaseClient.Storage
                .From(BucketName)
                .Remove(path);

            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\SupabaseStorageService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\TagService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenEats.API.Services;

/// <summary>
/// Service for managing personal recipe tags.
/// </summary>
public class TagService : ITagService
{
    private readonly AppDbContext _context;

    public TagService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<List<TagDto>> GetUserTagsAsync(Guid userId)
    {
        var tags = await _context.RecipeTags
            .Where(t => t.UserId == userId)
            .Select(t => new TagDto
            {
                Id = t.Id,
                Name = t.Name,
                Color = t.Color,
                Icon = t.Icon,
                RecipeCount = t.UserRecipeTags.Count,
                CreatedAt = t.CreatedAt
            })
            .OrderBy(t => t.Name)
            .ToListAsync();

        return tags;
    }

    public async Task<TagDto?> GetTagAsync(Guid tagId, Guid userId)
    {
        var tag = await _context.RecipeTags
            .Where(t => t.Id == tagId && t.UserId == userId)
            .Select(t => new TagDto
            {
                Id = t.Id,
                Name = t.Name,
                Color = t.Color,
                Icon = t.Icon,
                RecipeCount = t.UserRecipeTags.Count,
                CreatedAt = t.CreatedAt
            })
            .FirstOrDefaultAsync();

        return tag;
    }

    public async Task<TagDto> CreateTagAsync(Guid userId, CreateTagDto dto)
    {
        if (string.IsNullOrWhiteSpace(dto.Name))
            throw new InvalidOperationException("Tag name is required");

        // Check for duplicate name
        var exists = await _context.RecipeTags
            .AnyAsync(t => t.UserId == userId && t.Name.ToLower() == dto.Name.ToLower());

        if (exists)
            throw new InvalidOperationException($"A tag with name '{dto.Name}' already exists");

        var tag = new RecipeTag
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            Name = dto.Name.Trim(),
            Color = dto.Color,
            Icon = dto.Icon,
            CreatedAt = DateTime.UtcNow
        };

        _context.RecipeTags.Add(tag);
        await _context.SaveChangesAsync();

        return new TagDto
        {
            Id = tag.Id,
            Name = tag.Name,
            Color = tag.Color,
            Icon = tag.Icon,
            RecipeCount = 0,
            CreatedAt = tag.CreatedAt
        };
    }

    public async Task<TagDto> UpdateTagAsync(Guid tagId, Guid userId, UpdateTagDto dto)
    {
        var tag = await _context.RecipeTags
            .Include(t => t.UserRecipeTags)
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        if (!string.IsNullOrWhiteSpace(dto.Name))
        {
            // Check for duplicate name (excluding current tag)
            var exists = await _context.RecipeTags
                .AnyAsync(t => t.UserId == userId && t.Id != tagId && t.Name.ToLower() == dto.Name.ToLower());

            if (exists)
                throw new InvalidOperationException($"A tag with name '{dto.Name}' already exists");

            tag.Name = dto.Name.Trim();
        }

        if (dto.Color != null)
            tag.Color = dto.Color;

        if (dto.Icon != null)
            tag.Icon = dto.Icon;

        await _context.SaveChangesAsync();

        return new TagDto
        {
            Id = tag.Id,
            Name = tag.Name,
            Color = tag.Color,
            Icon = tag.Icon,
            RecipeCount = tag.UserRecipeTags.Count,
            CreatedAt = tag.CreatedAt
        };
    }

    public async Task DeleteTagAsync(Guid tagId, Guid userId)
    {
        var tag = await _context.RecipeTags
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        _context.RecipeTags.Remove(tag);
        await _context.SaveChangesAsync();
    }

    public async Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        var tags = await _context.UserRecipeTags
            .Where(rt => rt.UserRecipeId == recipeId)
            .Select(rt => new TagReferenceDto
            {
                Id = rt.Tag.Id,
                Name = rt.Tag.Name,
                Color = rt.Tag.Color
            })
            .ToListAsync();

        return tags;
    }

    public async Task SetRecipeTagsAsync(Guid recipeId, Guid userId, List<Guid> tagIds)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .Include(r => r.UserRecipeTags)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        // Verify all tags belong to user
        var validTagIds = await _context.RecipeTags
            .Where(t => t.UserId == userId && tagIds.Contains(t.Id))
            .Select(t => t.Id)
            .ToListAsync();

        // Remove existing tags
        _context.UserRecipeTags.RemoveRange(recipe.UserRecipeTags);

        // Add new tags
        foreach (var tagId in validTagIds)
        {
            recipe.UserRecipeTags.Add(new UserRecipeTag
            {
                Id = Guid.NewGuid(),
                UserRecipeId = recipeId,
                TagId = tagId,
                CreatedAt = DateTime.UtcNow
            });
        }

        await _context.SaveChangesAsync();
    }

    public async Task AddTagToRecipeAsync(Guid recipeId, Guid tagId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        // Verify tag belongs to user
        var tag = await _context.RecipeTags
            .FirstOrDefaultAsync(t => t.Id == tagId && t.UserId == userId);

        if (tag == null)
            throw new InvalidOperationException("Tag not found");

        // Check if already exists
        var exists = await _context.UserRecipeTags
            .AnyAsync(rt => rt.UserRecipeId == recipeId && rt.TagId == tagId);

        if (exists)
            return; // Already tagged

        _context.UserRecipeTags.Add(new UserRecipeTag
        {
            Id = Guid.NewGuid(),
            UserRecipeId = recipeId,
            TagId = tagId,
            CreatedAt = DateTime.UtcNow
        });

        await _context.SaveChangesAsync();
    }

    public async Task RemoveTagFromRecipeAsync(Guid recipeId, Guid tagId, Guid userId)
    {
        // Verify recipe belongs to user
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId);

        if (recipe == null)
            throw new InvalidOperationException("Recipe not found");

        var recipeTag = await _context.UserRecipeTags
            .FirstOrDefaultAsync(rt => rt.UserRecipeId == recipeId && rt.TagId == tagId);

        if (recipeTag != null)
        {
            _context.UserRecipeTags.Remove(recipeTag);
            await _context.SaveChangesAsync();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\TagService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserFriendshipService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class UserFriendshipService : IUserFriendshipService
{
    private readonly AppDbContext _context;

    public UserFriendshipService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<FriendshipListDto> GetFriendshipsAsync(Guid userId)
    {
        var friendships = await _context.UserFriendships
            .Include(f => f.RequesterUser)
            .Include(f => f.TargetUser)
            .Where(f => f.RequesterUserId == userId || f.TargetUserId == userId)
            .ToListAsync();

        var result = new FriendshipListDto();

        foreach (var friendship in friendships)
        {
            var isRequester = friendship.RequesterUserId == userId;
            var otherUser = isRequester ? friendship.TargetUser : friendship.RequesterUser;

            var recipeCount = await _context.UserRecipes
                .CountAsync(r => r.UserId == otherUser.Id && !r.IsArchived);

            var dto = new UserFriendshipDto
            {
                Id = friendship.Id,
                FriendUserId = otherUser.Id,
                FriendDisplayName = otherUser.DisplayName,
                FriendAvatarUrl = otherUser.AvatarUrl,
                FriendShareId = otherUser.UniqueShareId,
                Message = friendship.Message,
                CreatedAt = friendship.CreatedAt,
                RespondedAt = friendship.RespondedAt,
                RecipeCount = recipeCount
            };

            if (friendship.Status == "accepted")
            {
                dto.Status = "accepted";
                result.Friends.Add(dto);
            }
            else if (friendship.Status == "pending")
            {
                if (isRequester)
                {
                    dto.Status = "pending_sent";
                    result.PendingSent.Add(dto);
                }
                else
                {
                    dto.Status = "pending_received";
                    result.PendingReceived.Add(dto);
                }
            }
        }

        return result;
    }

    public async Task<List<FriendProfileDto>> GetFriendsAsync(Guid userId)
    {
        var friendIds = await GetFriendIdsAsync(userId);

        var friends = await _context.Users
            .Where(u => friendIds.Contains(u.Id))
            .ToListAsync();

        var result = new List<FriendProfileDto>();
        foreach (var friend in friends)
        {
            var recipeCount = await _context.UserRecipes
                .CountAsync(r => r.UserId == friend.Id && !r.IsArchived);

            result.Add(new FriendProfileDto
            {
                Id = friend.Id,
                DisplayName = friend.DisplayName,
                AvatarUrl = friend.AvatarUrl,
                ShareId = friend.UniqueShareId,
                Bio = friend.Bio,
                IsProfilePublic = friend.IsProfilePublic,
                FavoriteCuisines = ParseJsonList(friend.FavoriteCuisines),
                RecipeCount = recipeCount,
                JoinedAt = friend.CreatedAt
            });
        }

        return result;
    }

    public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid friendshipId, Guid userId)
    {
        var friendship = await _context.UserFriendships
            .Include(f => f.RequesterUser)
            .Include(f => f.TargetUser)
            .FirstOrDefaultAsync(f => f.Id == friendshipId &&
                (f.RequesterUserId == userId || f.TargetUserId == userId));

        if (friendship == null) return null;

        var isRequester = friendship.RequesterUserId == userId;
        var otherUser = isRequester ? friendship.TargetUser : friendship.RequesterUser;

        var recipeCount = await _context.UserRecipes
            .CountAsync(r => r.UserId == otherUser.Id && !r.IsArchived);

        string status = friendship.Status;
        if (friendship.Status == "pending")
        {
            status = isRequester ? "pending_sent" : "pending_received";
        }

        return new UserFriendshipDto
        {
            Id = friendship.Id,
            FriendUserId = otherUser.Id,
            FriendDisplayName = otherUser.DisplayName,
            FriendAvatarUrl = otherUser.AvatarUrl,
            FriendShareId = otherUser.UniqueShareId,
            Status = status,
            Message = friendship.Message,
            CreatedAt = friendship.CreatedAt,
            RespondedAt = friendship.RespondedAt,
            RecipeCount = recipeCount
        };
    }

    public async Task<UserFriendshipDto> SendFriendRequestAsync(Guid userId, SendFriendRequestDto dto)
    {
        Guid targetUserId;

        if (dto.TargetUserId.HasValue)
        {
            targetUserId = dto.TargetUserId.Value;
        }
        else if (!string.IsNullOrEmpty(dto.TargetShareId))
        {
            var targetUser = await _context.Users
                .FirstOrDefaultAsync(u => u.UniqueShareId == dto.TargetShareId)
                ?? throw new InvalidOperationException("User not found with that share ID");
            targetUserId = targetUser.Id;
        }
        else
        {
            throw new InvalidOperationException("Either TargetUserId or TargetShareId must be provided");
        }

        // Validate
        if (targetUserId == userId)
            throw new InvalidOperationException("You cannot send a friend request to yourself");

        // Check for existing friendship
        var existing = await _context.UserFriendships
            .FirstOrDefaultAsync(f =>
                (f.RequesterUserId == userId && f.TargetUserId == targetUserId) ||
                (f.RequesterUserId == targetUserId && f.TargetUserId == userId));

        if (existing != null)
        {
            if (existing.Status == "accepted")
                throw new InvalidOperationException("You are already friends");
            if (existing.Status == "pending")
                throw new InvalidOperationException("A friend request already exists");
            if (existing.Status == "blocked")
                throw new InvalidOperationException("Unable to send friend request");
        }

        var friendship = new UserFriendship
        {
            Id = Guid.NewGuid(),
            RequesterUserId = userId,
            TargetUserId = targetUserId,
            Status = "pending",
            Message = dto.Message,
            CreatedAt = DateTime.UtcNow
        };

        _context.UserFriendships.Add(friendship);
        await _context.SaveChangesAsync();

        return (await GetFriendshipAsync(friendship.Id, userId))!;
    }

    public async Task<UserFriendshipDto> RespondToRequestAsync(Guid friendshipId, Guid userId, string action)
    {
        var friendship = await _context.UserFriendships
            .FirstOrDefaultAsync(f => f.Id == friendshipId && f.TargetUserId == userId && f.Status == "pending")
            ?? throw new InvalidOperationException("Friend request not found or you cannot respond to it");

        action = action.ToLower();
        if (action != "accept" && action != "reject")
            throw new InvalidOperationException("Action must be 'accept' or 'reject'");

        friendship.Status = action == "accept" ? "accepted" : "rejected";
        friendship.RespondedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return (await GetFriendshipAsync(friendshipId, userId))!;
    }

    public async Task RemoveFriendshipAsync(Guid friendshipId, Guid userId)
    {
        var friendship = await _context.UserFriendships
            .FirstOrDefaultAsync(f => f.Id == friendshipId &&
                (f.RequesterUserId == userId || f.TargetUserId == userId))
            ?? throw new InvalidOperationException("Friendship not found");

        _context.UserFriendships.Remove(friendship);
        await _context.SaveChangesAsync();
    }

    public async Task<List<UserSearchResultDto>> SearchUsersAsync(Guid userId, string query, int limit = 20)
    {
        if (string.IsNullOrWhiteSpace(query) || query.Length < 2)
            return new List<UserSearchResultDto>();

        query = query.ToLower();

        var users = await _context.Users
            .Where(u => u.Id != userId)
            .Where(u => u.IsProfilePublic)
            .Where(u =>
                u.DisplayName.ToLower().Contains(query) ||
                u.UniqueShareId.ToLower() == query ||
                u.Email.ToLower().Contains(query))
            .Take(limit)
            .ToListAsync();

        // Get friendship statuses
        var userIds = users.Select(u => u.Id).ToList();
        var friendships = await _context.UserFriendships
            .Where(f =>
                (f.RequesterUserId == userId && userIds.Contains(f.TargetUserId)) ||
                (f.TargetUserId == userId && userIds.Contains(f.RequesterUserId)))
            .ToListAsync();

        return users.Select(u =>
        {
            var friendship = friendships.FirstOrDefault(f =>
                (f.RequesterUserId == userId && f.TargetUserId == u.Id) ||
                (f.TargetUserId == userId && f.RequesterUserId == u.Id));

            string status = "none";
            if (friendship != null)
            {
                if (friendship.Status == "accepted")
                    status = "friends";
                else if (friendship.Status == "pending")
                    status = friendship.RequesterUserId == userId ? "pending_sent" : "pending_received";
            }

            return new UserSearchResultDto
            {
                Id = u.Id,
                DisplayName = u.DisplayName,
                AvatarUrl = u.AvatarUrl,
                ShareId = u.UniqueShareId,
                FriendshipStatus = status
            };
        }).ToList();
    }

    public async Task<FriendProfileDto?> GetUserProfileAsync(Guid profileUserId, Guid requestingUserId)
    {
        var user = await _context.Users.FindAsync(profileUserId);
        if (user == null) return null;

        // Check if profile is public or if they are friends
        var areFriends = await AreFriendsAsync(profileUserId, requestingUserId);
        if (!user.IsProfilePublic && !areFriends && profileUserId != requestingUserId)
            return null;

        var recipeCount = await _context.UserRecipes
            .CountAsync(r => r.UserId == profileUserId && !r.IsArchived &&
                (r.Visibility == "public" ||
                 (r.Visibility == "friends" && areFriends) ||
                 r.UserId == requestingUserId));

        return new FriendProfileDto
        {
            Id = user.Id,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            ShareId = user.UniqueShareId,
            Bio = user.Bio,
            IsProfilePublic = user.IsProfilePublic,
            FavoriteCuisines = ParseJsonList(user.FavoriteCuisines),
            RecipeCount = recipeCount,
            JoinedAt = user.CreatedAt
        };
    }

    public async Task<bool> AreFriendsAsync(Guid userId1, Guid userId2)
    {
        if (userId1 == userId2) return true; // User is always "friends" with themselves

        return await _context.UserFriendships
            .AnyAsync(f =>
                f.Status == "accepted" &&
                ((f.RequesterUserId == userId1 && f.TargetUserId == userId2) ||
                 (f.RequesterUserId == userId2 && f.TargetUserId == userId1)));
    }

    public async Task<List<Guid>> GetFriendIdsAsync(Guid userId)
    {
        var friendships = await _context.UserFriendships
            .Where(f => f.Status == "accepted")
            .Where(f => f.RequesterUserId == userId || f.TargetUserId == userId)
            .ToListAsync();

        return friendships
            .Select(f => f.RequesterUserId == userId ? f.TargetUserId : f.RequesterUserId)
            .Distinct()
            .ToList();
    }

    private static List<string> ParseJsonList(string json)
    {
        try
        {
            return System.Text.Json.JsonSerializer.Deserialize<List<string>>(json) ?? new();
        }
        catch
        {
            return new List<string>();
        }
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\UserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserRecipeService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenEats.API.Models;
using System.Text.Json;

namespace StorhaugenEats.API.Services;

public class UserRecipeService : IUserRecipeService
{
    private readonly AppDbContext _context;
    private readonly IActivityFeedService _activityFeedService;
    private readonly IUserFriendshipService _friendshipService;

    public UserRecipeService(
        AppDbContext context,
        IActivityFeedService activityFeedService,
        IUserFriendshipService friendshipService)
    {
        _context = context;
        _activityFeedService = activityFeedService;
        _friendshipService = friendshipService;
    }

    public async Task<UserRecipePagedResult> GetUserRecipesAsync(Guid userId, GetUserRecipesQuery query)
    {
        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
            .ThenInclude(rt => rt.User)
            .Where(r => r.UserId == userId);

        if (!query.IncludeArchived)
        {
            queryable = queryable.Where(r => !r.IsArchived);
        }

        if (!string.IsNullOrEmpty(query.Visibility) && query.Visibility != "all")
        {
            queryable = queryable.Where(r => r.Visibility == query.Visibility);
        }

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "name" => query.SortDescending
                ? queryable.OrderByDescending(r => r.LocalTitle ?? r.GlobalRecipe!.Title)
                : queryable.OrderBy(r => r.LocalTitle ?? r.GlobalRecipe!.Title),
            "rating" => query.SortDescending
                ? queryable.OrderByDescending(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0)
                : queryable.OrderBy(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0),
            _ => query.SortDescending
                ? queryable.OrderByDescending(r => r.CreatedAt)
                : queryable.OrderBy(r => r.CreatedAt)
        };

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new UserRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToDto(r, userId)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<UserRecipeDto?> GetRecipeAsync(Guid recipeId, Guid requestingUserId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .FirstOrDefaultAsync(r => r.Id == recipeId);

        if (recipe == null) return null;

        // Check visibility
        if (!await CanUserViewRecipeAsync(recipeId, requestingUserId))
            return null;

        return MapToDto(recipe, requestingUserId);
    }

    public async Task<UserRecipeDto> CreateRecipeAsync(Guid userId, CreateUserRecipeDto dto)
    {
        // 1. Existing creation logic
        var user = await _context.Users.FindAsync(userId)
            ?? throw new InvalidOperationException("User not found");

        var recipe = new UserRecipe
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            GlobalRecipeId = dto.GlobalRecipeId,
            LocalTitle = dto.Name,
            LocalDescription = dto.Description,
            LocalIngredients = dto.Ingredients != null ? JsonSerializer.Serialize(dto.Ingredients) : null,
            LocalImageUrls = dto.ImageUrls != null ? JsonSerializer.Serialize(dto.ImageUrls) : "[]",
            PersonalNotes = dto.PersonalNotes,
            Visibility = dto.Visibility ?? "private",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        // Increment global usage count if linked
        if (dto.GlobalRecipeId.HasValue)
        {
            var globalRecipe = await _context.GlobalRecipes.FindAsync(dto.GlobalRecipeId.Value);
            if (globalRecipe != null) globalRecipe.TotalTimesAdded++;
        }

        _context.UserRecipes.Add(recipe);

        // Save the recipe first so we have an ID for the ratings
        await _context.SaveChangesAsync();

        // 2.NEW: Handle Proxy Ratings
        if (dto.MemberRatings != null && dto.MemberRatings.Any())
        {
            // Security Check: Get valid member IDs for this user's household
            // This prevents rating for random users outside the family
            var householdId = user.CurrentHouseholdId;
            var validMemberIds = new List<Guid>();

            if (householdId.HasValue)
            {
                validMemberIds = await _context.HouseholdMembers
                    .Where(hm => hm.HouseholdId == householdId.Value)
                    .Select(hm => hm.UserId)
                    .ToListAsync();
            }
            else
            {
                // If no household, can only rate self
                validMemberIds.Add(userId);
            }

            var ratingsToAdd = new List<Rating>();

            foreach (var kvp in dto.MemberRatings)
            {
                var targetUserId = kvp.Key;
                var score = kvp.Value;

                // Only allow rating if target user is in the household (or is self)
                if (validMemberIds.Contains(targetUserId))
                {
                    ratingsToAdd.Add(new Rating
                    {
                        Id = Guid.NewGuid(),
                        UserRecipeId = recipe.Id,
                        GlobalRecipeId = recipe.GlobalRecipeId, // Link to global if applicable
                        UserId = targetUserId,
                        Score = Math.Clamp(score, 1, 10), // Ensure score is 1-10
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    });
                }
            }

            if (ratingsToAdd.Any())
            {
                _context.Ratings.AddRange(ratingsToAdd);
                await _context.SaveChangesAsync();

                // If global link exists, update the global average stats
                if (recipe.GlobalRecipeId.HasValue)
                {
                    await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
                }
            }
        }

        // 3. Existing activity log
        var imageUrls = dto.ImageUrls?.FirstOrDefault();
        await _activityFeedService.RecordAddedRecipeActivityAsync(userId, recipe.Id, recipe.DisplayTitle, imageUrls);

        // 4. Return result
        var createdRecipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings).ThenInclude(rt => rt.User) // Include ratings so they show up immediately
            .FirstAsync(r => r.Id == recipe.Id);

        return MapToDto(createdRecipe, userId);
    }

    public async Task<UserRecipeDto> UpdateRecipeAsync(Guid recipeId, Guid userId, UpdateUserRecipeDto dto)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission to edit it");

        if (dto.Name != null) recipe.LocalTitle = dto.Name;
        if (dto.Description != null) recipe.LocalDescription = dto.Description;
        if (dto.Ingredients != null) recipe.LocalIngredients = JsonSerializer.Serialize(dto.Ingredients);
        if (dto.ImageUrls != null) recipe.LocalImageUrls = JsonSerializer.Serialize(dto.ImageUrls);
        if (dto.PersonalNotes != null) recipe.PersonalNotes = dto.PersonalNotes;
        if (dto.Visibility != null) recipe.Visibility = dto.Visibility;

        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task DeleteRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission to delete it");

        _context.UserRecipes.Remove(recipe);
        await _context.SaveChangesAsync();
    }

    public async Task<PublishRecipeResultDto> PublishRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission");

        if (recipe.GlobalRecipeId.HasValue)
            throw new InvalidOperationException("This recipe is already linked to a global recipe");

        // Create global recipe from local data
        var globalRecipe = new GlobalRecipe
        {
            Id = Guid.NewGuid(),
            Title = recipe.LocalTitle ?? "Untitled Recipe",
            Description = recipe.LocalDescription,
            ImageUrl = recipe.LocalImageUrl,
            ImageUrls = recipe.LocalImageUrls,
            Ingredients = recipe.LocalIngredients ?? "[]",
            CreatedByUserId = userId,
            IsPublic = true,
            IsHellofresh = false,
            IsEditable = false, // Published recipes are not directly editable
            PublishedFromUserRecipeId = recipe.Id,
            TotalTimesAdded = 1,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.GlobalRecipes.Add(globalRecipe);

        // Link the user recipe to the new global recipe
        recipe.GlobalRecipeId = globalRecipe.Id;
        recipe.Visibility = "public";
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        // Record activity
        await _activityFeedService.RecordPublishedActivityAsync(
            userId,
            globalRecipe.Id,
            globalRecipe.Title,
            globalRecipe.ImageUrl);

        return new PublishRecipeResultDto
        {
            UserRecipe = MapToDto(recipe, userId),
            GlobalRecipeId = globalRecipe.Id,
            Message = "Recipe published successfully!"
        };
    }

    public async Task<UserRecipeDto> DetachRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found or you don't have permission");

        if (!recipe.GlobalRecipeId.HasValue)
            throw new InvalidOperationException("This recipe is not linked to a global recipe");

        // Copy global recipe data to local fields before detaching
        if (recipe.GlobalRecipe != null)
        {
            recipe.LocalTitle ??= recipe.GlobalRecipe.Title;
            recipe.LocalDescription ??= recipe.GlobalRecipe.Description;
            recipe.LocalIngredients ??= recipe.GlobalRecipe.Ingredients;
            recipe.LocalImageUrl ??= recipe.GlobalRecipe.ImageUrl;
            recipe.LocalImageUrls = string.IsNullOrEmpty(recipe.LocalImageUrls) || recipe.LocalImageUrls == "[]"
                ? recipe.GlobalRecipe.ImageUrls
                : recipe.LocalImageUrls;
        }

        // Detach from global recipe
        recipe.GlobalRecipeId = null;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        var updatedRecipe = await _context.UserRecipes
            .Include(r => r.User)
            .FirstAsync(r => r.Id == recipeId);

        return MapToDto(updatedRecipe, userId);
    }

    public async Task<UserRecipeDto> RateRecipeAsync(Guid recipeId, Guid userId, int rating, string? comment = null)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
            .FirstOrDefaultAsync(r => r.Id == recipeId)
            ?? throw new InvalidOperationException("Recipe not found");

        // Check if user can view this recipe
        if (!await CanUserViewRecipeAsync(recipeId, userId))
            throw new InvalidOperationException("You don't have permission to rate this recipe");

        // Find existing rating or create new
        var existingRating = await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserRecipeId == recipeId && r.UserId == userId);

        if (existingRating != null)
        {
            existingRating.Score = rating;
            existingRating.Comment = comment;
            existingRating.UpdatedAt = DateTime.UtcNow;
        }
        else
        {
            var newRating = new Rating
            {
                Id = Guid.NewGuid(),
                UserRecipeId = recipeId,
                GlobalRecipeId = recipe.GlobalRecipeId,
                UserId = userId,
                Score = rating,
                Comment = comment,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            _context.Ratings.Add(newRating);
        }

        // Update global recipe average if linked
        if (recipe.GlobalRecipeId.HasValue)
        {
            await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
        }

        await _context.SaveChangesAsync();

        // Record activity
        await _activityFeedService.RecordRatingActivityAsync(
            userId,
            recipeId,
            recipe.DisplayTitle,
            rating,
            recipe.LocalImageUrl);

        // Reload with includes
        var updatedRecipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .FirstAsync(r => r.Id == recipeId);

        return MapToDto(updatedRecipe, userId);
    }

    public async Task RemoveRatingAsync(Guid recipeId, Guid userId)
    {
        var rating = await _context.Ratings
            .FirstOrDefaultAsync(r => r.UserRecipeId == recipeId && r.UserId == userId);

        if (rating != null)
        {
            _context.Ratings.Remove(rating);

            var recipe = await _context.UserRecipes.FindAsync(recipeId);
            if (recipe?.GlobalRecipeId.HasValue == true)
            {
                await UpdateGlobalRecipeRatingAsync(recipe.GlobalRecipeId.Value);
            }

            await _context.SaveChangesAsync();
        }
    }

    public async Task<UserRecipeDto> ArchiveRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found");

        recipe.IsArchived = true;
        recipe.ArchivedDate = DateTime.UtcNow;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task<UserRecipeDto> RestoreRecipeAsync(Guid recipeId, Guid userId)
    {
        var recipe = await _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .FirstOrDefaultAsync(r => r.Id == recipeId && r.UserId == userId)
            ?? throw new InvalidOperationException("Recipe not found");

        recipe.IsArchived = false;
        recipe.ArchivedDate = null;
        recipe.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return MapToDto(recipe, userId);
    }

    public async Task<bool> CanUserViewRecipeAsync(Guid recipeId, Guid requestingUserId)
    {
        var recipe = await _context.UserRecipes
            .FirstOrDefaultAsync(r => r.Id == recipeId);

        if (recipe == null) return false;

        // Owner can always view
        if (recipe.UserId == requestingUserId) return true;

        return recipe.Visibility switch
        {
            "public" => true,
            "friends" => await _friendshipService.AreFriendsAsync(recipe.UserId, requestingUserId),
            "household" => await AreInSameHouseholdAsync(recipe.UserId, requestingUserId),
            _ => false // private
        };
    }

    public async Task<AggregatedRecipePagedResult> GetHouseholdRecipesAsync(
        Guid householdId,
        Guid requestingUserId,
        GetCombinedRecipesQuery query)
    {
        // Get all member IDs of the household
        var memberIds = await _context.HouseholdMembers
            .Where(hm => hm.HouseholdId == householdId)
            .Select(hm => hm.UserId)
            .ToListAsync();

        // Check if requesting user is a member
        if (!memberIds.Contains(requestingUserId))
            throw new InvalidOperationException("You are not a member of this household");

        // Get recipes from all members that are visible to household
        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .Where(r => memberIds.Contains(r.UserId))
            .Where(r => r.Visibility == "household" || r.Visibility == "public" || r.Visibility == "friends")
            .Where(r => !r.IsArchived);

        // Filter by specific members
        if (query.FilterByMembers?.Any() == true)
        {
            queryable = queryable.Where(r => query.FilterByMembers.Contains(r.UserId));
        }

        // Search
        if (!string.IsNullOrEmpty(query.Search))
        {
            queryable = queryable.Where(r =>
                (r.LocalTitle != null && r.LocalTitle.Contains(query.Search)) ||
                (r.GlobalRecipe != null && r.GlobalRecipe.Title.Contains(query.Search)));
        }

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "name" => query.SortDescending
                ? queryable.OrderByDescending(r => r.LocalTitle ?? r.GlobalRecipe!.Title)
                : queryable.OrderBy(r => r.LocalTitle ?? r.GlobalRecipe!.Title),
            "rating" => query.SortDescending
                ? queryable.OrderByDescending(r =>
                    r.Ratings
                     .Where(rt => memberIds.Contains(rt.UserId))
                     .Select(rt => (double?)rt.Score)
                     .Average() ?? 0)
                : queryable.OrderBy(r =>
                    r.Ratings
                     .Where(rt => memberIds.Contains(rt.UserId))
                     .Select(rt => (double?)rt.Score)
                     .Average() ?? 0),
            "owner" => query.SortDescending
                ? queryable.OrderByDescending(r => r.User.DisplayName)
                : queryable.OrderBy(r => r.User.DisplayName),
            _ => query.SortDescending
                ? queryable.OrderByDescending(r => r.CreatedAt)
                : queryable.OrderBy(r => r.CreatedAt)
        };

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new AggregatedRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToAggregatedDto(r, memberIds)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<List<CommonFavoriteDto>> GetCommonFavoritesAsync(
        Guid householdId,
        Guid requestingUserId,
        GetCommonFavoritesQuery query)
    {
        var memberIds = await _context.HouseholdMembers
            .Where(hm => hm.HouseholdId == householdId)
            .Select(hm => hm.UserId)
            .ToListAsync();

        if (!memberIds.Contains(requestingUserId))
            throw new InvalidOperationException("You are not a member of this household");

        // Find global recipes that multiple household members have rated highly
        var commonFavorites = await _context.Ratings
            .Include(r => r.GlobalRecipe)
            .Include(r => r.User)
            .Where(r => r.GlobalRecipeId.HasValue)
            .Where(r => memberIds.Contains(r.UserId))
            .GroupBy(r => r.GlobalRecipeId)
            .Where(g => g.Count() >= query.MinMembers)
            .Where(g => g.Average(r => r.Score) >= query.MinAverageRating)
            .Select(g => new
            {
                GlobalRecipeId = g.Key!.Value,
                Ratings = g.ToList(),
                AverageRating = g.Average(r => r.Score),
                MemberCount = g.Count()
            })
            .OrderByDescending(x => x.AverageRating)
            .ThenByDescending(x => x.MemberCount)
            .Take(query.Limit)
            .ToListAsync();

        var globalRecipeIds = commonFavorites.Select(cf => cf.GlobalRecipeId).ToList();
        var globalRecipes = await _context.GlobalRecipes
            .Where(gr => globalRecipeIds.Contains(gr.Id))
            .ToDictionaryAsync(gr => gr.Id);

        // Check which ones are in the requesting user's collection
        var userRecipeGlobalIds = await _context.UserRecipes
            .Where(ur => ur.UserId == requestingUserId && ur.GlobalRecipeId.HasValue)
            .Select(ur => ur.GlobalRecipeId!.Value)
            .ToListAsync();

        return commonFavorites.Select(cf =>
        {
            var globalRecipe = globalRecipes.GetValueOrDefault(cf.GlobalRecipeId);
            return new CommonFavoriteDto
            {
                GlobalRecipeId = cf.GlobalRecipeId,
                Name = globalRecipe?.Title ?? "Unknown",
                ImageUrl = globalRecipe?.ImageUrl,
                Description = globalRecipe?.Description,
                MemberRatings = cf.Ratings.Select(r => new MemberRatingDto
                {
                    UserId = r.UserId,
                    DisplayName = r.User?.DisplayName ?? "Unknown",
                    AvatarUrl = r.User?.AvatarUrl,
                    Rating = r.Score,
                    Comment = r.Comment,
                    RatedAt = r.CreatedAt
                }).ToList(),
                AverageRating = cf.AverageRating,
                MembersWhoRated = cf.MemberCount,
                IsInMyCollection = userRecipeGlobalIds.Contains(cf.GlobalRecipeId)
            };
        }).ToList();
    }

    // Private helpers

    public async Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(
        Guid requestingUserId,
        GetMultiGroupRecipesQuery query)
    {
        if (query.GroupIds == null || !query.GroupIds.Any())
        {
            return new AggregatedRecipePagedResult
            {
                Recipes = new List<AggregatedRecipeDto>(),
                TotalCount = 0,
                Page = query.Page,
                PageSize = query.PageSize
            };
        }

        // Verify user is a member of ALL requested groups
        var userMemberships = await _context.HouseholdMembers
            .Where(hm => hm.UserId == requestingUserId)
            .Select(hm => hm.HouseholdId)
            .ToListAsync();

        var unauthorizedGroups = query.GroupIds.Except(userMemberships).ToList();
        if (unauthorizedGroups.Any())
        {
            throw new InvalidOperationException(
                $"You are not a member of groups: {string.Join(", ", unauthorizedGroups)}");
        }

        // Get all unique member IDs from ALL selected groups
        var allMemberIds = await _context.HouseholdMembers
            .Where(hm => query.GroupIds.Contains(hm.HouseholdId))
            .Select(hm => hm.UserId)
            .Distinct()
            .ToListAsync();

        // Get recipes from all members that are visible to groups
        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .Where(r => allMemberIds.Contains(r.UserId))
            .Where(r => r.Visibility == "household" || r.Visibility == "public" || r.Visibility == "friends")
            .Where(r => !r.IsArchived);

        // Filter by specific members
        if (query.FilterByMembers?.Any() == true)
        {
            queryable = queryable.Where(r => query.FilterByMembers.Contains(r.UserId));
        }

        // Filter by minimum rating
        if (query.MinRating.HasValue)
        {
            queryable = queryable.Where(r =>
                r.Ratings.Any() && r.Ratings.Average(rt => rt.Score) >= query.MinRating.Value);
        }

        // Search
        if (!string.IsNullOrEmpty(query.Search))
        {
            queryable = queryable.Where(r =>
                (r.LocalTitle != null && r.LocalTitle.Contains(query.Search)) ||
                (r.GlobalRecipe != null && r.GlobalRecipe.Title.Contains(query.Search)));
        }

        // Sorting
        queryable = query.SortBy.ToLower() switch
        {
            "name" => query.SortDescending
                ? queryable.OrderByDescending(r => r.LocalTitle ?? r.GlobalRecipe!.Title)
                : queryable.OrderBy(r => r.LocalTitle ?? r.GlobalRecipe!.Title),
            "rating" => query.SortDescending
                ? queryable.OrderByDescending(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0)
                : queryable.OrderBy(r => r.Ratings.Any() ? r.Ratings.Average(rt => rt.Score) : 0),
            "owner" => query.SortDescending
                ? queryable.OrderByDescending(r => r.User.DisplayName)
                : queryable.OrderBy(r => r.User.DisplayName),
            _ => query.SortDescending
                ? queryable.OrderByDescending(r => r.CreatedAt)
                : queryable.OrderBy(r => r.CreatedAt)
        };

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new AggregatedRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToAggregatedDto(r, allMemberIds)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize
        };
    }

    public async Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(
        Guid requestingUserId,
        GetMultiGroupFavoritesQuery query)
    {
        if (query.GroupIds == null || !query.GroupIds.Any())
        {
            return new List<CommonFavoriteDto>();
        }

        // Verify user is a member of ALL requested groups
        var userMemberships = await _context.HouseholdMembers
            .Where(hm => hm.UserId == requestingUserId)
            .Select(hm => hm.HouseholdId)
            .ToListAsync();

        var unauthorizedGroups = query.GroupIds.Except(userMemberships).ToList();
        if (unauthorizedGroups.Any())
        {
            throw new InvalidOperationException(
                $"You are not a member of groups: {string.Join(", ", unauthorizedGroups)}");
        }

        // Get all unique member IDs from ALL selected groups
        var allMemberIds = await _context.HouseholdMembers
            .Where(hm => query.GroupIds.Contains(hm.HouseholdId))
            .Select(hm => hm.UserId)
            .Distinct()
            .ToListAsync();

        // Find global recipes that multiple members have rated highly
        var commonFavorites = await _context.Ratings
            .Include(r => r.GlobalRecipe)
            .Include(r => r.User)
            .Where(r => r.GlobalRecipeId.HasValue)
            .Where(r => allMemberIds.Contains(r.UserId))
            .GroupBy(r => r.GlobalRecipeId)
            .Where(g => g.Count() >= query.MinMembers)
            .Where(g => g.Average(r => r.Score) >= query.MinAverageRating)
            .Select(g => new
            {
                GlobalRecipeId = g.Key!.Value,
                Ratings = g.ToList(),
                AverageRating = g.Average(r => r.Score),
                MemberCount = g.Count()
            })
            .OrderByDescending(x => x.AverageRating)
            .ThenByDescending(x => x.MemberCount)
            .Take(query.Limit)
            .ToListAsync();

        var globalRecipeIds = commonFavorites.Select(cf => cf.GlobalRecipeId).ToList();
        var globalRecipes = await _context.GlobalRecipes
            .Where(gr => globalRecipeIds.Contains(gr.Id))
            .ToDictionaryAsync(gr => gr.Id);

        // Check which ones are in the requesting user's collection
        var userRecipeGlobalIds = await _context.UserRecipes
            .Where(ur => ur.UserId == requestingUserId && ur.GlobalRecipeId.HasValue)
            .Select(ur => ur.GlobalRecipeId!.Value)
            .ToListAsync();

        return commonFavorites.Select(cf =>
        {
            var globalRecipe = globalRecipes.GetValueOrDefault(cf.GlobalRecipeId);
            return new CommonFavoriteDto
            {
                GlobalRecipeId = cf.GlobalRecipeId,
                Name = globalRecipe?.Title ?? "Unknown",
                ImageUrl = globalRecipe?.ImageUrl,
                Description = globalRecipe?.Description,
                MemberRatings = cf.Ratings.Select(r => new MemberRatingDto
                {
                    UserId = r.UserId,
                    DisplayName = r.User?.DisplayName ?? "Unknown",
                    AvatarUrl = r.User?.AvatarUrl,
                    Rating = r.Score,
                    Comment = r.Comment,
                    RatedAt = r.CreatedAt
                }).ToList(),
                AverageRating = cf.AverageRating,
                MembersWhoRated = cf.MemberCount,
                IsInMyCollection = userRecipeGlobalIds.Contains(cf.GlobalRecipeId)
            };
        }).ToList();
    }

    public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(Guid userId, GetUserRecipesQuery query)
    {
        // Get all friend user IDs
        var friendIds = await _friendshipService.GetFriendIdsAsync(userId);

        if (!friendIds.Any())
        {
            return new UserRecipePagedResult
            {
                Recipes = new List<UserRecipeDto>(),
                TotalCount = 0,
                Page = query.Page,
                PageSize = query.PageSize,
            };
        }

        // Get recipes from friends that are visible to the requesting user
        // Friends can see: public, friends visibility recipes
        var queryable = _context.UserRecipes
            .Include(r => r.User)
            .Include(r => r.GlobalRecipe)
            .Include(r => r.Ratings)
                .ThenInclude(rt => rt.User)
            .Where(r => friendIds.Contains(r.UserId))
            .Where(r => r.Visibility == "friends" || r.Visibility == "public")
            .Where(r => !r.IsArchived);

        // Sort by date by default
        queryable = queryable.OrderByDescending(r => r.CreatedAt);

        var totalCount = await queryable.CountAsync();
        var recipes = await queryable
            .Skip((query.Page - 1) * query.PageSize)
            .Take(query.PageSize)
            .ToListAsync();

        return new UserRecipePagedResult
        {
            Recipes = recipes.Select(r => MapToDto(r, userId)).ToList(),
            TotalCount = totalCount,
            Page = query.Page,
            PageSize = query.PageSize,
        };
    }

    private async Task<bool> AreInSameHouseholdAsync(Guid userId1, Guid userId2)
    {
        var user1Households = await _context.HouseholdMembers
            .Where(hm => hm.UserId == userId1)
            .Select(hm => hm.HouseholdId)
            .ToListAsync();

        return await _context.HouseholdMembers
            .AnyAsync(hm => hm.UserId == userId2 && user1Households.Contains(hm.HouseholdId));
    }

    private async Task UpdateGlobalRecipeRatingAsync(Guid globalRecipeId)
    {
        var ratings = await _context.Ratings
            .Where(r => r.GlobalRecipeId == globalRecipeId)
            .ToListAsync();

        var globalRecipe = await _context.GlobalRecipes.FindAsync(globalRecipeId);
        if (globalRecipe != null)
        {
            globalRecipe.RatingCount = ratings.Count;
            globalRecipe.TotalRatings = ratings.Count;
            globalRecipe.AverageRating = ratings.Any()
                ? (decimal)ratings.Average(r => r.Score)
                : 0;
        }
    }

    private UserRecipeDto MapToDto(UserRecipe recipe, Guid requestingUserId)
    {
        var imageUrls = new List<string>();
        try
        {
            if (!string.IsNullOrEmpty(recipe.LocalImageUrl))
            {
                imageUrls.Add(recipe.LocalImageUrl);
            }
            else if (!string.IsNullOrEmpty(recipe.LocalImageUrls) && recipe.LocalImageUrls != "[]")
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.LocalImageUrls) ?? new();
            }
            else if (recipe.GlobalRecipe != null && !string.IsNullOrEmpty(recipe.GlobalRecipe.ImageUrls))
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.GlobalRecipe.ImageUrls) ?? new();
            }
        }
        catch { }

        var myRating = recipe.Ratings?.FirstOrDefault(r => r.UserId == requestingUserId);

        var householdRatings = recipe.Ratings?
            .Where(r => r.User != null)
            .ToDictionary(r => r.User!.DisplayName, r => (int?)r.Score)
            ?? new Dictionary<string, int?>();

        var memberRatings = recipe.Ratings?
            .Where(r => r.User != null)
            .GroupBy(r => r.UserId)
            .Select(g => g.OrderByDescending(x => x.UpdatedAt).First())
            .Select(r => new MemberRatingDto
            {
                UserId = r.UserId,
                DisplayName = r.User!.DisplayName ?? "Unknown",
                AvatarUrl = r.User!.AvatarUrl,
                Rating = r.Score,
                Comment = r.Comment,
                RatedAt = r.UpdatedAt
            })
            .ToList() ?? new List<MemberRatingDto>();


        return new UserRecipeDto
        {
            Id = recipe.Id,
            UserId = recipe.UserId,
            UserDisplayName = recipe.User?.DisplayName ?? "Unknown",
            UserAvatarUrl = recipe.User?.AvatarUrl,
            Name = recipe.LocalTitle ?? recipe.GlobalRecipe?.Title ?? "Untitled",
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = imageUrls,
            Ingredients = recipe.LocalIngredients != null
                ? JsonSerializer.Deserialize<object>(recipe.LocalIngredients)
                : (recipe.GlobalRecipe?.Ingredients != null
                    ? JsonSerializer.Deserialize<object>(recipe.GlobalRecipe.Ingredients)
                    : null),
            GlobalRecipeId = recipe.GlobalRecipeId,
            GlobalRecipeName = recipe.GlobalRecipe?.Title,
            IsPublished = recipe.GlobalRecipe?.PublishedFromUserRecipeId == recipe.Id,
            Visibility = recipe.Visibility,
            PersonalNotes = recipe.PersonalNotes,
            IsArchived = recipe.IsArchived,
            CreatedAt = recipe.CreatedAt,
            UpdatedAt = recipe.UpdatedAt,
            AverageRating = memberRatings.Any() ? memberRatings.Average(m => m.Rating) : 0,
            RatingCount = memberRatings.Count,
            MyRating = memberRatings.FirstOrDefault(m => m.UserId == requestingUserId)?.Rating,
            MemberRatings = memberRatings,
            HouseholdRatings = householdRatings
        };
    }

    private AggregatedRecipeDto MapToAggregatedDto(UserRecipe recipe, List<Guid> householdMemberIds)
    {
        var imageUrls = new List<string>();
        try
        {
            if (!string.IsNullOrEmpty(recipe.LocalImageUrl))
            {
                imageUrls.Add(recipe.LocalImageUrl);
            }
            else if (!string.IsNullOrEmpty(recipe.LocalImageUrls) && recipe.LocalImageUrls != "[]")
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.LocalImageUrls) ?? new();
            }
            else if (recipe.GlobalRecipe != null && !string.IsNullOrEmpty(recipe.GlobalRecipe.ImageUrls))
            {
                imageUrls = JsonSerializer.Deserialize<List<string>>(recipe.GlobalRecipe.ImageUrls) ?? new();
            }
        }
        catch { }

        // Only include ratings from household members (dedupe per userId just in case)
        var memberRatings = recipe.Ratings?
        .Where(r => householdMemberIds.Contains(r.UserId) && r.User != null)
        .GroupBy(r => r.UserId)
        .Select(g => g.OrderByDescending(x => x.UpdatedAt).First())
        .Select(r => new MemberRatingDto
        {
            UserId = r.UserId,
            DisplayName = r.User!.DisplayName ?? "Unknown",
            AvatarUrl = r.User!.AvatarUrl,
            Rating = r.Score,
            Comment = r.Comment,
            RatedAt = r.UpdatedAt
        })
        .ToList() ?? new List<MemberRatingDto>();

            var scores = memberRatings.Select(m => m.Rating).ToList();


        return new AggregatedRecipeDto
        {
            UserRecipeId = recipe.Id,
            OwnerUserId = recipe.UserId,
            OwnerDisplayName = recipe.User?.DisplayName ?? "Unknown",
            OwnerAvatarUrl = recipe.User?.AvatarUrl,
            Name = recipe.LocalTitle ?? recipe.GlobalRecipe?.Title ?? "Untitled",
            Description = recipe.LocalDescription ?? recipe.GlobalRecipe?.Description,
            ImageUrls = imageUrls,
            GlobalRecipeId = recipe.GlobalRecipeId,

            MemberRatings = memberRatings,
            HouseholdAverageRating = scores.Any() ? scores.Average() : 0,
            HouseholdRatingCount = scores.Count,

            CreatedAt = recipe.CreatedAt
        };
    }

}


================================================================================
FILE END: \StorhaugenEats.API\Services\UserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Services\UserService.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Models;

namespace StorhaugenEats.API.Services;

public class UserService : IUserService
{
    private readonly AppDbContext _context;

    public UserService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<User?> GetByIdAsync(Guid id)
    {
        return await _context.Users
            .Include(u => u.CurrentHousehold)
            .FirstOrDefaultAsync(u => u.Id == id);
    }

    public async Task<User?> GetByEmailAsync(string email)
    {
        return await _context.Users
            .Include(u => u.CurrentHousehold)
            .FirstOrDefaultAsync(u => u.Email == email);
    }

    public async Task<User?> GetByShareIdAsync(string shareId)
    {
        return await _context.Users
            .Include(u => u.CurrentHousehold)
            .FirstOrDefaultAsync(u => u.UniqueShareId == shareId);
    }

    public async Task<User> CreateAsync(Guid authUserId, string email, string displayName, string? avatarUrl = null)
    {
        var shareId = await GenerateUniqueShareIdAsync();

        var user = new User
        {
            Id = authUserId, // Use Supabase Auth user ID
            Email = email,
            DisplayName = displayName,
            AvatarUrl = avatarUrl,
            UniqueShareId = shareId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return user;
    }

    public async Task<User> UpdateAsync(User user)
    {
        user.UpdatedAt = DateTime.UtcNow;
        _context.Users.Update(user);
        await _context.SaveChangesAsync();
        return user;
    }

    public async Task<string> GenerateUniqueShareIdAsync()
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Exclude confusing chars
        var random = new Random();
        string shareId;

        do
        {
            shareId = new string(Enumerable.Range(0, 12)
                .Select(_ => chars[random.Next(chars.Length)])
                .ToArray());
        }
        while (await _context.Users.AnyAsync(u => u.UniqueShareId == shareId));

        return shareId;
    }
}


================================================================================
FILE END: \StorhaugenEats.API\Services\UserService.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\appsettings.json
================================================================================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Host=aws-1-eu-west-1.pooler.supabase.com;Port=5432;Database=postgres;Username=postgres.ithuvxvsoozmvdicxedx;Password=Elias25112099!;Timeout=300;CommandTimeout=300;Pooling=true;MinPoolSize=1;MaxPoolSize=20;SSL Mode=Require;Trust Server Certificate=true;Include Error Detail=true;Keepalive=30;TCP Keepalive=true;TCP Keepalive Time=30;TCP Keepalive Interval=10"
  },
  "Supabase": {
    "Url": "https://ithuvxvsoozmvdicxedx.supabase.co",
    "AnonKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0",
    "ServiceRoleKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2NDk2MDU3MiwiZXhwIjoyMDgwNTM2NTcyfQ.U5W3C_LKYYlBkqUfjXfL9nxrWyDxG3PReVsqamfjOWY",
    "JwtSecret": "qlDo8dj/zFMRia+cZa5ZqOHI+zOc6YLPmk8BhLf6pzREOdpQt+xHhHH/2FxY0z+eygXNrahHu0ihk/VH5VPelA=="
  },
  "HelloFresh": {
    "BaseUrl": "https://www.hellofresh.no",
    "SyncIntervalHours": 24,
    "WeeksToFetch": 4
  }
}


================================================================================
FILE END: \StorhaugenEats.API\appsettings.json
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\Program.cs
================================================================================
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using StorhaugenEats.API.Data;
using StorhaugenEats.API.Services;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Add configuration
builder.Configuration.AddEnvironmentVariables();
builder.Configuration.AddJsonFile("appsettings.json", optional: false);
builder.Configuration.AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database Context
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(connectionString));

// Supabase Client
builder.Services.AddSingleton(sp =>
{
    var url = builder.Configuration["Supabase:Url"] ?? throw new InvalidOperationException("Supabase URL not configured");
    var key = builder.Configuration["Supabase:ServiceRoleKey"] ?? throw new InvalidOperationException("Supabase Service Role Key not configured");

    var options = new Supabase.SupabaseOptions
    {
        AutoConnectRealtime = false // We don't need realtime in the API
    };

    return new Supabase.Client(url, key, options);
});

// HTTP Context Accessor (needed for CurrentUserService)
builder.Services.AddHttpContextAccessor();

// Application Services
builder.Services.AddScoped<ICurrentUserService, CurrentUserService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IHouseholdService, HouseholdService>();
builder.Services.AddScoped<IGlobalRecipeService, GlobalRecipeService>();
builder.Services.AddScoped<IRatingService, RatingService>();
builder.Services.AddScoped<IStorageService, SupabaseStorageService>();
builder.Services.AddScoped<IHelloFreshScraperService, HelloFreshScraperService>();
// HTTP Client for scraper
builder.Services.AddHttpClient<IHelloFreshScraperService, HelloFreshScraperService>();

// New User-Centric Services
builder.Services.AddScoped<IUserFriendshipService, UserFriendshipService>();
builder.Services.AddScoped<IActivityFeedService, ActivityFeedService>();
builder.Services.AddScoped<IUserRecipeService, UserRecipeService>();
builder.Services.AddScoped<ITagService, TagService>();

// JWT Authentication (Supabase JWT)
var jwtSecret = builder.Configuration["Supabase:JwtSecret"] ?? throw new InvalidOperationException("JWT Secret not configured");
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSecret)),
        ValidateIssuer = true,
        ValidIssuer = $"{builder.Configuration["Supabase:Url"]}/auth/v1",
        ValidateAudience = false,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero,
        NameClaimType = "email", // Map email claim to Name for easier access
        RoleClaimType = "role"
    };

    // Enable detailed logging for JWT validation failures (development only)
    options.Events = new JwtBearerEvents
    {
        OnAuthenticationFailed = context =>
        {
            if (builder.Environment.IsDevelopment())
            {
                Console.WriteLine($"JWT Authentication failed: {context.Exception.Message}");
            }
            return Task.CompletedTask;
        },
        OnTokenValidated = context =>
        {
            if (builder.Environment.IsDevelopment())
            {
                var email = context.Principal?.FindFirst("email")?.Value;
                Console.WriteLine($"JWT Token validated for user: {email}");
            }
            return Task.CompletedTask;
        }
    };
});

builder.Services.AddAuthorization();

// CORS (for Blazor WASM)
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowBlazorWasm", policy =>
    {
        var allowedOrigins = new List<string>
        {
            // Development - Frontend
            "https://localhost:7280",  // Frontend HTTPS
            "http://localhost:5055",   // Frontend HTTP
            "https://localhost:7000",
            "https://localhost:7001",
            "https://localhost:5001",
            "http://localhost:5000",
            "https://127.0.0.1:7280",
            "https://127.0.0.1:7000",
            "https://127.0.0.1:7001",

            // Production (GitHub Pages)
            "https://markus-sv.github.io"
        };

        // Add additional production URL from configuration if specified
        var productionUrl = builder.Configuration["Frontend:ProductionUrl"];
        if (!string.IsNullOrEmpty(productionUrl))
        {
            allowedOrigins.Add(productionUrl);
        }

        policy.WithOrigins(allowedOrigins.ToArray())
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

var app = builder.Build();

// Run database migrations on startup
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    try
    {
        var context = services.GetRequiredService<AppDbContext>();
        context.Database.Migrate();
        Console.WriteLine("✅ Database migrations applied successfully");
    }
    catch (Exception ex)
    {
        var logger = services.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "An error occurred while migrating the database");
        // Don't fail startup, just log the error
    }
}

// Configure the HTTP request pipeline
// Enable Swagger in all environments for easier testing
app.UseSwagger();
app.UseSwaggerUI();

app.UseHttpsRedirection();
app.UseCors("AllowBlazorWasm");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

// Health check endpoint
app.MapGet("/health", () => Results.Ok(new { status = "healthy", timestamp = DateTime.UtcNow }));

// Database connection test endpoint
app.MapGet("/test-connections", async (IConfiguration configuration) =>
{
    await StorhaugenEats.API.ConnectionTester.TestAllConnectionsAsync(configuration);
    return Results.Ok(new { message = "Check console output for connection test results" });
});

app.Run();


================================================================================
FILE END: \StorhaugenEats.API\Program.cs
================================================================================


================================================================================
FILE START: \StorhaugenEats.API\StorhaugenEats.API.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- ASP.NET Core -->
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />

    <!-- Entity Framework Core for PostgreSQL -->
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>

    <!-- Supabase Client -->
	  <PackageReference Include="MudBlazor" Version="8.15.0" />

	  <PackageReference Include="Supabase" Version="1.1.1" />
	  <PackageReference Include="Supabase.Gotrue" Version="6.0.3" />

    <!-- HTTP Client for HelloFresh scraper -->
    <PackageReference Include="HtmlAgilityPack" Version="1.12.4" />

    <!-- Authentication -->
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />

    <!-- JSON -->
    <PackageReference Include="System.Text.Json" Version="10.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenEats.API\StorhaugenEats.API.csproj
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\ApiClient\ApiClient.cs
================================================================================
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using StorhaugenWebsite.Shared.DTOs;
using StorhaugenWebsite.Services;

namespace StorhaugenWebsite.ApiClient;

public class ApiClient : IApiClient
{
    private readonly HttpClient _httpClient;
    private readonly IAuthService _authService;
    private readonly JsonSerializerOptions _jsonOptions;

    public ApiClient(HttpClient httpClient, IAuthService authService)
    {
        _httpClient = httpClient;
        _authService = authService;

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    private async Task AddAuthHeaderAsync()
    {
        var token = await _authService.GetAccessTokenAsync();
        if (!string.IsNullOrEmpty(token))
        {
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
        }
    }

    // User Methods
    public async Task<UserDto?> GetMyProfileAsync()
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserDto>("/api/users/me", _jsonOptions);
    }

    public async Task<UserDto> UpdateMyProfileAsync(UpdateUserDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync("/api/users/me", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserDto>(_jsonOptions))!;
    }

    // Household Methods
    public async Task<List<HouseholdDto>> GetMyHouseholdsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<HouseholdDto>>("/api/households/my", _jsonOptions)) ?? new();
    }

    public async Task<HouseholdDto?> GetHouseholdAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<HouseholdDto>($"/api/households/{id}", _jsonOptions);
    }

    public async Task<HouseholdDto> CreateHouseholdAsync(CreateHouseholdDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/households", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdDto>(_jsonOptions))!;
    }

    public async Task<HouseholdDto> UpdateHouseholdSettingsAsync(Guid id, UpdateHouseholdSettingsDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/households/{id}/settings", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdDto>(_jsonOptions))!;
    }

    public async Task<HouseholdDto> UpdateHouseholdNameAsync(Guid id, UpdateHouseholdDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/households/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdDto>(_jsonOptions))!;
    }

    public async Task<HouseholdDto> RegenerateHouseholdShareIdAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/households/{id}/regenerate-share-id", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdDto>(_jsonOptions))!;
    }

    public async Task SwitchHouseholdAsync(Guid householdId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/households/{householdId}/switch", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<HouseholdInviteDto>> GetPendingInvitesAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<HouseholdInviteDto>>("/api/households/invites/pending", _jsonOptions)) ?? new();
    }

    public async Task AcceptInviteAsync(Guid inviteId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/households/invites/{inviteId}/accept", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task RejectInviteAsync(Guid inviteId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/households/invites/{inviteId}/reject", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task InviteToHouseholdAsync(Guid householdId, InviteToHouseholdDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync($"/api/households/{householdId}/invites", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }

    public async Task LeaveHouseholdAsync(Guid householdId)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/households/{householdId}/leave", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<HouseholdSearchResultDto>> SearchHouseholdsAsync(string query)
    {
        await AddAuthHeaderAsync();
        var results = await _httpClient.GetFromJsonAsync<List<HouseholdSearchResultDto>>($"/api/households/search?query={Uri.EscapeDataString(query)}", _jsonOptions);
        return results ?? new List<HouseholdSearchResultDto>();
    }

    public async Task<List<HouseholdFriendshipDto>> GetHouseholdFriendshipsAsync()
    {
        await AddAuthHeaderAsync();
        var results = await _httpClient.GetFromJsonAsync<List<HouseholdFriendshipDto>>("/api/household-friendships", _jsonOptions);
        return results ?? new List<HouseholdFriendshipDto>();
    }

    public async Task<HouseholdFriendshipDto> SendHouseholdFriendRequestAsync(SendHouseholdFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/household-friendships/request", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdFriendshipDto>(_jsonOptions))!;
    }

    public async Task<HouseholdFriendshipDto> RespondHouseholdFriendRequestAsync(Guid requestId, RespondFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync($"/api/household-friendships/{requestId}/respond", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdFriendshipDto>(_jsonOptions))!;
    }

    // Household Recipe Methods
    public async Task<List<HouseholdRecipeDto>> GetRecipesAsync(bool includeArchived = false)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/household-recipes?includeArchived={includeArchived}";
        return (await _httpClient.GetFromJsonAsync<List<HouseholdRecipeDto>>(url, _jsonOptions)) ?? new();
    }

    public async Task<HouseholdRecipeDto?> GetRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<HouseholdRecipeDto>($"/api/household-recipes/{id}", _jsonOptions);
    }

    public async Task<PublicRecipeDto?> GetPublicRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<PublicRecipeDto>($"api/household-recipes/public/{id}", _jsonOptions);
    }

    public async Task<HouseholdRecipeDto> CreateRecipeAsync(CreateHouseholdRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/household-recipes", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdRecipeDto>(_jsonOptions))!;
    }

    public async Task<HouseholdRecipeDto> UpdateRecipeAsync(Guid id, UpdateHouseholdRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/household-recipes/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<HouseholdRecipeDto>(_jsonOptions))!;
    }

    public async Task ArchiveRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/household-recipes/{id}/archive", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task RestoreRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/household-recipes/{id}/restore", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task RateRecipeAsync(Guid id, int rating)
    {
        await AddAuthHeaderAsync();
        var dto = new RateRecipeDto { Rating = rating };
        var response = await _httpClient.PostAsJsonAsync($"/api/household-recipes/{id}/rate", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }

    public async Task ForkRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/household-recipes/{id}/fork", null);
        response.EnsureSuccessStatusCode();
    }

    public async Task DeleteRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/household-recipes/{id}");
        response.EnsureSuccessStatusCode();
    }

    // Global Recipe Methods
    public async Task<GlobalRecipePagedResult> BrowseGlobalRecipesAsync(BrowseGlobalRecipesQuery query)
    {
        var queryParams = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.Search))
            queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

        if (!string.IsNullOrWhiteSpace(query.Cuisine))
            queryParams.Add($"cuisine={Uri.EscapeDataString(query.Cuisine)}");

        if (!string.IsNullOrWhiteSpace(query.Difficulty))
            queryParams.Add($"difficulty={Uri.EscapeDataString(query.Difficulty)}");

        if (query.MaxPrepTime.HasValue)
            queryParams.Add($"maxPrepTime={query.MaxPrepTime.Value}");

        if (query.Tags != null && query.Tags.Count > 0)
        {
            foreach (var tag in query.Tags)
                queryParams.Add($"tags={Uri.EscapeDataString(tag)}");
        }

        if (query.HellofreshOnly)
            queryParams.Add("hellofreshOnly=true");

        queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = $"/api/global-recipes?{string.Join("&", queryParams)}";

        return (await _httpClient.GetFromJsonAsync<GlobalRecipePagedResult>(url, _jsonOptions))
            ?? new GlobalRecipePagedResult();
    }

    public async Task<GlobalRecipeDto?> GetGlobalRecipeAsync(Guid id)
    {
        return await _httpClient.GetFromJsonAsync<GlobalRecipeDto>($"/api/global-recipes/{id}", _jsonOptions);
    }

    public async Task<List<GlobalRecipeDto>> SearchGlobalRecipesAsync(string query, int limit = 20)
    {
        var url = $"/api/global-recipes/search?q={Uri.EscapeDataString(query)}&limit={limit}";
        return (await _httpClient.GetFromJsonAsync<List<GlobalRecipeDto>>(url, _jsonOptions)) ?? new();
    }

    public async Task DeleteGlobalRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/global-recipes/{id}");
        response.EnsureSuccessStatusCode();
    }

    // Public Household Recipes (community recipes)
    public async Task<PublicRecipePagedResult> BrowsePublicRecipesAsync(BrowsePublicRecipesQuery query)
    {
        var queryParams = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.Search))
            queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

        queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = $"/api/household-recipes/public?{string.Join("&", queryParams)}";

        return (await _httpClient.GetFromJsonAsync<PublicRecipePagedResult>(url, _jsonOptions))
            ?? new PublicRecipePagedResult();
    }

    // Storage Methods
    public async Task<UploadImageResultDto> UploadImageAsync(byte[] imageData, string fileName)
    {
        await AddAuthHeaderAsync();

        var base64 = Convert.ToBase64String(imageData);
        var dto = new UploadImageDto
        {
            FileName = fileName,
            Base64Data = base64
        };

        var response = await _httpClient.PostAsJsonAsync("/api/storage/upload", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();

        return (await response.Content.ReadFromJsonAsync<UploadImageResultDto>(_jsonOptions))!;
    }

    public async Task DeleteImageAsync(string fileName)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/storage/{Uri.EscapeDataString(fileName)}");
        response.EnsureSuccessStatusCode();
    }

    // User Recipes (user-centric recipe management)
    public async Task<UserRecipePagedResult> GetMyUserRecipesAsync(GetUserRecipesQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.Visibility))
            queryParams.Add($"visibility={Uri.EscapeDataString(query.Visibility)}");

        if (query.IncludeArchived)
            queryParams.Add("includeArchived=true");

        queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = $"/api/user-recipes?{string.Join("&", queryParams)}";
        return (await _httpClient.GetFromJsonAsync<UserRecipePagedResult>(url, _jsonOptions))
            ?? new UserRecipePagedResult();
    }

    public async Task<UserRecipeDto?> GetUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserRecipeDto>($"/api/user-recipes/{id}", _jsonOptions);
    }

    public async Task<UserRecipeDto> CreateUserRecipeAsync(CreateUserRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/user-recipes", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> UpdateUserRecipeAsync(Guid id, UpdateUserRecipeDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/user-recipes/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task DeleteUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/user-recipes/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<PublishRecipeResultDto> PublishUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/publish", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<PublishRecipeResultDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> DetachUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/detach", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> RateUserRecipeAsync(Guid id, int rating, string? comment = null)
    {
        await AddAuthHeaderAsync();
        var dto = new { Rating = rating, Comment = comment };
        var response = await _httpClient.PostAsJsonAsync($"/api/user-recipes/{id}/rate", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task RemoveUserRecipeRatingAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/user-recipes/{id}/rate");
        response.EnsureSuccessStatusCode();
    }

    public async Task<UserRecipeDto> ArchiveUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/archive", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipeDto> RestoreUserRecipeAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsync($"/api/user-recipes/{id}/restore", null);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipeDto>(_jsonOptions))!;
    }

    public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();
        if (query.Page > 0) queryParams.Add($"page={query.Page}");
        if (query.PageSize > 0) queryParams.Add($"pageSize={query.PageSize}");

        var url = "/api/user-recipes/friends";
        if (queryParams.Any()) url += "?" + string.Join("&", queryParams);

        var response = await _httpClient.GetAsync(url);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserRecipePagedResult>(_jsonOptions))!;
    }

    // User Friendships
    public async Task<FriendshipListDto> GetFriendshipsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<FriendshipListDto>("/api/friendships", _jsonOptions))
            ?? new FriendshipListDto();
    }

    public async Task<List<FriendProfileDto>> GetFriendsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<FriendProfileDto>>("/api/friendships/friends", _jsonOptions))
            ?? new List<FriendProfileDto>();
    }

    public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<UserFriendshipDto>($"/api/friendships/{id}", _jsonOptions);
    }

    public async Task<UserFriendshipDto> SendFriendRequestAsync(SendFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/friendships/request", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserFriendshipDto>(_jsonOptions))!;
    }

    // In StorhaugenWebsite\ApiClient\ApiClient.cs

    public async Task<UserFriendshipDto> RespondToFriendRequestAsync(Guid id, RespondFriendRequestDto dto)
    {
        await AddAuthHeaderAsync();

        var response = await _httpClient.PostAsJsonAsync($"/api/friendships/{id}/respond", dto, _jsonOptions);

        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<UserFriendshipDto>(_jsonOptions))!;
    }

    public async Task RemoveFriendshipAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/friendships/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/friendships/search?query={Uri.EscapeDataString(query)}&limit={limit}";
        return (await _httpClient.GetFromJsonAsync<List<UserSearchResultDto>>(url, _jsonOptions))
            ?? new List<UserSearchResultDto>();
    }

    public async Task<FriendProfileDto?> GetUserProfileAsync(Guid userId)
    {
        await AddAuthHeaderAsync();
        return await _httpClient.GetFromJsonAsync<FriendProfileDto>($"/api/friendships/profile/{userId}", _jsonOptions);
    }

    // Activity Feed
    public async Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery query)
    {
        await AddAuthHeaderAsync();
        var queryParams = new List<string>();

        if (query.Types != null && query.Types.Count > 0)
        {
            foreach (var type in query.Types)
                queryParams.Add($"Types={Uri.EscapeDataString(type)}");
        }

        if (query.UserIds != null && query.UserIds.Count > 0)
        {
            foreach (var friendId in query.UserIds)
                queryParams.Add($"friendIds={friendId}");
        }

        queryParams.Add($"page={query.Page}");
        queryParams.Add($"pageSize={query.PageSize}");

        var url = queryParams.Count > 0
            ? $"/api/feed?{string.Join("&", queryParams)}"
            : "/api/feed";

        return (await _httpClient.GetFromJsonAsync<ActivityFeedPagedResult>(url, _jsonOptions))
            ?? new ActivityFeedPagedResult();
    }

    public async Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/feed/my-activity?page={page}&pageSize={pageSize}";
        return (await _httpClient.GetFromJsonAsync<ActivityFeedPagedResult>(url, _jsonOptions))
            ?? new ActivityFeedPagedResult();
    }

    public async Task<ActivitySummaryDto> GetActivitySummaryAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<ActivitySummaryDto>("/api/feed/summary", _jsonOptions))
            ?? new ActivitySummaryDto();
    }

    public async Task<List<UserRatingDto>> GetUserRatingsAsync(Guid userId, int skip = 0, int take = 50)
    {
        await AddAuthHeaderAsync();

        var url = $"/api/ratings/user/{userId}?skip={skip}&take={take}";
        return (await _httpClient.GetFromJsonAsync<List<UserRatingDto>>(url, _jsonOptions)) ?? new List<UserRatingDto>();
    }

    // Household Recipe Aggregation
    // In ApiClient.cs

    public async Task<AggregatedRecipePagedResult> GetHouseholdCombinedRecipesAsync(Guid householdId, GetCombinedRecipesQuery query)
	{
		await AddAuthHeaderAsync();
		var queryParams = new List<string>();

		if (!string.IsNullOrWhiteSpace(query.Search))
			queryParams.Add($"search={Uri.EscapeDataString(query.Search)}");

		// FIX: Changed from query.MemberIds to query.FilterByMembers
		if (query.FilterByMembers != null && query.FilterByMembers.Count > 0)
		{
			foreach (var memberId in query.FilterByMembers)
				queryParams.Add($"filterByMembers={memberId}");
		}

		// FIX: Changed from query.MinimumRating to query.MinRating
		if (query.MinRating.HasValue)
			queryParams.Add($"minRating={query.MinRating.Value}");

		queryParams.Add($"sortBy={Uri.EscapeDataString(query.SortBy)}");
		queryParams.Add($"sortDescending={query.SortDescending}"); // Added this based on DTO
		queryParams.Add($"page={query.Page}");
		queryParams.Add($"pageSize={query.PageSize}");

		var url = $"/api/households/{householdId}/combined-recipes?{string.Join("&", queryParams)}";

		return (await _httpClient.GetFromJsonAsync<AggregatedRecipePagedResult>(url, _jsonOptions))
			?? new AggregatedRecipePagedResult();
	}

	public async Task<List<CommonFavoriteDto>> GetHouseholdCommonFavoritesAsync(Guid householdId, int minimumMembers = 2, int limit = 10)
    {
        await AddAuthHeaderAsync();
        var url = $"/api/households/{householdId}/common-favorites?minimumMembers={minimumMembers}&limit={limit}";
        return (await _httpClient.GetFromJsonAsync<List<CommonFavoriteDto>>(url, _jsonOptions))
            ?? new List<CommonFavoriteDto>();
    }

    // Multi-group Recipe Aggregation
    public async Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(GetMultiGroupRecipesQuery query)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/user-recipes/groups/aggregate", query, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<AggregatedRecipePagedResult>(_jsonOptions))
            ?? new AggregatedRecipePagedResult();
    }

    public async Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(GetMultiGroupFavoritesQuery query)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/user-recipes/groups/common-favorites", query, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<List<CommonFavoriteDto>>(_jsonOptions))
            ?? new List<CommonFavoriteDto>();
    }

    // ==========================================
    // TAGS (Personal Recipe Organization)
    // ==========================================

    public async Task<List<TagDto>> GetMyTagsAsync()
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<TagDto>>("/api/tags", _jsonOptions))
            ?? new List<TagDto>();
    }

    public async Task<TagDto?> GetTagAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        try
        {
            return await _httpClient.GetFromJsonAsync<TagDto>($"/api/tags/{id}", _jsonOptions);
        }
        catch (HttpRequestException)
        {
            return null;
        }
    }

    public async Task<TagDto> CreateTagAsync(CreateTagDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PostAsJsonAsync("/api/tags", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<TagDto>(_jsonOptions))!;
    }

    public async Task<TagDto> UpdateTagAsync(Guid id, UpdateTagDto dto)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.PutAsJsonAsync($"/api/tags/{id}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
        return (await response.Content.ReadFromJsonAsync<TagDto>(_jsonOptions))!;
    }

    public async Task DeleteTagAsync(Guid id)
    {
        await AddAuthHeaderAsync();
        var response = await _httpClient.DeleteAsync($"/api/tags/{id}");
        response.EnsureSuccessStatusCode();
    }

    public async Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId)
    {
        await AddAuthHeaderAsync();
        return (await _httpClient.GetFromJsonAsync<List<TagReferenceDto>>($"/api/tags/recipe/{recipeId}", _jsonOptions))
            ?? new List<TagReferenceDto>();
    }

    public async Task SetRecipeTagsAsync(Guid recipeId, List<Guid> tagIds)
    {
        await AddAuthHeaderAsync();
        var dto = new UpdateRecipeTagsDto { TagIds = tagIds };
        var response = await _httpClient.PutAsJsonAsync($"/api/tags/recipe/{recipeId}", dto, _jsonOptions);
        response.EnsureSuccessStatusCode();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\ApiClient\ApiClient.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\ApiClient\IApiClient.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.ApiClient;

public interface IApiClient
{
    // User
    Task<UserDto?> GetMyProfileAsync();
    Task<UserDto> UpdateMyProfileAsync(UpdateUserDto dto);

    // Households
    Task<List<HouseholdDto>> GetMyHouseholdsAsync();
    Task<HouseholdDto?> GetHouseholdAsync(Guid id);
    Task<HouseholdDto> CreateHouseholdAsync(CreateHouseholdDto dto);
    Task<HouseholdDto> UpdateHouseholdSettingsAsync(Guid id, UpdateHouseholdSettingsDto dto);
    Task<HouseholdDto> UpdateHouseholdNameAsync(Guid id, UpdateHouseholdDto dto);
    Task<HouseholdDto> RegenerateHouseholdShareIdAsync(Guid id);
    Task SwitchHouseholdAsync(Guid householdId);
    Task<List<HouseholdInviteDto>> GetPendingInvitesAsync();
    Task AcceptInviteAsync(Guid inviteId);
    Task RejectInviteAsync(Guid inviteId);
    Task InviteToHouseholdAsync(Guid householdId, InviteToHouseholdDto dto);
    Task LeaveHouseholdAsync(Guid householdId);
    Task<List<HouseholdSearchResultDto>> SearchHouseholdsAsync(string query);
    Task<List<HouseholdFriendshipDto>> GetHouseholdFriendshipsAsync();
    Task<HouseholdFriendshipDto> SendHouseholdFriendRequestAsync(SendHouseholdFriendRequestDto dto);
    Task<HouseholdFriendshipDto> RespondHouseholdFriendRequestAsync(Guid requestId, RespondFriendRequestDto dto);
    Task<PublicRecipeDto?> GetPublicRecipeAsync(Guid id);

    // Household Recipes
    Task<List<HouseholdRecipeDto>> GetRecipesAsync(bool includeArchived = false);
    Task<HouseholdRecipeDto?> GetRecipeAsync(Guid id);
    Task<HouseholdRecipeDto> CreateRecipeAsync(CreateHouseholdRecipeDto dto);
    Task<HouseholdRecipeDto> UpdateRecipeAsync(Guid id, UpdateHouseholdRecipeDto dto);
    Task ArchiveRecipeAsync(Guid id);
    Task RestoreRecipeAsync(Guid id);
    Task RateRecipeAsync(Guid id, int rating);
    Task ForkRecipeAsync(Guid id);
    Task DeleteRecipeAsync(Guid id);

    // Global Recipes
    Task<GlobalRecipePagedResult> BrowseGlobalRecipesAsync(BrowseGlobalRecipesQuery query);
    Task<GlobalRecipeDto?> GetGlobalRecipeAsync(Guid id);
    Task<List<GlobalRecipeDto>> SearchGlobalRecipesAsync(string query, int limit = 20);
    Task DeleteGlobalRecipeAsync(Guid id);

    // Public Household Recipes (community recipes)
    Task<PublicRecipePagedResult> BrowsePublicRecipesAsync(BrowsePublicRecipesQuery query);

    // Storage
    Task<UploadImageResultDto> UploadImageAsync(byte[] imageData, string fileName);
    Task DeleteImageAsync(string fileName);

    // User Recipes (user-centric recipe management)
    Task<UserRecipePagedResult> GetMyUserRecipesAsync(GetUserRecipesQuery query);
    Task<UserRecipeDto?> GetUserRecipeAsync(Guid id);
    Task<UserRecipeDto> CreateUserRecipeAsync(CreateUserRecipeDto dto);
    Task<UserRecipeDto> UpdateUserRecipeAsync(Guid id, UpdateUserRecipeDto dto);
    Task DeleteUserRecipeAsync(Guid id);
    Task<PublishRecipeResultDto> PublishUserRecipeAsync(Guid id);
    Task<UserRecipeDto> DetachUserRecipeAsync(Guid id);
    Task<UserRecipeDto> RateUserRecipeAsync(Guid id, int rating, string? comment = null);
    Task RemoveUserRecipeRatingAsync(Guid id);
    Task<UserRecipeDto> ArchiveUserRecipeAsync(Guid id);
    Task<UserRecipeDto> RestoreUserRecipeAsync(Guid id);
    Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery query);

    // User Friendships
    Task<FriendshipListDto> GetFriendshipsAsync();
    Task<List<FriendProfileDto>> GetFriendsAsync();
    Task<UserFriendshipDto?> GetFriendshipAsync(Guid id);
    Task<UserFriendshipDto> SendFriendRequestAsync(SendFriendRequestDto dto);
    Task<UserFriendshipDto> RespondToFriendRequestAsync(Guid id, RespondFriendRequestDto action);
    Task RemoveFriendshipAsync(Guid id);
    Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20);
    Task<FriendProfileDto?> GetUserProfileAsync(Guid userId);

    // Activity Feed
    Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery query);
    Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20);
    Task<ActivitySummaryDto> GetActivitySummaryAsync();

    // Household Recipe Aggregation (single group - backwards compatible)
    Task<AggregatedRecipePagedResult> GetHouseholdCombinedRecipesAsync(Guid householdId, GetCombinedRecipesQuery query);
    Task<List<CommonFavoriteDto>> GetHouseholdCommonFavoritesAsync(Guid householdId, int minimumMembers = 2, int limit = 10);

    // Multi-group Recipe Aggregation
    Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(GetMultiGroupRecipesQuery query);
    Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(GetMultiGroupFavoritesQuery query);

    // Tags (personal recipe organization)
    Task<List<TagDto>> GetMyTagsAsync();
    Task<TagDto?> GetTagAsync(Guid id);
    Task<TagDto> CreateTagAsync(CreateTagDto dto);
    Task<TagDto> UpdateTagAsync(Guid id, UpdateTagDto dto);
    Task DeleteTagAsync(Guid id);
    Task<List<TagReferenceDto>> GetRecipeTagsAsync(Guid recipeId);
    Task SetRecipeTagsAsync(Guid recipeId, List<Guid> tagIds);

    // Ratings
    Task<List<UserRatingDto>> GetUserRatingsAsync(Guid userId, int skip = 0, int take = 50);
}



================================================================================
FILE END: \StorhaugenWebsite\ApiClient\IApiClient.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\ActivityFeed.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IActivityFeedService FeedService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<div class="activity-feed">
    @if (_isLoading)
    {
        <div class="d-flex flex-column gap-3">
            @for (int i = 0; i < 5; i++)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="80px" Class="rounded-xl" />
            }
        </div>
    }
    else if (!_feedItems.Any())
    {
        <div class="empty-state">
            <MudIcon Icon="@Icons.Material.Rounded.RssFeed" Size="Size.Large" Color="Color.Default" />
            <MudText Typo="Typo.h6" Class="mt-2">Ingen aktivitet ennå</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Legg til venner for å se hva de lager!
            </MudText>
            <MudButton Variant="Variant.Outlined" Color="Color.Primary" Href="/friends" Class="mt-3">
                Finn venner
            </MudButton>
        </div>
    }
    else
    {
        <div class="d-flex flex-column gap-3">
            @foreach (var item in _feedItems)
            {
                <MudPaper Class="activity-card" Elevation="0" @onclick="() => NavigateToRecipe(item)">

                    @* --- 1. Background Image Layer (Absolute) --- *@
                    @if (!string.IsNullOrEmpty(item.RecipeImageUrl))
                    {
                        <div class="activity-image-layer">
                            <img src="@item.RecipeImageUrl" alt="@item.RecipeName" loading="lazy" />
                        </div>
                    }

                    @* --- 2. Content Layer (Relative) --- *@
                    <div class="activity-content-layer">
                        <div class="d-flex gap-3 align-start">
                            @* Avatar (Left) *@
                            <MudAvatar Color="@GetActivityColor(item.ActivityType)" Size="Size.Medium" Variant="Variant.Filled" Class="flex-shrink-0">
                                @(item.UserDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>

                            @* Text (Fills remaining space) *@
                            <div class="activity-text-container">
                                <div class="d-flex align-center gap-2 flex-wrap mb-0">
                                    <MudText Typo="Typo.body2" Class="font-weight-bold user-name-text">
                                        @item.UserDisplayName
                                    </MudText>
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="time-text">
                                        @GetTimeAgo(item.CreatedAt)
                                    </MudText>
                                </div>

                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="action-text mb-1 d-block">
                                    @GetActivityDescription(item)
                                </MudText>

                            </div>
                        </div>
                                @if (!string.IsNullOrEmpty(item.RecipeName))
                                {
                                    <div class="recipe-row">
                                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" Class="recipe-icon" />
                                        <span class="recipe-name text-truncate">@item.RecipeName</span>
                                        @if (item.RatingScore.HasValue)
                                        {
                                            <span class="rating-dot" style="background-color: @GetRatingColorHex(item.RatingScore.Value)"></span>
                                            <span class="rating-val">@item.RatingScore.Value</span>
                                        }
                                    </div>
                                }
                    </div>
                </MudPaper>
            }
        </div>

        @if (_hasMorePages)
        {
            <div class="d-flex justify-center mt-4">
                <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="LoadMore" Disabled="_isLoadingMore">
                    @if (_isLoadingMore)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    }
                    Last inn mer
                </MudButton>
            </div>
        }
    }
</div>

<style>
    .activity-card {
        position: relative;
        background: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-divider);
        border-radius: 20px;
        overflow: hidden; /* Clips the image */
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        min-height: 84px;
    }

        .activity-card:active {
            transform: scale(0.98);
            background: var(--mud-palette-background-grey);
        }

    /* --- Image Layer ---
           Positioned absolutely to the right, sitting behind content */
    .activity-image-layer {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 55%; /* Covers ~half the card */
        z-index: 1;
        pointer-events: none;
        /* The Mask: Fades from Opaque (Right) to Transparent (Left) */
        -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0) 100%);
        mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0) 100%);
    }

        .activity-image-layer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

    /* --- Content Layer ---
           Sits on top of image, background transparent */
    .activity-content-layer {
        position: relative;
        z-index: 2;
        padding: 14px 16px;
    }

    .activity-text-container {
        flex: 1;
        min-width: 0; /* Enables text-truncate inside flex */
        padding-right: 20px; /* Space so text doesn't hit right edge hard */
        text-shadow: 0 1px 4px rgba(var(--mud-palette-surface-rgb), 0.8); /* Optional: makes text readable over image */
    }

    .user-name-text {
        font-size: 0.95rem;
        line-height: 1.2;
    }

    .time-text {
        font-size: 0.75rem;
        opacity: 0.8;
    }

    .action-text {
        font-size: 0.8rem;
        line-height: 1.2;
    }

    .recipe-row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
        color: var(--mud-palette-text-primary);
    }

    .recipe-icon {
        font-size: 14px;
        opacity: 0.7;
        flex-shrink: 0;
    }

    .recipe-name {
        font-weight: 600;
        font-size: 0.9rem;
    }

    .text-truncate {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .rating-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        margin-left: 2px;
        flex-shrink: 0;
    }

    .rating-val {
        font-weight: 700;
        font-size: 0.8rem;
        flex-shrink: 0;
    }
</style>

@code {
    [Parameter]
    public bool ShowOnlyMyActivity { get; set; } = false;

    [Parameter]
    public int PageSize { get; set; } = 20;

    private List<ActivityFeedItemDto> _feedItems = new();
    private bool _isLoading = true;
    private bool _isLoadingMore = false;
    private bool _hasMorePages = false;
    private int _currentPage = 1;

    protected override async Task OnInitializedAsync()
    {
        await LoadFeed();
    }

    private async Task LoadFeed()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            ActivityFeedPagedResult result;
            if (ShowOnlyMyActivity)
            {
                result = await FeedService.GetMyActivityAsync(_currentPage, PageSize);
            }
            else
            {
                result = await FeedService.GetFeedAsync(new ActivityFeedQuery
                {
                    Page = _currentPage,
                    PageSize = PageSize
                });
            }

            _feedItems = result.Items;
            _hasMorePages = result.HasMore;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste aktivitetsfeed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadMore()
    {
        _isLoadingMore = true;
        _currentPage++;
        StateHasChanged();

        try
        {
            ActivityFeedPagedResult result;
            if (ShowOnlyMyActivity)
            {
                result = await FeedService.GetMyActivityAsync(_currentPage, PageSize);
            }
            else
            {
                result = await FeedService.GetFeedAsync(new ActivityFeedQuery
                {
                    Page = _currentPage,
                    PageSize = PageSize
                });
            }

            _feedItems.AddRange(result.Items);
            _hasMorePages = result.HasMore;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste mer: {ex.Message}", Severity.Error);
            _currentPage--;
        }
        finally
        {
            _isLoadingMore = false;
            StateHasChanged();
        }
    }

    private void NavigateToRecipe(ActivityFeedItemDto item)
    {
        Navigation.NavigateTo($"food/{item.TargetId}");
    }

    private Color GetActivityColor(string activityType)
    {
        return activityType switch
        {
            "rated" => Color.Warning,
            "added" => Color.Success,
            "published" => Color.Info,
            "joined_household" => Color.Primary,
            _ => Color.Default
        };
    }

    private string GetRatingColorHex(int rating)
    {
        return rating switch
        {
            >= 8 => "#2D5A45", // Green
            >= 5 => "#D4A017", // Yellow
            _ => "#C44536"     // Red
        };
    }

    private string GetActivityDescription(ActivityFeedItemDto item)
    {
        return item.ActivityType switch
        {
            "rated" => "ga en vurdering",
            "added" => "la til en ny oppskrift",
            "published" => "publiserte en oppskrift",
            "joined_household" => "ble med i en husstand",
            "friend_added" => $"ble venn med {item.UserDisplayName}",
            _ => item.ActivityType
        };
    }

    private string GetTimeAgo(DateTime dateTime)
    {
        var diff = DateTime.UtcNow - dateTime;

        if (diff.TotalMinutes < 1) return "akkurat nå";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}t";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d";
        return dateTime.ToString("dd.MM");
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Components\ActivityFeed.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\HouseholdMembersDialog.razor
================================================================================
@*
    LEGACY: Dialog for viewing household members.
    Still needed while households exist, but new features should use user-level views.
*@
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs

@inject IApiClient ApiClient
@inject IAuthService AuthService
@inject IHouseholdStateService HouseholdState
@inject ISnackbar Snackbar
@inject NavigationManager Navigation

<MudDialog>
    <DialogContent>
        <div class="members-dialog">
            <div class="dialog-header">
                <MudText Typo="Typo.h6">@Household?.Name</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @Household?.Members.Count member@(Household?.Members.Count != 1 ? "s" : "")
                </MudText>
            </div>

            @if (Household?.Members.Any() == true)
            {
                <div class="members-list">
                    @foreach (var member in Household.Members.OrderBy(m => m.UserId != Household.CreatedById).ThenBy(m => m.JoinedAt))
                    {
                        var isCreator = member.UserId == Household.CreatedById;

                        <div class="member-card">
                            <div class="member-avatar" style="background: @GetMemberColor(member.DisplayName)">
                                @if (!string.IsNullOrEmpty(member.AvatarUrl))
                                {
                                    <img src="@member.AvatarUrl" alt="@member.DisplayName" />
                                }
                                else
                                {
                                    <span>@member.DisplayName.FirstOrDefault()</span>
                                }
                            </div>

                            <div class="member-info">
                                <div class="d-flex align-center gap-2">
                                    <MudText Typo="Typo.subtitle1" Style="font-weight: 600;">
                                        @member.DisplayName
                                    </MudText>
                                    @if (isCreator)
                                    {
                                        <MudChip Size="Size.Small" T=string Color="Color.Primary" Style="height: 20px;">Owner</MudChip>
                                    }
                                </div>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    Joined @member.JoinedAt.ToString("MMM dd, yyyy")
                                </MudText>
                            </div>
                        </div>
                    }
                </div>
            }

            @if (CanLeaveHousehold())
            {
                <div class="leave-section">
                    <MudDivider Class="my-3" />
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Error"
                               OnClick="LeaveHousehold"
                               Disabled="_isLeaving"
                               FullWidth="true"
                               Style="border-style: dashed;">
                        @if (_isLeaving)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Leaving...</span>
                        }
                        else
                        {
                            <MudIcon Icon="@Icons.Material.Rounded.ExitToApp" Class="mr-2" Size="Size.Small" />
                            <span>Leave Household</span>
                        }
                    </MudButton>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-2" Style="text-align: center;">
                        You'll lose access to all household recipes
                    </MudText>
                </div>
            }
        </div>
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Close" Color="Color.Primary">Close</MudButton>
    </DialogActions>
</MudDialog>

<style>
    .members-dialog {
        padding: 8px 0;
    }

    .dialog-header {
        margin-bottom: 20px;
    }

    .members-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: 400px;
        overflow-y: auto;
        padding: 4px;
    }

    .member-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        border-radius: 12px;
        background: var(--mud-palette-background-grey);
        transition: all 0.2s ease;
    }

        .member-card:hover {
            background: var(--mud-palette-action-default-hover);
        }

    .member-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.25rem;
        font-weight: 600;
        color: white;
        flex-shrink: 0;
        overflow: hidden;
    }

        .member-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .member-avatar span {
            text-transform: uppercase;
        }

    .member-info {
        flex: 1;
        min-width: 0;
    }

    .leave-section {
        margin-top: 16px;
    }
</style>

@code {
    [CascadingParameter]
    IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public HouseholdDto? Household { get; set; }

    private bool _isLeaving = false;

    private bool CanLeaveHousehold()
    {
        if (Household == null) return false;

        return true;
    }

    private async Task LeaveHousehold()
    {
        if (Household == null)
            return;

        Snackbar.Add($"Are you sure you want to leave {Household.Name}?",
            Severity.Warning,
            config =>
            {
                config.RequireInteraction = true;
                config.ShowCloseIcon = true;
                config.VisibleStateDuration = 10000;
            });

        // MudBlazor's Snackbar doesn't have confirmation dialogs built-in,
        // so we'll just proceed. In a production app, use MudDialog for confirmation.
        // For now, let's just proceed with the leave action.

        _isLeaving = true;
        StateHasChanged();

        try
        {
            await ApiClient.LeaveHouseholdAsync(Household.Id);

            Snackbar.Add($"Left {Household.Name} successfully", Severity.Success);

            // Refresh household state
            await HouseholdState.RefreshHouseholdsAsync();

            // Close dialog
            Close();

            // If no households left, might need to show household setup
            if (!HouseholdState.HasHousehold)
            {
                Navigation.NavigateTo("settings", forceLoad: true);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error leaving household: {ex.Message}");
            Snackbar.Add("Failed to leave household", Severity.Error);
        }
        finally
        {
            _isLeaving = false;
            StateHasChanged();
        }
    }

    private void Close()
    {
        MudDialog?.Close();
    }

    private string GetMemberColor(string displayName)
    {
        // Generate consistent color based on name hash
        var hash = displayName.GetHashCode();
        var colors = new[]
        {
            "#E07A2E", // Orange
            "#2D5A45", // Green
            "#4A7C9B", // Blue
            "#6B5D4D", // Brown
            "#9B4A7C", // Purple
            "#7C9B4A", // Lime
            "#4A5A9B", // Indigo
            "#9B6B4A"  // Rust
        };

        return colors[Math.Abs(hash) % colors.Length];
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\HouseholdMembersDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\HouseholdSelector.razor
================================================================================
@*
    LEGACY: Dialog for selecting/creating households.
    Still needed while households exist, but new user onboarding should consider
    users operating without a household (Personal Cookbook concept).
*@
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@inject IHouseholdStateService HouseholdState
@inject NavigationManager Navigation

<MudDialog>
    <DialogContent>
        <MudText Typo="Typo.h5" Class="mb-4">Welcome! Let's get started</MudText>

        @if (pendingInvites.Any())
        {
            <MudText Typo="Typo.h6" Class="mb-2">You have pending invitations</MudText>
            @foreach (var invite in pendingInvites)
            {
                <MudCard Class="mb-3">
                    <MudCardContent>
                        <MudText><strong>@invite.HouseholdName</strong></MudText>
                        <MudText Typo="Typo.body2">Invited by @invite.InvitedByName</MudText>
                    </MudCardContent>
                    <MudCardActions>
                        <MudButton Color="Color.Primary" Variant="Variant.Filled"
                                   OnClick="() => AcceptInvite(invite.Id)">
                            Accept
                        </MudButton>
                        <MudButton Color="Color.Default">Decline</MudButton>
                    </MudCardActions>
                </MudCard>
            }
            <MudDivider Class="my-4" />
        }

        <MudText Typo="Typo.h6" Class="mb-2">Create a new household</MudText>
        <MudTextField @bind-Value="newHouseholdName"
                      Label="Household Name"
                      Variant="Variant.Outlined"
                      Placeholder="e.g., Smith Family"
                      Class="mb-3" />

        <MudButton Color="Color.Primary"
                   Variant="Variant.Filled"
                   FullWidth="true"
                   OnClick="CreateHousehold"
                   Disabled="@(string.IsNullOrWhiteSpace(newHouseholdName) || isLoading)">
            @if (isLoading)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
            }
            else
            {
                <MudText>Create Household</MudText>
            }
        </MudButton>

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mt-3">@errorMessage</MudAlert>
        }
    </DialogContent>
</MudDialog>

@code {
    [CascadingParameter]
    IMudDialogInstance? MudDialog { get; set; }

    private string newHouseholdName = "";
    private List<HouseholdInviteDto> pendingInvites = new();
    private bool isLoading = false;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        await LoadPendingInvites();
    }

    private async Task LoadPendingInvites()
    {
        try
        {
            pendingInvites = await HouseholdState.GetPendingInvitesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading invites: {ex.Message}");
        }
    }

    private async Task CreateHousehold()
    {
        if (string.IsNullOrWhiteSpace(newHouseholdName))
            return;

        isLoading = true;
        errorMessage = null;

        try
        {
            await HouseholdState.CreateHouseholdAsync(newHouseholdName);
            MudDialog?.Close(DialogResult.Ok(true));
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to create household: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task AcceptInvite(Guid inviteId)
    {
        isLoading = true;
        errorMessage = null;

        try
        {
            await HouseholdState.AcceptInviteAsync(inviteId);
            MudDialog?.Close(DialogResult.Ok(true));
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to accept invitation: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\HouseholdSelector.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\InviteMemberDialog.razor
================================================================================
@*
    LEGACY: Dialog for inviting members to a household.
    Still needed while households exist for member management.
*@
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using System.ComponentModel.DataAnnotations
@inject IApiClient ApiClient
@inject ISnackbar Snackbar

<MudDialog>
    <DialogContent>
        <div class="invite-dialog">
            <MudText Typo="Typo.h6" Class="mb-2">Invite Member to @HouseholdName</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                Invite someone using their email address or unique Share ID.
            </MudText>

            <MudTabs Rounded="true" Centered="true" Class="mb-4" @bind-ActivePanelIndex="_activeTab">
                <MudTabPanel Text="Email" Icon="@Icons.Material.Rounded.Email">
                    <MudForm @ref="_emailForm" @bind-IsValid="_emailIsValid" Class="mt-3">
                        <MudTextField @bind-Value="_email"
                                      Label="Email Address"
                                      Variant="Variant.Outlined"
                                      Required="true"
                                      RequiredError="Email is required"
                                      Validation="@(new EmailAddressAttribute() { ErrorMessage = "Please enter a valid email address" })"
                                      Adornment="Adornment.Start"
                                      AdornmentIcon="@Icons.Material.Rounded.Email"
                                      HelperText="e.g., friend@example.com"
                                      Immediate="true" />
                    </MudForm>
                </MudTabPanel>
                <MudTabPanel Text="Share ID" Icon="@Icons.Material.Rounded.Tag">
                    <MudForm @ref="_shareIdForm" @bind-IsValid="_shareIdIsValid" Class="mt-3">
                        <MudTextField @bind-Value="_shareId"
                                      Label="Share ID"
                                      Variant="Variant.Outlined"
                                      Required="true"
                                      RequiredError="Share ID is required"
                                      Adornment="Adornment.Start"
                                      AdornmentIcon="@Icons.Material.Rounded.Tag"
                                      HelperText="e.g., ABC123XYZ"
                                      Immediate="true"
                                      Style="text-transform: uppercase; font-family: monospace; letter-spacing: 1px;" />
                    </MudForm>
                </MudTabPanel>
            </MudTabs>

            @if (!string.IsNullOrEmpty(_errorMessage))
            {
                <MudAlert Severity="Severity.Error" Class="mt-3" Dense="true" ShowCloseIcon="true" CloseIconClicked="@(() => _errorMessage = null)">
                    @_errorMessage
                </MudAlert>
            }

            @if (!string.IsNullOrEmpty(_successMessage))
            {
                <MudAlert Severity="Severity.Success" Class="mt-3" Dense="true">
                    @_successMessage
                </MudAlert>
            }

            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-3">
                <strong>Note:</strong> The invitee must have an account to accept the invitation. They can find their Share ID in Settings.
            </MudText>
        </div>
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel" Disabled="_isSending">Cancel</MudButton>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="SendInvite"
                   Disabled="_isSending || !IsCurrentFormValid()">
            @if (_isSending)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>Sending...</span>
            }
            else
            {
                <MudIcon Icon="@Icons.Material.Rounded.Send" Class="mr-2" Size="Size.Small" />
                <span>Send Invite</span>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

<style>
    .invite-dialog {
        padding: 8px 0;
    }
</style>

@code {
    [CascadingParameter]
    IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public Guid HouseholdId { get; set; }

    [Parameter]
    public string HouseholdName { get; set; } = "";

    private MudForm? _emailForm;
    private MudForm? _shareIdForm;
    private bool _emailIsValid = false;
    private bool _shareIdIsValid = false;
    private bool _isSending = false;
    private int _activeTab = 0;
    private string _email = "";
    private string _shareId = "";
    private string? _errorMessage;
    private string? _successMessage;

    private bool IsCurrentFormValid()
    {
        return _activeTab == 0 ? _emailIsValid : _shareIdIsValid;
    }

    private async Task SendInvite()
    {
        _errorMessage = null;
        _successMessage = null;

        // Validate the active form
        if (_activeTab == 0)
        {
            await _emailForm!.Validate();
            if (!_emailIsValid || string.IsNullOrWhiteSpace(_email))
            {
                _errorMessage = "Please enter a valid email address";
                return;
            }
        }
        else
        {
            await _shareIdForm!.Validate();
            if (!_shareIdIsValid || string.IsNullOrWhiteSpace(_shareId))
            {
                _errorMessage = "Please enter a Share ID";
                return;
            }
        }

        _isSending = true;
        StateHasChanged();

        try
        {
            var dto = new InviteToHouseholdDto
            {
                Email = _activeTab == 0 ? _email.Trim() : null,
                UniqueShareId = _activeTab == 1 ? _shareId.Trim().ToUpperInvariant() : null
            };
            await ApiClient.InviteToHouseholdAsync(HouseholdId, dto);

            var inviteTarget = _activeTab == 0 ? _email : $"user with ID {_shareId.ToUpperInvariant()}";
            _successMessage = $"Invitation sent to {inviteTarget}!";
            Snackbar.Add($"Invitation sent!", Severity.Success);

            // Clear the form for another invite
            _email = "";
            _shareId = "";
            _emailForm?.ResetAsync();
            _shareIdForm?.ResetAsync();

            // Close dialog after a short delay
            await Task.Delay(1500);
            MudDialog?.Close(DialogResult.Ok(true));
        }
        catch (HttpRequestException ex)
        {
            if (ex.StatusCode == System.Net.HttpStatusCode.BadRequest)
            {
                _errorMessage = "This user is already a member or has a pending invitation";
            }
            else if (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                _errorMessage = _activeTab == 1 ? "User with that Share ID not found" : "Household not found";
            }
            else
            {
                _errorMessage = $"Failed to send invitation: {ex.Message}";
            }
            Console.WriteLine($"Error sending invite: {ex}");
        }
        catch (Exception ex)
        {
            _errorMessage = $"An unexpected error occurred: {ex.Message}";
            Console.WriteLine($"Error sending invite: {ex}");
        }
        finally
        {
            _isSending = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog?.Close(DialogResult.Cancel());
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\InviteMemberDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\MyRecipes.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IUserRecipeService RecipeService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<div class="my-recipes">
    @* --- FILTER/SORT CONTROLS --- *@
    <div class="d-flex justify-space-between align-center mb-4">
        <MudMenu AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft">
            <ActivatorContent>
                <div class="sort-dropdown" style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 12px; background: var(--mud-palette-background-grey); border-radius: 8px;">
                    <MudIcon Icon="@Icons.Material.Rounded.FilterList" Size="Size.Small" />
                    <span>@GetVisibilityLabel()</span>
                </div>
            </ActivatorContent>
            <ChildContent>
                <MudMenuItem OnClick="@(() => SetVisibilityFilter(null))">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.AllInclusive" Size="Size.Small" />
                        <span>Alle</span>
                        @if (_visibilityFilter == null) { <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Color="Color.Primary" /> }
                    </div>
                </MudMenuItem>
                <MudMenuItem OnClick="@(() => SetVisibilityFilter("private"))">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Small" />
                        <span>Private</span>
                        @if (_visibilityFilter == "private") { <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Color="Color.Primary" /> }
                    </div>
                </MudMenuItem>
                <MudMenuItem OnClick="@(() => SetVisibilityFilter("household"))">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Home" Size="Size.Small" />
                        <span>Husstand</span>
                        @if (_visibilityFilter == "household") { <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Color="Color.Primary" /> }
                    </div>
                </MudMenuItem>
                <MudMenuItem OnClick="@(() => SetVisibilityFilter("friends"))">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" />
                        <span>Venner</span>
                        @if (_visibilityFilter == "friends") { <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Color="Color.Primary" /> }
                    </div>
                </MudMenuItem>
                <MudMenuItem OnClick="@(() => SetVisibilityFilter("public"))">
                    <div class="d-flex align-center gap-2">
                        <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" />
                        <span>Offentlige</span>
                        @if (_visibilityFilter == "public") { <MudIcon Icon="@Icons.Material.Rounded.Check" Size="Size.Small" Color="Color.Primary" /> }
                    </div>
                </MudMenuItem>
            </ChildContent>
        </MudMenu>

        <MudTextField @bind-Value="_searchQuery"
                     Placeholder="Søk..."
                     Variant="Variant.Outlined"
                     Adornment="Adornment.Start"
                     AdornmentIcon="@Icons.Material.Rounded.Search"
                     Immediate="true"
                     DebounceInterval="300"
                     OnDebounceIntervalElapsed="OnSearchChanged"
                     Style="max-width: 200px; --mud-default-borderradius: 8px;"
                     Margin="Margin.Dense" />
    </div>

    @* --- RECIPES LIST --- *@
    @if (_isLoading)
    {
        <div class="d-flex flex-column gap-3">
            @for (int i = 0; i < 5; i++)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100px" />
            }
        </div>
    }
    else if (!_recipes.Any())
    {
        <div class="empty-state text-center pa-6">
            <MudIcon Icon="@Icons.Material.Rounded.MenuBook" Size="Size.Large" Color="Color.Default" />
            <MudText Typo="Typo.h6" Class="mt-3">Ingen oppskrifter ennå</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                Start din personlige kokebok ved å legge til oppskrifter!
            </MudText>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="/add" StartIcon="@Icons.Material.Rounded.Add">
                Legg til oppskrift
            </MudButton>
        </div>
    }
    else
    {
        <div class="d-flex flex-column gap-3">
            @foreach (var recipe in _recipes)
            {
                <MudPaper Class="pa-3 recipe-card" Elevation="1" @onclick="() => NavigateToRecipe(recipe)">
                    <div class="d-flex gap-3">
                        @if (recipe.ImageUrls.Any())
                        {
                            <MudImage Src="@recipe.ImageUrls.First()"
                                     Alt="@recipe.Name"
                                     Width="80"
                                     Height="80"
                                     ObjectFit="ObjectFit.Cover"
                                     Class="rounded" />
                        }
                        else
                        {
                            <div class="recipe-placeholder rounded" style="width: 80px; height: 80px; background: var(--mud-palette-background-grey); display: flex; align-items: center; justify-content: center;">
                                <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Color="Color.Default" />
                            </div>
                        }
                        <div class="flex-grow-1">
                            <div class="d-flex align-center gap-2">
                                <MudText Typo="Typo.subtitle1" Class="font-weight-medium">@recipe.Name</MudText>
                                @if (recipe.IsLinkedToGlobal)
                                {
                                    <MudIcon Icon="@Icons.Material.Rounded.Link" Size="Size.Small" Color="Color.Info" />
                                }
                            </div>
                            <div class="d-flex align-center gap-2 mt-1">
                                <MudIcon Icon="@GetVisibilityIcon(recipe.Visibility)" Size="Size.Small" Color="Color.Default" />
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @GetVisibilityText(recipe.Visibility)
                                </MudText>
                            </div>
                            @if (recipe.MyRating.HasValue)
                            {
                                <div class="d-flex align-center gap-1 mt-1">
                                    <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" Color="Color.Warning" />
                                    <MudText Typo="Typo.caption">@recipe.MyRating.Value/10</MudText>
                                </div>
                            }
                        </div>
                        <div class="d-flex flex-column align-end justify-space-between">
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @recipe.CreatedAt.ToString("dd. MMM")
                            </MudText>
                            @if (!recipe.IsPublished && !recipe.IsLinkedToGlobal)
                            {
                                <MudIconButton Icon="@Icons.Material.Rounded.Publish"
                                              Size="Size.Small"
                                              Color="Color.Primary"
                                              OnClick="@((e) => { PublishRecipe(recipe); })" />
                            }
                        </div>
                    </div>
                </MudPaper>
            }
        </div>

        @if (_hasMorePages)
        {
            <div class="d-flex justify-center mt-4">
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="LoadMore" Disabled="_isLoadingMore">
                    @if (_isLoadingMore)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    }
                    Last inn mer
                </MudButton>
            </div>
        }
    }
</div>

<style>
    .recipe-card {
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .recipe-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
    }
</style>

@code {
    private List<UserRecipeDto> _recipes = new();
    private bool _isLoading = true;
    private bool _isLoadingMore = false;
    private bool _hasMorePages = false;
    private int _currentPage = 1;
    private string? _visibilityFilter = null;
    private string? _searchQuery = null;


    protected override async Task OnInitializedAsync()
    {
        await LoadRecipes();
    }

    private async Task LoadRecipes()
    {
        _isLoading = true;
        _currentPage = 1;
        StateHasChanged();

        try
        {
            var query = new GetUserRecipesQuery
            {
                Page = _currentPage,
                PageSize = 20,
                Visibility = _visibilityFilter,
            };
            var result = await RecipeService.GetMyRecipesAsync(query);
            _recipes = result.Recipes;
            _hasMorePages = result.Page < result.TotalPages;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste oppskrifter: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadMore()
    {
        _isLoadingMore = true;
        _currentPage++;
        StateHasChanged();

        try
        {
            var query = new GetUserRecipesQuery
            {
                Page = _currentPage,
                PageSize = 20,
                Visibility = _visibilityFilter,
            };
            var result = await RecipeService.GetMyRecipesAsync(query);
            _recipes.AddRange(result.Recipes);
            _hasMorePages = result.Page < result.TotalPages;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste mer: {ex.Message}", Severity.Error);
            _currentPage--;
        }
        finally
        {
            _isLoadingMore = false;
            StateHasChanged();
        }
    }

    private async Task SetVisibilityFilter(string? visibility)
    {
        _visibilityFilter = visibility;
        await LoadRecipes();
    }

    private async Task OnSearchChanged(string value)
    {
        await LoadRecipes();
    }

    private void NavigateToRecipe(UserRecipeDto recipe)
    {
        Navigation.NavigateTo($"/food/{recipe.Id}");
    }

    private async Task PublishRecipe(UserRecipeDto recipe)
    {
        var parameters = new DialogParameters<PublishRecipeDialog> { { x => x.Recipe, recipe } };
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<PublishRecipeDialog>("Publiser", parameters, options);
        var result = await dialog.Result;
        if (result != null && !result.Canceled)
        {
            await LoadRecipes();
        }
    }

    private string GetVisibilityLabel()
    {
        return _visibilityFilter switch
        {
            "private" => "Private",
            "household" => "Husstand",
            "friends" => "Venner",
            "public" => "Offentlige",
            _ => "Alle"
        };
    }

    private string GetVisibilityIcon(string visibility)
    {
        return visibility switch
        {
            "private" => Icons.Material.Rounded.Lock,
            "household" => Icons.Material.Rounded.Home,
            "friends" => Icons.Material.Rounded.People,
            "public" => Icons.Material.Rounded.Public,
            _ => Icons.Material.Rounded.Lock
        };
    }

    private string GetVisibilityText(string visibility)
    {
        return visibility switch
        {
            "private" => "Privat",
            "household" => "Husstand",
            "friends" => "Venner",
            "public" => "Offentlig",
            _ => "Privat"
        };
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\MyRecipes.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\NotificationBell.razor
================================================================================
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@inject IApiClient ApiClient
@inject IHouseholdStateService HouseholdState
@inject ISnackbar Snackbar
@implements IDisposable

<MudBadge Content="@_pendingInvites.Count"
          Color="Color.Error"
          Overlap="true"
          Visible="@(_pendingInvites.Count > 0)"
          Class="notification-badge">

    <MudMenu Icon="@Icons.Material.Rounded.Notifications"
             Color="Color.Inherit"
             Size="Size.Medium"
             AnchorOrigin="Origin.BottomRight"
             TransformOrigin="Origin.TopRight"
             Dense="true"
             PopoverClass="notification-popover">

        <ChildContent>
            @if (_isLoading)
            {
                <div class="d-flex align-center gap-2 pa-4">
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <MudText Typo="Typo.body2">Loading...</MudText>
                </div>
            }
            else if (_pendingInvites.Count == 0)
            {
                <div class="d-flex flex-column align-center pa-4" style="min-width: 250px;">
                    <MudIcon Icon="@Icons.Material.Rounded.NotificationsNone"
                             Color="Color.Secondary"
                             Size="Size.Large" />
                    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2">
                        No pending invitations
                    </MudText>
                </div>
            }
            else
            {
                <div style="max-height: 400px; overflow-y: auto; min-width: 320px;">
                    @foreach (var invite in _pendingInvites)
                    {
                        <div class="invite-row">
                            <div class="invite-info">
                                <MudText Typo="Typo.subtitle2" Style="font-weight: 600;">
                                    @invite.HouseholdName
                                </MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="d-block">
                                    Invited by @invite.InvitedByName
                                </MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @GetTimeAgo(invite.CreatedAt)
                                </MudText>
                            </div>

                            <div class="invite-actions">
                                <MudIconButton Icon="@Icons.Material.Rounded.Check"
                                               Color="Color.Success"
                                               Size="Size.Small"
                                               Variant="Variant.Filled"
                                               OnClick="@((e) => AcceptInvite(invite))"
                                               Disabled="@(_processingInviteId == invite.Id)"
                                               Title="Accept" />

                                <MudIconButton Icon="@Icons.Material.Rounded.Close"
                                               Color="Color.Error"
                                               Size="Size.Small"
                                               Variant="Variant.Outlined"
                                               OnClick="@((e) => RejectInvite(invite))"
                                               Disabled="@(_processingInviteId == invite.Id)"
                                               Title="Decline" />
                            </div>
                        </div>
                    }
                </div>
            }
        </ChildContent>
    </MudMenu>
</MudBadge>

<style>
    .notification-badge .mud-badge-content {
        font-size: 10px;
        min-width: 16px;
        height: 16px;
        padding: 0 4px;
    }

    /* Styles to replicate MudMenuItem look but keep it interactive */
    .invite-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 16px;
        transition: background-color 0.2s;
        cursor: default;
    }

        .invite-row:hover {
            background-color: var(--mud-palette-action-hover);
        }

    .invite-info {
        flex: 1;
        min-width: 0;
    }

    .invite-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
    }
</style>

@code {
    // Keep your existing C# code as-is
    private List<HouseholdInviteDto> _pendingInvites = new();
    private bool _isLoading = true;
    private Guid? _processingInviteId;
    private System.Threading.Timer? _refreshTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadPendingInvites();

        _refreshTimer = new System.Threading.Timer(
            async _ => await InvokeAsync(async () =>
            {
                await LoadPendingInvites();
                StateHasChanged();
            }),
            null,
            TimeSpan.FromSeconds(30),
            TimeSpan.FromSeconds(30)
        );
    }

    private async Task LoadPendingInvites()
    {
        try
        {
            _pendingInvites = await ApiClient.GetPendingInvitesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading pending invites: {ex.Message}");
            _pendingInvites = new();
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task AcceptInvite(HouseholdInviteDto invite)
    {
        _processingInviteId = invite.Id;
        StateHasChanged();

        try
        {
            await ApiClient.AcceptInviteAsync(invite.Id);
            _pendingInvites.Remove(invite);
            Snackbar.Add($"Joined {invite.HouseholdName}!", Severity.Success);
            await HouseholdState.RefreshHouseholdsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error accepting invite: {ex.Message}");
            Snackbar.Add("Failed to accept invitation", Severity.Error);
        }
        finally
        {
            _processingInviteId = null;
            StateHasChanged();
        }
    }

    private async Task RejectInvite(HouseholdInviteDto invite)
    {
        _processingInviteId = invite.Id;
        StateHasChanged();

        try
        {
            await ApiClient.RejectInviteAsync(invite.Id);
            _pendingInvites.Remove(invite);
            Snackbar.Add("Invitation declined", Severity.Info);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error rejecting invite: {ex.Message}");
            Snackbar.Add("Failed to decline invitation", Severity.Error);
        }
        finally
        {
            _processingInviteId = null;
            StateHasChanged();
        }
    }

    private string GetTimeAgo(DateTime createdAt)
    {
        var diff = DateTime.UtcNow - createdAt;
        if (diff.TotalMinutes < 1) return "Just now";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d ago";
        return createdAt.ToString("MMM d");
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Components\NotificationBell.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\PublishRecipeDialog.razor
================================================================================
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IUserRecipeService RecipeService
@inject ISnackbar Snackbar

<MudDialog>
    <TitleContent>
        <div class="d-flex align-center gap-2">
            <MudIcon Icon="@Icons.Material.Rounded.Publish" Color="Color.Primary" />
            <MudText Typo="Typo.h6">Publiser oppskrift</MudText>
        </div>
    </TitleContent>
    <DialogContent>
        @if (_isPublishing)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                <MudText Typo="Typo.body1" Class="mt-4">Publiserer oppskrift...</MudText>
            </div>
        }
        else if (_publishResult != null)
        {
            <div class="d-flex flex-column align-center pa-4">
                <MudIcon Icon="@Icons.Material.Rounded.CheckCircle" Color="Color.Success" Size="Size.Large" />
                <MudText Typo="Typo.h6" Class="mt-3">Publisert!</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2 text-center">
                    @_publishResult.Message
                </MudText>
            </div>
        }
        else
        {
            <MudText Typo="Typo.body1" Class="mb-4">
                Ved å publisere denne oppskriften blir den tilgjengelig for alle brukere i den globale oppskriftsdatabasen.
            </MudText>

            <MudAlert Severity="Severity.Info" Dense="true" Class="mb-4">
                <MudText Typo="Typo.body2">
                    Din oppskrift vil fortsatt være lenket til den publiserte versjonen.
                    Du kan når som helst "koble fra" for å gjøre lokale endringer.
                </MudText>
            </MudAlert>

            @if (Recipe != null)
            {
                <MudPaper Class="pa-3" Elevation="1">
                    <div class="d-flex gap-3">
                        @if (Recipe.ImageUrls.Any())
                        {
                            <MudImage Src="@Recipe.ImageUrls.First()"
                                     Alt="@Recipe.Name"
                                     Width="80"
                                     Height="80"
                                     ObjectFit="ObjectFit.Cover"
                                     Class="rounded" />
                        }
                        <div>
                            <MudText Typo="Typo.subtitle1">@Recipe.Name</MudText>
                            @if (!string.IsNullOrEmpty(Recipe.Description))
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                                    @(Recipe.Description.Length > 100 ? Recipe.Description.Substring(0, 100) + "..." : Recipe.Description)
                                </MudText>
                            }
                        </div>
                    </div>
                </MudPaper>
            }
        }
    </DialogContent>
    <DialogActions>
        @if (_publishResult != null)
        {
            <MudButton OnClick="Close" Color="Color.Primary" Variant="Variant.Filled">
                Lukk
            </MudButton>
        }
        else if (!_isPublishing)
        {
            <MudButton OnClick="Cancel" Color="Color.Default">Avbryt</MudButton>
            <MudButton OnClick="Publish" Color="Color.Primary" Variant="Variant.Filled">
                Publiser
            </MudButton>
        }
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public UserRecipeDto? Recipe { get; set; }

    private bool _isPublishing = false;
    private PublishRecipeResultDto? _publishResult;

    private async Task Publish()
    {
        if (Recipe == null) return;

        _isPublishing = true;
        StateHasChanged();

        try
        {
            _publishResult = await RecipeService.PublishRecipeAsync(Recipe.Id);
            Snackbar.Add("Oppskriften ble publisert!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke publisere: {ex.Message}", Severity.Error);
            _isPublishing = false;
        }

        StateHasChanged();
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    private void Close()
    {
        MudDialog.Close(DialogResult.Ok(_publishResult));
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\PublishRecipeDialog.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
================================================================================
@using MudBlazor

<MudPaper Class="pa-3" Elevation="0" Style="background: var(--mud-palette-background-grey);">
    <MudText Typo="Typo.subtitle2" Class="mb-2">Synlighet</MudText>

    <MudRadioGroup @bind-Value="Visibility" T="string">
        <div class="d-flex flex-column gap-2">
            <MudPaper Class="@(Visibility == "private" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("private")"
                     @onclick="@(() => SetVisibility("private"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("private")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Privat</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Bare du kan se denne oppskriften</MudText>
                    </div>
                </div>
            </MudPaper>

            <MudPaper Class="@(Visibility == "household" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("household")"
                     @onclick="@(() => SetVisibility("household"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("household")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.Home" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Husstand</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Synlig for husstandsmedlemmer</MudText>
                    </div>
                </div>
            </MudPaper>

            <MudPaper Class="@(Visibility == "friends" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("friends")"
                     @onclick="@(() => SetVisibility("friends"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("friends")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.People" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Venner</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Synlig for vennene dine</MudText>
                    </div>
                </div>
            </MudPaper>

            <MudPaper Class="@(Visibility == "public" ? "mud-border-primary pa-2" : "pa-2")"
                     Elevation="0"
                     Style="@GetItemStyle("public")"
                     @onclick="@(() => SetVisibility("public"))">
                <div class="d-flex align-center gap-2">
                    <MudRadio Value="@("public")" Color="Color.Primary" Dense="true" />
                    <MudIcon Icon="@Icons.Material.Rounded.Public" Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body2">Offentlig</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Alle kan se denne oppskriften</MudText>
                    </div>
                </div>
            </MudPaper>
        </div>
    </MudRadioGroup>
</MudPaper>

@code {
    [Parameter]
    public string Visibility { get; set; } = "private";

    [Parameter]
    public EventCallback<string> VisibilityChanged { get; set; }

    private async Task SetVisibility(string value)
    {
        Visibility = value;
        await VisibilityChanged.InvokeAsync(value);
    }

    private string GetItemStyle(string value)
    {
        var baseStyle = "cursor: pointer; border: 1px solid transparent; border-radius: 8px;";
        if (Visibility == value)
        {
            return baseStyle + " border-color: var(--mud-palette-primary);";
        }
        return baseStyle;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Components\RecipeVisibilitySelector.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\AppConfig.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    // AppConfig is now simplified - no more email whitelist
    // Authorization is handled by the backend API based on household membership
    public static class AppConfig
    {
        // Keep this empty for now - configuration can be added later if needed
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Models\AppConfig.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\DeviceSettings.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class DeviceSettings
    {
        public string Theme { get; set; } = "Dark";
        public string ViewMode { get; set; } = "list";
        public string SortBy { get; set; } = "date";
        public bool SortDescending { get; set; } = true;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\DeviceSettings.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\FoodItem.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class FoodItem
    {
        public string Id { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;

        // --- ADD THIS LINE ---
        public bool IsHelloFresh { get; set; } = false;
        // ---------------------

        public string? Description { get; set; }
        public List<string> ImageUrls { get; set; } = new();
        public Dictionary<string, int?> Ratings { get; set; } = new();
        public DateTime DateAdded { get; set; } = DateTime.UtcNow;
        public string AddedBy { get; set; } = string.Empty;
        public bool IsArchived { get; set; } = false;
        public DateTime? ArchivedDate { get; set; }
        public string? ArchivedBy { get; set; }
         
        // Multi-tenant fields
        public Guid? GlobalRecipeId { get; set; }
        public string? GlobalRecipeName { get; set; }
        public bool IsForked { get; set; }
        public string? PersonalNotes { get; set; }

        // Public sharing
        public bool IsPublic { get; set; }
        public string? HouseholdName { get; set; }

        public double AverageRating
        {
            get
            {
                var validRatings = Ratings.Values.Where(r => r.HasValue).Select(r => r!.Value).ToList();
                return validRatings.Count > 0 ? validRatings.Average() : 0;
            }
        }

        public int GetRatingForPerson(string person)
        {
            return Ratings.TryGetValue(person, out var rating) ? rating ?? 0 : 0;
        }

        // Helper property to check if this recipe is linked to a global recipe
        public bool IsLinkedToGlobal => GlobalRecipeId.HasValue && !IsForked;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\FoodItem.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Models\ThemeColors.cs
================================================================================
namespace StorhaugenWebsite.Models
{
    public class ThemeColors
    {
        public string? Primary { get; set; }
        public string? Info { get; set; }
        public string? AppbarBackground { get; set; }
        public string? Surface { get; set; }
        public string? Background { get; set; }
        public string? BackgroundGrey { get; set; }
        public string? Divider { get; set; }
        public string? TextPrimary { get; set; }
        public string? TextSecondary { get; set; }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Models\ThemeColors.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\AddFood.razor
================================================================================
@page "/add"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Components
@inject IAuthService AuthService
@inject IFoodService FoodService
@inject IUserRecipeService RecipeService
@inject IHouseholdStateService HouseholdState
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IOcrService OcrService
@inject IJSRuntime JSRuntime
@attribute [Authorize]

@* --- 1. LANDSCAPE BLOCKER --- *@
<div id="landscape-blocker">
    <MudIcon Icon="@Icons.Material.Rounded.ScreenLockPortrait" Style="font-size: 64px; margin-bottom: 20px; color: #E07A2E;" />
    <h2 style="font-family: 'Fraunces', serif;">Vennligst snu telefonen</h2>
    <p style="opacity: 0.7; max-width: 300px; margin-top: 10px;">Storhaugen Eats er designet for å brukes i portrettmodus.</p>
</div>

@* --- 2. CAMERA OVERLAY UI --- *@
@if (_showCameraOverlay)
{
    <div class="camera-overlay">
        <video @ref="_videoElement" autoplay playsinline muted class="camera-video"></video>
        <div class="camera-guide-container @GetOverlayClass()">
            <div class="camera-guide-box">
                @if (_currentStep == ScanStep.Front)
                {
                    <div class="logo-hint-zone">
                        <svg width="60" height="80" viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" fill="#fff">
                            <path d="M50 0 C25 0 5 20 5 45 C5 70 25 90 50 90 C75 90 95 70 95 45 C95 35 90 15 80 5" fill="#9ACD32" />
                            <path d="M80 5 C85 0 95 0 95 10 C95 5 85 5 80 5 Z" fill="#76a11e" />
                            <text x="50" y="105" font-family="Arial, sans-serif" font-weight="900" font-size="14" text-anchor="middle" letter-spacing="1">HELLO</text>
                            <text x="50" y="118" font-family="Arial, sans-serif" font-weight="900" font-size="14" text-anchor="middle" letter-spacing="1">FRESH</text>
                        </svg>
                    </div>
                    <div class="text-hint-zone"><span class="text-label">TITTEL HER</span></div>
                }
                <div class="scan-line"></div>
            </div>
            <div class="camera-instruction-pill">
                <MudIcon Icon="@GetStepIcon()" Size="Size.Small" Class="mr-2" Style="color: #00E676;" />
                <span class="step-text">@GetStepTitle()</span>
            </div>
            <p class="camera-guide-text">@GetInstructionText()</p>
        </div>
        <div class="camera-controls">
            <MudIconButton Icon="@Icons.Material.Rounded.Close" Color="Color.Surface" Size="Size.Large" OnClick="StopCamera" />
            <button class="camera-shutter @(_isProcessingOcr ? "processing" : "")" disabled="@_isProcessingOcr" @onclick="CaptureCameraImage"></button>
            <div class="step-counter">@((int)_currentStep + 1) / 3</div>
        </div>
    </div>
}

<div class="app-content-container">
    <div class="d-flex justify-space-between align-center mb-4">
        <div>
            <h1 class="page-title" style="margin-bottom: 4px; font-size: 24px; font-weight: 700;">Legg til måltid</h1>
            <p class="page-subtitle" style="color: var(--mud-palette-text-secondary);">
                @(_fromDraft ? "Tilpass kopiert oppskrift" : "Gi kveldens middag en vurdering")
            </p>
        </div>
    </div>

    <MudPaper Class="pa-2 mb-6 d-flex justify-center gap-2" Elevation="0" Style="background: var(--mud-palette-background-grey); border-radius: 12px;">
        <MudButton Variant="@(_isHelloFresh? Variant.Filled: Variant.Text)" Color="Color.Success" OnClick="@(() => SetFoodType(true))" Class="flex-1" Style="border-radius: 10px;" StartIcon="@Icons.Custom.Brands.MudBlazor">HelloFresh</MudButton>
        <MudButton Variant="@(!_isHelloFresh ? Variant.Filled : Variant.Text)" Color="Color.Primary" OnClick="@(() => SetFoodType(false))" Class="flex-1" Style="border-radius: 10px;" StartIcon="@Icons.Material.Rounded.Restaurant">Annet</MudButton>
    </MudPaper>

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="mb-4" ShowCloseIcon="true" CloseIconClicked="@(() => _errorMessage = null)">@_errorMessage</MudAlert>
    }

    <div class="form-section">
        <div class="d-flex justify-space-between align-center">
            <p class="form-section-title">Måltidsdetaljer</p>
            @if (_isHelloFresh && _isProcessingOcr)
            {
                <MudChip Size="Size.Small" Color="Color.Success" T="string" Variant="Variant.Text" Icon="@Icons.Material.Rounded.AutoAwesome">Analyserer...</MudChip>
            }
        </div>

        <MudTextField @bind-Value="_newFood.Name"
                      Label="@(_isHelloFresh ? "Navn på rett" : "Hva spiste vi?")"
                      Variant="Variant.Outlined"
                      Placeholder="@(_isHelloFresh ? "Skann forside for å fylle ut..." : "f.eks. Bestemors lasagne")"
                      Required="true"
                      Class="mb-4"
                      Style="--mud-default-borderradius: 12px;" />

        <MudTextField @bind-Value="_newFood.Description"
                      Label="Beskrivelse / Ingredienser"
                      Variant="Variant.Outlined"
                      Lines="8"
                      Placeholder="Ingredienser blir lagt til her..."
                      Style="--mud-default-borderradius: 12px;" />
    </div>

    <div class="form-section">
        <p class="form-section-title">Bilder</p>

        @if (_imagePreviewUrls.Any())
        {
            <div class="image-preview-grid">
                @for (int i = 0; i < _imagePreviewUrls.Count; i++)
                {
                    var index = i;
                    <div class="image-preview-item">
                        <img src="@_imagePreviewUrls[index]" />
                        <button class="image-preview-remove" @onclick="@(() => RemoveImage(index))">
                            <MudIcon Icon="@Icons.Material.Rounded.Close" Size="Size.Small" />
                        </button>
                    </div>
                }
            </div>
        }

        <div class="d-flex gap-3 w-100">
            @if (_isHelloFresh)
            {
                <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Rounded.DocumentScanner" Size="Size.Large" OnClick="StartCamera" Class="flex-1" Style="border-radius: 12px; height: 56px;">Skann</MudButton>
            }
            else
            {
                <MudFileUpload T="IReadOnlyList<IBrowserFile>" @ref="@_fileUpload" FilesChanged="OnImagesSelected" Accept="image/*" MaximumFileCount="5" Class="flex-1" @attributes="@(new Dictionary<string, object> { { "capture", "environment" } })">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Rounded.CameraAlt" Size="Size.Large" FullWidth="true" Style="border-radius: 12px; height: 56px;">Ta bilde</MudButton>
                    </ActivatorContent>
                </MudFileUpload>
            }
            <input type="file" id="galleryInput" accept="image/*, .heic" multiple style="display: none;" @onchange="OnGalleryFileSelected" />
            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Rounded.PhotoLibrary" Size="Size.Large" OnClick="TriggerGalleryClick" Class="flex-1" Style="border-radius: 12px; height: 56px; border-style: dashed; border-width: 2px;">Galleri</MudButton>
        </div>
    </div>

    @* --- PRIVACY & GROUP SELECTION --- *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center">
            <p class="form-section-title mb-0">Deling</p>
            <MudSwitch T="bool"
                       Value="@_shareWithGroup"
                       ValueChanged="OnShareGroupToggled"
                       Color="Color.Primary"
                       Label="Legg til i gruppe" />
        </div>

        @if (_shareWithGroup)
        {
            <div class="mt-3 animate-in">
                @if (HouseholdState.UserHouseholds.Any())
                {
                    <MudSelect T="Guid?"
                               Label="Velg gruppe"
                               Value="@_selectedGroupId"
                               ValueChanged="OnGroupSelectionChanged"
                               Variant="Variant.Outlined"
                               AnchorOrigin="Origin.BottomCenter">
                        @foreach (var group in HouseholdState.UserHouseholds)
                        {
                            <MudSelectItem Value="@((Guid?)group.Id)">@group.Name</MudSelectItem>
                        }
                    </MudSelect>
                }
                else
                {
                    <MudAlert Severity="Severity.Warning" Dense="true" Class="mt-2">
                        Du er ikke medlem av noen grupper.
                        <MudLink Href="/households" Typo="Typo.body2">Opprett en gruppe her.</MudLink>
                    </MudAlert>
                }
            </div>
        }

        <div class="mt-4 d-flex justify-space-between align-center">
            <MudText Typo="Typo.body2">Gjør offentlig (Synlig for alle)</MudText>
            <MudSwitch @bind-Value="_isPublic" Color="Color.Tertiary" />
        </div>
        @if (_isPublic)
        {
            <MudText Typo="Typo.caption" Color="Color.Secondary">Oppskriften blir søkbar for hele fellesskapet.</MudText>
        }
    </div>

    @* --- RATINGS SECTION --- *@
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-4">
            <p class="form-section-title mb-0">Hvordan smakte det?</p>
            <MudSwitch T="bool" @bind-Value="_ratingEnabled" Color="Color.Primary" Label="Gi vurdering" />
        </div>

        @if (_ratingEnabled)
        {
            <div class="d-flex flex-column gap-3">
                @foreach (var member in _currentRatingMembers)
                {
                    var isMe = member.DisplayName == _currentUserName;
                    bool included = IsMemberIncluded(member.UserId);
                    int rating = GetMemberRating(member.UserId);

                    <div class="d-flex align-center gap-2 pa-2" style="background: var(--mud-palette-background); border-radius: 12px; transition: opacity 0.2s; opacity: @(included ? 1 : 0.6);">

                        @* Avatar *@
                        <MudAvatar Size="Size.Medium" Style="@($"background: {GetMemberColor(member.DisplayName)}")">
                            @(string.IsNullOrEmpty(member.DisplayName) ? '?' : member.DisplayName[0])
                        </MudAvatar>

                        @* Name & Slider *@
                        <div class="flex-grow-1 ml-2">
                            <div class="d-flex justify-space-between">
                                <MudText Typo="Typo.body2" Style="font-weight: 600;">@member.DisplayName</MudText>
                                @if (included)
                                {
                                    <span style="font-size: 0.8rem; font-weight: 700; color: @GetRatingTextColor(rating);">@rating/10</span>
                                }
                            </div>

                            <MudSlider T="int"
                                       Value="rating"
                                       ValueChanged="@((int v) => SetMemberRating(member.UserId, v))"
                                       Min="1" Max="10" Step="1"
                                       Color="Color.Primary"
                                       Disabled="@(!included)"
                                       Class="my-0" />
                        </div>

                        @* Toggle *@
                        <MudSwitch T="bool"
                                   Value="included"
                                   ValueChanged="@((bool v) => SetMemberIncluded(member.UserId, v))"
                                   Color="Color.Success"
                                   UnCheckedColor="Color.Default"
                                   Size="Size.Medium"
                                   Class="ml-1" />
                    </div>
                }
            </div>
        }
    </div>

    <div class="form-section" style="border:none; background:transparent; padding:0;">
        <MudButton Variant="Variant.Filled"
                   Color="@(_isHelloFresh ? Color.Success : Color.Primary)"
                   Size="Size.Large"
                   FullWidth="true"
                   OnClick="SubmitFood"
                   Disabled="_isSubmitting"
                   Style="border-radius: 14px; padding: 14px; height: 56px;">
            @if (_isSubmitting)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" Color="Color.Surface" />
                <span>Lagrer...</span>
            }
            else
            {
                <MudIcon Icon="@Icons.Material.Rounded.Check" Class="mr-2" />
                <span>Lagre måltid</span>
            }
        </MudButton>
    </div>
</div>

@code {
    #region State Variables
    private FoodItem _newFood = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private bool _isSubmitting = false;
    private bool _fromDraft = false;
    private string? _errorMessage;
    private List<string> _imagePreviewUrls = new();
    private List<byte[]> _imageData = new();
    private List<string> _imageNames = new();
    private List<string> _draftImageUrls = new();

    private bool _ratingEnabled = true;
    private string _currentUserName = "";
    private bool _isHelloFresh = true;

    // Group & Privacy State
    private bool _shareWithGroup = false;
    private bool _isPublic = false;
    private Guid? _selectedGroupId;

    // Member list for rating (Filtered based on selection)
    private List<HouseholdMemberDto> _currentRatingMembers = new();
    #endregion

    #region Camera & OCR State
    private ElementReference _videoElement;
    private bool _showCameraOverlay = false;
    private bool _isProcessingOcr = false;
    private enum ScanStep { Front, Ingredients, Back, Finished }
    private ScanStep _currentStep = ScanStep.Front;
    public class ProcessedImage { public string Name { get; set; } = ""; public string Data { get; set; } = ""; }
    #endregion

    #region Household & Ratings State
    private Dictionary<Guid, int> _memberRatings = new();
    private Dictionary<Guid, bool> _memberIncluded = new();
    #endregion

    protected override async Task OnInitializedAsync()
    {
        await HouseholdState.InitializeAsync();
        _currentUserName = AuthService.CurrentUserName ?? "Unknown";

        // Auto-select first group if available
        if (HouseholdState.UserHouseholds.Any())
        {
            _shareWithGroup = true;
            _selectedGroupId = HouseholdState.UserHouseholds.First().Id;
        }
        else
        {
            _shareWithGroup = false;
        }

        UpdateRatingMemberList();

        if (FoodService.DraftRecipe != null)
        {
            LoadDraft(FoodService.DraftRecipe);
        }
    }

    private void OnShareGroupToggled(bool toggled)
    {
        _shareWithGroup = toggled;

        if (_shareWithGroup && _selectedGroupId == null && HouseholdState.UserHouseholds.Any())
        {
            _selectedGroupId = HouseholdState.UserHouseholds.First().Id;
        }

        UpdateRatingMemberList();
    }

    private void OnGroupSelectionChanged(Guid? groupId)
    {
        _selectedGroupId = groupId;
        UpdateRatingMemberList();
    }

    private void UpdateRatingMemberList()
    {
        if (_shareWithGroup && _selectedGroupId.HasValue)
        {
            // Get members of the specific selected group [cite: 1664]
            var group = HouseholdState.UserHouseholds.FirstOrDefault(h => h.Id == _selectedGroupId.Value);
            _currentRatingMembers = group?.Members ?? new List<HouseholdMemberDto>();
        }
        else
        {
            // If private, only show current user
            // We create a temporary DTO for the current user to display in the rating list
            _currentRatingMembers = new List<HouseholdMemberDto>();

            // We need the current user's ID.
            // Since we might not have the full ID easily accessible in this scope without looking up profile,
            // we can try to find it in any household or just use the AuthState if we had the ID there.
            // Fallback: If user is in ANY household, find their ID.
            var myMemberInfo = HouseholdState.UserHouseholds
                .SelectMany(h => h.Members)
                .FirstOrDefault(m => m.DisplayName == _currentUserName); // Fallback matching

            if (myMemberInfo != null)
            {
                _currentRatingMembers.Add(myMemberInfo);
            }
        }

        // Initialize dictionaries for new members
        foreach (var member in _currentRatingMembers)
        {
            if (!_memberIncluded.ContainsKey(member.UserId)) _memberIncluded[member.UserId] = true;
            if (!_memberRatings.ContainsKey(member.UserId)) _memberRatings[member.UserId] = 5;
        }
    }

    private void LoadDraft(FoodItem draft)
    {
        _newFood.Name = draft.Name;
        _newFood.Description = draft.Description;
        _fromDraft = true;
        if (draft.ImageUrls != null)
        {
            _imagePreviewUrls.AddRange(draft.ImageUrls);
            _draftImageUrls.AddRange(draft.ImageUrls);
        }
        FoodService.DraftRecipe = null;
    }

    private void SetFoodType(bool isHelloFresh) => _isHelloFresh = isHelloFresh;

    #region Dictionary Helpers
    private bool IsMemberIncluded(Guid userId) => _memberIncluded.ContainsKey(userId) && _memberIncluded[userId];
    private int GetMemberRating(Guid userId) => _memberRatings.ContainsKey(userId) ? _memberRatings[userId] : 5;
    private void SetMemberIncluded(Guid userId, bool value) => _memberIncluded[userId] = value;
    private void SetMemberRating(Guid userId, int value) => _memberRatings[userId] = value;
    #endregion

    #region Submission Logic
    private async Task SubmitFood()
    {
        if (string.IsNullOrWhiteSpace(_newFood.Name))
        {
            _errorMessage = "Navn mangler.";
            return;
        }
        _isSubmitting = true;
        try
        {
            var urls = new List<string>(_draftImageUrls);
            for (int i = 0; i < _imageData.Count; i++)
                urls.Add(await FoodService.UploadImageAsync(_imageData[i], _imageNames[i]));

            var ratingsToSend = new Dictionary<Guid, int>();
            if (_ratingEnabled)
            {
                foreach (var member in _currentRatingMembers)
                {
                    if (IsMemberIncluded(member.UserId))
                    {
                        ratingsToSend[member.UserId] = GetMemberRating(member.UserId);
                    }
                }
            }

            // Determine Visibility
            string finalVisibility = "private";
            if (_isPublic)
                finalVisibility = "public";
            else if (_shareWithGroup && _selectedGroupId.HasValue)
                finalVisibility = "household"; // Visible to the household

            var createDto = new CreateUserRecipeDto
            {
                Name = _newFood.Name,
                Description = _newFood.Description,
                ImageUrls = urls,
                PersonalNotes = _newFood.PersonalNotes,
                GlobalRecipeId = _newFood.GlobalRecipeId,
                Visibility = finalVisibility,
                MemberRatings = ratingsToSend
                // Note: The API doesn't seem to have a specific "HouseholdId" field on UserRecipe yet,
                // it relies on the user's membership. In a multi-group system, you might want to tag *which* group
                // this is for, but currently the visibility "household" usually implies "any group I am in".
            };

            await RecipeService.CreateRecipeAsync(createDto);
            RecipeService.InvalidateCache();
            Navigation.NavigateTo("");
        }
        catch (Exception ex) { _errorMessage = ex.Message; }
        finally { _isSubmitting = false; }
    }
    #endregion

    #region Image & OCR
    private async Task TriggerGalleryClick() => await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('galleryInput').click()");

    private async Task OnGalleryFileSelected()
    {
        try
        {
            _isSubmitting = true;
            if (_isHelloFresh) _isProcessingOcr = true;
            StateHasChanged();

            var images = await JSRuntime.InvokeAsync<List<ProcessedImage>>("imageTools.processInputFile", "galleryInput");
            if (images == null || images.Count == 0) return;

            bool ingredientsFound = false;

            for (int i = 0; i < images.Count; i++)
            {
                var img = images[i];
                if (_imageData.Count < 5)
                {
                    var base64Pure = img.Data.Split(',')[1];
                    _imageData.Add(Convert.FromBase64String(base64Pure));
                    _imagePreviewUrls.Add(img.Data);
                    _imageNames.Add(img.Name);
                }

                if (_isHelloFresh)
                {
                    if (i == 0 && string.IsNullOrWhiteSpace(_newFood.Name))
                    {
                        Snackbar.Add("Analyserer forside...", Severity.Info);
                        await TryAutoFillTitle(img.Data);
                    }
                    if (!ingredientsFound && string.IsNullOrWhiteSpace(_newFood.Description))
                    {
                        if (i == 0 && !string.IsNullOrWhiteSpace(_newFood.Name)) continue;
                        Snackbar.Add($"Ser etter ingredienser (Bilde {i + 1})...", Severity.Info);
                        ingredientsFound = await TryExtractIngredients(img.Data);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Feil i galleri-opplasting: {ex.Message}");
            Snackbar.Add("Noe gikk galt med bildebehandlingen.", Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            _isProcessingOcr = false;
            StateHasChanged();
        }
    }

    private async Task TryAutoFillTitle(string dataUrl)
    {
        try
        {
            var rawText = await OcrService.RecognizeTextAsync(dataUrl);
            if (!string.IsNullOrWhiteSpace(rawText))
            {
                var lines = rawText.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines)
                {
                    var cleanLine = line.Trim();
                    cleanLine = System.Text.RegularExpressions.Regex.Replace(cleanLine, @"\b(HELLO|FRESH|OPPSKRIFT|RECIPE)\b", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    cleanLine = System.Text.RegularExpressions.Regex.Replace(cleanLine, @"^[^a-zA-ZæøåÆØÅ0-9]+", "").Trim();

                    if (cleanLine.Length > 5 && cleanLine.Length < 60 && cleanLine.Any(char.IsLetter))
                    {
                        _newFood.Name = char.ToUpper(cleanLine[0]) + cleanLine.Substring(1);
                        Snackbar.Add($"Tittel funnet: {_newFood.Name}", Severity.Success);
                        await InvokeAsync(StateHasChanged);
                        break;
                    }
                }
            }
        }
        catch (Exception ex) { Console.WriteLine($"Title OCR Error: {ex}"); }
    }

    private async Task<bool> TryExtractIngredients(string dataUrl)
    {
        try
        {
            var rawText = await OcrService.RecognizeTextAsync(dataUrl);
            if (string.IsNullOrWhiteSpace(rawText)) return false;

            var rawLines = rawText.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
            var flattenedList = new List<string>();

            foreach (var line in rawLines)
            {
                var columns = System.Text.RegularExpressions.Regex.Split(line, @"\s{3,}");
                foreach (var col in columns)
                {
                    var trimmed = System.Text.RegularExpressions.Regex.Replace(col.Trim(), @"^[^a-zA-ZæøåÆØÅ0-9]+", "").Trim();
                    if (trimmed.Length > 2) flattenedList.Add(trimmed);
                }
            }

            var cleanIngredients = new List<string>();
            int foodConfidence = 0;
            var commonFoodWords = new HashSet<string>(StringComparer.OrdinalIgnoreCase) {
                "gulrot", "potet", "løk", "hvitløk", "tomat", "agurk", "salat", "kylling", "kjøtt", "biff", "svin", "fisk", "laks", "torsk",
                "ris", "pasta", "nudler", "saus", "fløte", "rømme", "ost", "smør", "olje", "krydder", "salt", "pepper"
            };

            foreach (var currentLine in flattenedList)
            {
                if (currentLine.Split(' ').Any(word => commonFoodWords.Contains(word.Trim(',', '.')))) foodConfidence++;

                bool isContinuation = cleanIngredients.Count > 0 && (char.IsLower(currentLine[0]) || currentLine.StartsWith("("));
                if (isContinuation)
                {
                    int lastIdx = cleanIngredients.Count - 1;
                    cleanIngredients[lastIdx] = cleanIngredients[lastIdx] + " " + currentLine;
                }
                else
                {
                    cleanIngredients.Add(char.ToUpper(currentLine[0]) + currentLine.Substring(1));
                }
            }

            if (foodConfidence >= 2 || (cleanIngredients.Count >= 4 && cleanIngredients.All(i => i.Length < 50)))
            {
                cleanIngredients = cleanIngredients.Distinct().ToList();
                if (cleanIngredients.Count > 0)
                {
                    _newFood.Description = "Ingredienser:\n" + string.Join("\n", cleanIngredients);
                    await InvokeAsync(StateHasChanged);
                    return true;
                }
            }
            return false;
        }
        catch (Exception ex) { Console.WriteLine($"Ingredient OCR Error: {ex.Message}"); return false; }
    }

    private async Task StartCamera()
    {
        _currentStep = ScanStep.Front;
        _showCameraOverlay = true;
        await Task.Delay(100);
        try { await JSRuntime.InvokeVoidAsync("cameraInterop.start", _videoElement); }
        catch (Exception) { Snackbar.Add("Kunne ikke starte kamera.", Severity.Error); _showCameraOverlay = false; }
    }
    private async Task StopCamera() { await JSRuntime.InvokeVoidAsync("cameraInterop.stop", _videoElement); _showCameraOverlay = false; }

    private async Task CaptureCameraImage()
    {
        if (_isProcessingOcr) return;
        _isProcessingOcr = true;
        StateHasChanged();
        try
        {
            var base64Data = await JSRuntime.InvokeAsync<string>("cameraInterop.capture", _videoElement);
            var cleanBase64 = base64Data.Contains(",") ? base64Data.Split(',')[1] : base64Data;
            _imagePreviewUrls.Add(base64Data);
            _imageData.Add(Convert.FromBase64String(cleanBase64));

            if (_currentStep == ScanStep.Front)
            {
                _imageNames.Add("hf_front.jpg");
                Snackbar.Add("Forside fanget! Analyserer...", Severity.Info);
                await TryAutoFillTitle(base64Data);
                _currentStep = ScanStep.Ingredients;
            }
            else if (_currentStep == ScanStep.Ingredients)
            {
                _imageNames.Add("hf_ingr.jpg");
                Snackbar.Add("Ingredienser fanget!", Severity.Info);
                await TryExtractIngredients(base64Data);
                _currentStep = ScanStep.Back;
            }
            else if (_currentStep == ScanStep.Back)
            {
                _imageNames.Add("hf_back.jpg");
                Snackbar.Add("Ferdig!", Severity.Success);
                await StopCamera();
                _currentStep = ScanStep.Finished;
            }
        }
        catch { Snackbar.Add("Feil ved bildeopptak.", Severity.Error); }
        finally { _isProcessingOcr = false; StateHasChanged(); }
    }

    private async Task OnImagesSelected(IReadOnlyList<IBrowserFile> files)
    {
        foreach (var file in files)
        {
            if (_imageData.Count >= 5) break;
            var fileToRead = await file.RequestImageFileAsync("image/jpeg", 1200, 1200);
            using var stream = fileToRead.OpenReadStream(30 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var buffer = ms.ToArray();
            _imagePreviewUrls.Add($"data:image/jpeg;base64,{Convert.ToBase64String(buffer)}");
            _imageData.Add(buffer);
            _imageNames.Add(file.Name);
        }
    }
    private void RemoveImage(int index)
    {
        if (index < _draftImageUrls.Count) { _draftImageUrls.RemoveAt(index); _imagePreviewUrls.RemoveAt(index); }
        else
        {
            var newIdx = index - _draftImageUrls.Count;
            if (newIdx >= 0 && newIdx < _imageData.Count) { _imageData.RemoveAt(newIdx); _imageNames.RemoveAt(newIdx); _imagePreviewUrls.RemoveAt(index); }
        }
    }
    #endregion

    #region Helpers
    private string GetMemberColor(string? n) => string.IsNullOrEmpty(n) ? "grey" : $"hsl({Math.Abs(n.GetHashCode() % 360)}, 45%, 45%)";
    private string GetRatingBackground(int r) => r >= 8 ? "rgba(45,90,69,0.15)" : r >= 5 ? "rgba(212,160,23,0.15)" : "rgba(196,69,54,0.15)";
    private string GetRatingTextColor(int r) => r >= 8 ? "#2D5A45" : r >= 5 ? "#A17D00" : "#C44536";
    private string GetOverlayClass() => _currentStep switch { ScanStep.Front => "step-landscape", ScanStep.Ingredients => "step-portrait-tall", _ => "step-portrait-normal" };
    private string GetStepTitle() => _currentStep switch { ScanStep.Front => "1: FORSIDE (SNU)", ScanStep.Ingredients => "2: INGREDIENSER", ScanStep.Back => "3: FREMGANGSMÅTE", _ => "" };
    private string GetInstructionText() => _currentStep == ScanStep.Front ? "Hold telefonen vannrett." : "Hold telefonen loddrett.";
    private string GetStepIcon() => _currentStep == ScanStep.Front ? Icons.Material.Rounded.ScreenRotation : Icons.Material.Rounded.CropPortrait;
    #endregion

}

================================================================================
FILE END: \StorhaugenWebsite\Pages\AddFood.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Archived.razor
================================================================================
@page "/archived"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.Services
@inject IAuthService AuthService
@inject IFoodService FoodService
@inject IHouseholdStateService HouseholdState // Inject this!
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@attribute [Authorize]

<div class="d-flex align-center gap-3 mb-6">
    <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Arkiv</h1>
    @if (_archivedItems.Any())
    {
        <p class="page-subtitle" style="margin: 0;">@_archivedItems.Count arkiverte mltider</p>
    }
</div>

@if (!HouseholdState.HasHousehold)
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.Home" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Ingen husstand valgt</h2>
        <p class="empty-state-text">Du m vre medlem av en husstand for  se arkiverte mltider.</p>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="settings" StartIcon="@Icons.Material.Rounded.Settings">
            G til innstillinger
        </MudButton>
    </div>
}
else if (_isLoading)
{
    <div class="d-flex flex-column gap-2">
        @for (int i = 0; i < 3; i++)
        {
            <div class="skeleton-card">
                <div class="skeleton-content" style="display: flex; gap: 12px;">
                    <div style="width: 60px; height: 60px; border-radius: 12px; background: var(--mud-palette-divider-light);"></div>
                    <div style="flex: 1;">
                        <div class="skeleton-text title" style="margin-bottom: 8px;"></div>
                        <div class="skeleton-text subtitle"></div>
                    </div>
                </div>
            </div>
        }
    </div>
}
else if (!_archivedItems.Any())
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.Inventory2" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Ingen arkiverte mltider</h2>
        <p class="empty-state-text">Arkiverte mltider vil vises her</p>
    </div>
}
else
{
    <div class="d-flex flex-column gap-2">
        @{
            var index = 0;
        }
        @foreach (var food in _archivedItems.OrderByDescending(f => f.ArchivedDate))
        {
            var currentFood = food;
            var delay = index++;
            <div class="food-list-item animate-in animate-delay-@Math.Min(delay, 4)" style="opacity: 0.85;">
                @if (currentFood.ImageUrls.Any())
                {
                    <img src="@currentFood.ImageUrls.First()"
                         alt="@currentFood.Name"
                         class="food-list-image"
                         style="filter: grayscale(40%);" />
                }
                else
                {
                    <div class="food-list-placeholder">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Small" />
                    </div>
                }
                <div class="food-list-content" @onclick="@(() => ViewFood(currentFood))">
                    <h3 class="food-list-title">@currentFood.Name</h3>
                    <p class="food-list-date">
                        Arkivert @(currentFood.ArchivedDate?.ToString("dd. MMM yyyy") ?? "")
                        @if (!string.IsNullOrEmpty(currentFood.ArchivedBy))
                        {
                            <span> av @currentFood.ArchivedBy</span>
                        }
                    </p>
                </div>
                <div class="d-flex gap-1 align-center">
                    <MudIconButton Icon="@Icons.Material.Rounded.Visibility"
                                   Size="Size.Small"
                                   OnClick="@(() => ViewFood(currentFood))" />
                    <MudIconButton Icon="@Icons.Material.Rounded.Restore"
                                   Size="Size.Small"
                                   Color="Color.Primary"
                                   OnClick="@(() => RestoreFood(currentFood))" />
                </div>
            </div>
        }
    </div>
}

@code {
    private List<FoodItem> _archivedItems = new();
    private bool _isLoading = false; // Default to false, let logic handle it

    protected override async Task OnInitializedAsync()
    {
        // 2. Only load if we have a household
        if (HouseholdState.HasHousehold)
        {
            await LoadArchivedItems();
        }
    }

    private async Task LoadArchivedItems()
    {
        _isLoading = true;
        try
        {
            var allItems = await FoodService.GetAllFoodsAsync(includeArchived: true);
            _archivedItems = allItems.Where(f => f.IsArchived).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading archived items: {ex.Message}");
            // Optionally show snackbar error here if it wasn't expected
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void ViewFood(FoodItem food)
    {
        Navigation.NavigateTo($"food/{food.Id}");
    }

    private async Task RestoreFood(FoodItem food)
    {
        try
        {
            await FoodService.RestoreFoodAsync(food.Id);
            _archivedItems.Remove(food);
            Snackbar.Add($"'{food.Name}' gjenopprettet!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Archived.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Browse.razor
================================================================================
@page "/browse"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@inject IApiClient ApiClient
@inject IHouseholdStateService HouseholdState
@inject NavigationManager Navigation
@inject IDeviceStateService DeviceState
@inject ISnackbar Snackbar
@attribute [Authorize]

<div class="d-flex align-center justify-space-between mb-4">
    <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Utforsk</h1>
</div>

@* --- Search & Filters --- *@
<div class="d-flex flex-column gap-3 mb-4">
    <MudTextField @bind-Value="_searchQuery"
                  Label="Søk etter oppskrifter"
                  Variant="Variant.Outlined"
                  Adornment="Adornment.Start"
                  AdornmentIcon="@Icons.Material.Rounded.Search"
                  OnKeyUp="OnSearchKeyUp"
                  Immediate="false"
                  DebounceInterval="500"
                  Class="search-field" />

    <div class="d-flex justify-space-between align-center">
        <div class="d-flex gap-2">
            <MudChip T="string"
                     Color="@(_sourceMode == "community" ? Color.Primary : Color.Default)"
                     OnClick="@(() => SetSourceMode("community"))"
                     Icon="@Icons.Material.Rounded.People">
                Fellesskapet
            </MudChip>
            <MudChip T="string"
                     Color="@(_sourceMode == "hellofresh" ? Color.Primary : Color.Default)"
                     OnClick="@(() => SetSourceMode("hellofresh"))"
                     Icon="@Icons.Material.Rounded.LocalDining">
                HelloFresh
            </MudChip>
        </div>

        <div class="view-toggle">
            <button class="view-toggle-btn @(_viewMode == "card" ? "active" : "")" @onclick="@(() => SetViewMode("card"))">
                <MudIcon Icon="@Icons.Material.Rounded.GridView" Size="Size.Small" />
            </button>
            <button class="view-toggle-btn @(_viewMode == "list" ? "active" : "")" @onclick="@(() => SetViewMode("list"))">
                <MudIcon Icon="@Icons.Material.Rounded.ViewList" Size="Size.Small" />
            </button>
        </div>
    </div>
</div>

@* --- Content --- *@
@if (_isLoading)
{
    <div class="d-flex flex-column gap-3">
        @for (int i = 0; i < 3; i++)
        {
            <div class="skeleton-card">
                <div class="skeleton-image"></div>
                <div class="skeleton-content">
                    <div class="skeleton-text title"></div>
                    <div class="skeleton-text subtitle"></div>
                </div>
            </div>
        }
    </div>
}
else if (!_recipes.Any())
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@(_sourceMode == "community" ? Icons.Material.Rounded.People : Icons.Material.Rounded.SearchOff)" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Ingen oppskrifter funnet</h2>
        <p class="empty-state-text">
            @(_sourceMode == "community" ? "Bli den første til å dele en oppskrift!" : "Prøv et annet søk.")
        </p>
    </div>
}
else
{
    <div class="@(_viewMode == "card" ? "d-flex flex-column gap-4" : "d-flex flex-column gap-2")">
        @foreach (var recipe in _recipes)
        {
            <div class="@(_viewMode == "card" ? "food-card" : "food-list-item") animate-in"
                 @onclick="() => OpenRecipeDetail(recipe)">

                @* --- Image --- *@
                @if (GetImageUrl(recipe) != null)
                {
                    <img src="@GetImageUrl(recipe)" alt="@recipe.Name" class="@(_viewMode == "card" ? "food-card-image" : "food-list-image")" />
                }
                else
                {
                    <div class="@(_viewMode == "card" ? "food-card-placeholder" : "food-list-placeholder")">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="@(_viewMode == "card" ? Size.Large : Size.Small)" />
                    </div>
                }

                @* --- Text Content --- *@
                <div class="@(_viewMode == "card" ? "food-card-content" : "food-list-content")">
                    @if (_viewMode == "card")
                    {
                        <div class="d-flex justify-space-between align-start gap-3">
                            <h3 class="food-card-title">@recipe.Name</h3>
                            @if (recipe.AverageRating > 0)
                            {
                                <span class="rating-badge rating-high">
                                    <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                                    @recipe.AverageRating.ToString("0.0")
                                </span>
                            }
                        </div>

                        <div class="food-card-meta mt-2 d-flex gap-2 align-center flex-wrap">
                            @if (recipe.IsHellofresh)
                            {
                                @if (recipe.PrepTimeMinutes.HasValue)
                                {
                                    <span>@recipe.PrepTimeMinutes min</span>
                                }
                                @if (!string.IsNullOrEmpty(recipe.Difficulty))
                                {
                                    <span>• @recipe.Difficulty</span>
                                }
                            }
                            else
                            {
                                <span>Delt av @recipe.CreatedByUserName</span>
                                <span>• @recipe.CreatedAt.ToString("d MMM")</span>
                            }
                        </div>

                        <div class="mt-3 d-flex gap-2">
                            <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small"
                                       StartIcon="@Icons.Material.Rounded.Add"
                                       OnClick="@(() => AddRecipe(recipe, true))">
                                Kopier
                            </MudButton>

                            <MudIconButton Icon="@Icons.Material.Rounded.Link" Size="Size.Small"
                                           OnClick="@(() => AddRecipe(recipe, false))" Title="Lagre som referanse" />
                        </div>
                    }
                    else // List View
                    {
                        <h3 class="food-list-title">@recipe.Name</h3>
                        <p class="food-list-date">
                            @if (recipe.IsHellofresh)
                            {
                                @(recipe.PrepTimeMinutes.HasValue ? $"{recipe.PrepTimeMinutes} min" : "")
                                @(!string.IsNullOrEmpty(recipe.Cuisine) ? $" • {recipe.Cuisine}" : "")
                            }
                            else
                            {
                                <text>@recipe.CreatedByUserName • @recipe.CreatedAt.ToString("d MMM")</text>
                            }
                        </p>
                    }
                </div>

                @* List View Actions *@
                @if (_viewMode == "list")
                {
                    <div class="d-flex align-center gap-2">
                        @if (recipe.AverageRating > 0)
                        {
                            <div class="food-list-rating">
                                <span class="rating-badge rating-high">@recipe.AverageRating.ToString("0.0")</span>
                            </div>
                        }
                        <MudMenu Icon="@Icons.Material.Rounded.MoreVert" Size="Size.Small" @onclick:stopPropagation="true">
                            <MudMenuItem Icon="@Icons.Material.Rounded.ContentCopy" OnClick="@(() => AddRecipe(recipe, true))">Kopier til liste</MudMenuItem>
                            <MudMenuItem Icon="@Icons.Material.Rounded.Link" OnClick="@(() => AddRecipe(recipe, false))">Lagre som lenke</MudMenuItem>
                        </MudMenu>
                    </div>
                }
            </div>
        }
    </div>

    @* --- Pagination --- *@
    @if (_totalPages > 1)
    {
        <div class="d-flex justify-center align-center gap-2 mt-4">
            <MudIconButton Icon="@Icons.Material.Rounded.ChevronLeft" OnClick="PreviousPage" Disabled="@(_currentPage <= 1)" Size="Size.Small" />
            <MudText Typo="Typo.body2">Side @_currentPage av @_totalPages</MudText>
            <MudIconButton Icon="@Icons.Material.Rounded.ChevronRight" OnClick="NextPage" Disabled="@(_currentPage >= _totalPages)" Size="Size.Small" />
        </div>
    }
}

<style>
    .search-field {
        max-width: 100%;
    }
    /* View Toggle */
    .view-toggle {
        display: flex;
        background: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-lines-default);
        border-radius: 8px;
        padding: 2px;
    }

    .view-toggle-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--mud-palette-text-secondary);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

        .view-toggle-btn:hover {
            background: var(--mud-palette-action-default-hover);
            color: var(--mud-palette-text-primary);
        }

        .view-toggle-btn.active {
            background: var(--mud-palette-primary-hover);
            color: var(--mud-palette-primary-text);
        }
    /* Cards */
    .food-card {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        transition: all 0.2s ease;
        border: 1px solid transparent;
        cursor: pointer;
    }

        .food-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border-color: var(--mud-palette-lines-default);
            transform: translateY(-2px);
        }

    .food-card-image {
        width: 100%;
        height: 180px;
        object-fit: cover;
    }

    .food-card-placeholder {
        width: 100%;
        height: 180px;
        background: var(--mud-palette-background-grey);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-disabled);
    }

    .food-card-content {
        padding: 16px;
    }

    .food-card-title {
        font-size: 1.1rem;
        font-weight: 600;
        margin: 0 0 4px 0;
        color: var(--mud-palette-text-primary);
        line-height: 1.3;
    }
    /* List Items */
    .food-list-item {
        display: flex;
        align-items: center;
        padding: 12px;
        background: var(--mud-palette-surface);
        border-radius: 12px;
        gap: 16px;
        transition: all 0.2s ease;
        border: 1px solid transparent;
        cursor: pointer;
    }

        .food-list-item:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border-color: var(--mud-palette-lines-default);
            transform: translateY(-2px);
        }

    .food-list-image {
        width: 60px;
        height: 60px;
        border-radius: 8px;
        object-fit: cover;
        flex-shrink: 0;
    }

    .food-list-placeholder {
        width: 60px;
        height: 60px;
        border-radius: 8px;
        background: var(--mud-palette-background-grey);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--mud-palette-text-disabled);
        flex-shrink: 0;
    }

    .food-list-content {
        flex: 1;
        min-width: 0;
    }

    .food-list-title {
        font-size: 1rem;
        font-weight: 600;
        margin: 0 0 4px 0;
        color: var(--mud-palette-text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .rating-badge {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        flex-shrink: 0;
    }

    .rating-high {
        background: rgba(76, 175, 80, 0.1);
        color: #2e7d32;
    }

    .empty-state {
        text-align: center;
        padding: 60px 20px;
    }

    .empty-state-icon {
        font-size: 4rem;
        color: var(--mud-palette-text-secondary);
        margin-bottom: 16px;
    }

    .animate-in {
        animation: fadeIn 0.4s ease-out forwards;
        opacity: 0;
        transform: translateY(10px);
    }

    @@keyframes fadeIn {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .skeleton-card {
        background: var(--mud-palette-surface);
        border-radius: 16px;
        overflow: hidden;
        height: 300px;
    }

    .skeleton-image {
        width: 100%;
        height: 180px;
        background: linear-gradient(90deg, var(--mud-palette-background-grey) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-background-grey) 75%);
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
    }

    .skeleton-content {
        padding: 20px;
    }

    .skeleton-text {
        background: linear-gradient(90deg, var(--mud-palette-background-grey) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-background-grey) 75%);
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 4px;
        margin-bottom: 10px;
    }

        .skeleton-text.title {
            height: 24px;
            width: 60%;
        }

        .skeleton-text.subtitle {
            height: 16px;
            width: 40%;
        }

    @@keyframes shimmer {
        0% {
            background-position: 200% 0;
        }

        100% {
            background-position: -200% 0;
        }
    }
</style>

@code {
    private List<GlobalRecipeDto> _recipes = new();
    private bool _isLoading = true;
    private string _searchQuery = "";
    private string _sourceMode = "community";
    private string _viewMode = "card";
    private int _currentPage = 1;
    private int _pageSize = 20;
    private int _totalPages = 0;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(DeviceState.Settings.ViewMode))
        {
            _viewMode = DeviceState.Settings.ViewMode;
        }
        await LoadRecipes();
    }

    private async Task SetSourceMode(string mode)
    {
        if (_sourceMode == mode) return;
        _sourceMode = mode;
        _currentPage = 1;
        await LoadRecipes();
    }

    private async Task SetViewMode(string mode)
    {
        _viewMode = mode;
        await DeviceState.SetViewModeAsync(mode);
    }

    private async Task LoadRecipes()
    {
        _isLoading = true;
        try
        {
            var query = new BrowseGlobalRecipesQuery
            {
                Search = string.IsNullOrWhiteSpace(_searchQuery) ? null : _searchQuery,
                SortBy = _sourceMode == "hellofresh" ? "popular" : "newest",
                Page = _currentPage,
                PageSize = _pageSize,
                // Community mode now uses the Global Recipe endpoint too
                HellofreshOnly = _sourceMode == "hellofresh"
            };

            var result = await ApiClient.BrowseGlobalRecipesAsync(query);

            if (_sourceMode == "community")
            {
                // Filter client-side just in case the API returns mixed results for HellofreshOnly=false
                _recipes = result.Recipes.Where(r => !r.IsHellofresh).ToList();
            }
            else
            {
                _recipes = result.Recipes;
            }

            _totalPages = result.TotalPages;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading recipes: {ex.Message}");
            Snackbar.Add("Kunne ikke laste oppskrifter", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            _currentPage = 1;
            await LoadRecipes();
        }
    }

    private async Task PreviousPage()
    {
        if (_currentPage > 1)
        {
            _currentPage--;
            await LoadRecipes();
        }
    }

    private async Task NextPage()
    {
        if (_currentPage < _totalPages)
        {
            _currentPage++;
            await LoadRecipes();
        }
    }

    private void OpenRecipeDetail(GlobalRecipeDto recipe)
    {
        // Simply navigate to browse/{id} - it will handle both types
        Navigation.NavigateTo($"browse/{recipe.Id}");
    }

    private string? GetImageUrl(GlobalRecipeDto recipe)
    {
        if (!string.IsNullOrEmpty(recipe.ImageUrl)) return recipe.ImageUrl;
        return recipe.ImageUrls?.FirstOrDefault();
    }

    private async Task AddRecipe(GlobalRecipeDto recipe, bool fork)
    {
        if (!HouseholdState.HasHousehold)
        {
            Snackbar.Add("Vennligst opprett en husstand først", Severity.Warning);
            return;
        }

        try
        {
            var dto = new CreateHouseholdRecipeDto
            {
                GlobalRecipeId = recipe.Id,
                Fork = fork,
                Name = fork ? recipe.Name : null,
                PrepTimeMinutes = fork ? recipe.PrepTimeMinutes : null,
                Servings = fork ? recipe.Servings : null,
                Difficulty = fork ? recipe.Difficulty : null,
                Cuisine = fork ? recipe.Cuisine : null,
                Tags = fork ? recipe.Tags : null,
                Ingredients = fork ? recipe.Ingredients : null,
                ImageUrl = fork ? GetImageUrl(recipe) : null,
                Description = fork ? recipe.Description : null,
                ImageUrls = fork && recipe.ImageUrls != null ? new List<string>(recipe.ImageUrls) : null
            };

            await ApiClient.CreateRecipeAsync(dto);

            if (fork)
                Snackbar.Add($"'{recipe.Name}' kopiert til din husstand", Severity.Success);
            else
                Snackbar.Add($"'{recipe.Name}' lenket til din husstand", Severity.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error adding recipe: {ex.Message}");
            Snackbar.Add("Klarte ikke å legge til oppskrift", Severity.Error);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Browse.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\BrowseDetails.razor
================================================================================
@page "/browse/{Id:guid}"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@inject IApiClient ApiClient
@inject IFoodService FoodService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IHouseholdStateService HouseholdState
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="@(() => Navigation.NavigateTo("browse"))">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="p-4 d-flex justify-center">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_recipe == null)
{
    <div class="empty-state">
        <MudIcon Icon="@Icons.Material.Rounded.Error" Size="Size.Large" />
        <h2>Oppskrift ikke funnet</h2>
    </div>
}
else
{
    @* --- Header Image --- *@
    @if (!string.IsNullOrEmpty(GetImageUrl()))
    {
        <img src="@GetImageUrl()" class="detail-hero-image" />
    }
    else
    {
        <div class="detail-hero-placeholder">
            <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Large" />
        </div>
    }

    <div class="detail-content">
        <div class="d-flex justify-space-between align-start gap-3">
            <h1 class="detail-title">@_recipe.Name</h1>
            @if (_recipe.AverageRating > 0)
            {
                <span class="rating-badge rating-high">
                    <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                    @_recipe.AverageRating.ToString("0.0")
                </span>
            }
        </div>

        @* --- Source Badge --- *@
        <div class="d-flex gap-2 mt-2">
            @if (_recipe.IsHellofresh)
            {
                <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.LocalDining" Color="Color.Primary">
                    HelloFresh
                </MudChip>
            }
            else
            {
                <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.People" Color="Color.Tertiary">
                    Delt av @(_recipe.CreatedByUserName ?? "Fellesskapet")
                </MudChip>
            }

            @if (_recipe.PrepTimeMinutes.HasValue)
            {
                <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Rounded.AccessTime" Variant="Variant.Text">
                    @_recipe.PrepTimeMinutes min
                </MudChip>
            }
        </div>

        @if (!string.IsNullOrEmpty(_recipe.Description))
        {
            <p class="detail-description mt-4">@_recipe.Description</p>
        }

        <div class="action-buttons mt-6">
            @* --- Option A: Link (Reference) --- *@
            <div class="action-card">
                <div class="d-flex gap-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Link" Color="Color.Primary" Size="Size.Medium" />
                    <div>
                        <h3 class="action-title">Lagre som referanse</h3>
                        <p class="action-desc">
                            Lenker direkte til denne oppskriften.
                            Flere familier kan rangere samme rett, og ratingen blir delt.
                        </p>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" Class="mt-2"
                                   OnClick="AddToMyListAsLink" Disabled="_isProcessing">
                            Legg til i min liste
                        </MudButton>
                    </div>
                </div>
            </div>

            @* --- Option B: Copy (Fork) --- *@
            <div class="action-card mt-3">
                <div class="d-flex gap-3">
                    <MudIcon Icon="@Icons.Material.Rounded.ContentCopy" Color="Color.Secondary" Size="Size.Medium" />
                    <div>
                        <h3 class="action-title">Kopier og tilpass</h3>
                        <p class="action-desc">
                            Lager en kopi som du kan redigere.
                            Du kan endre ingredienser og navn før du lagrer.
                        </p>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" FullWidth="true" Class="mt-2"
                                   OnClick="CustomizeAndAdd">
                            Tilpass og legg til
                        </MudButton>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<style>
    .detail-hero-image {
        width: 100%;
        height: 250px;
        object-fit: cover;
        border-radius: 0 0 24px 24px;
    }

    .detail-hero-placeholder {
        width: 100%;
        height: 250px;
        background: var(--mud-palette-background-grey);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0 0 24px 24px;
        color: var(--mud-palette-text-disabled);
    }

    .detail-content {
        padding: 24px;
    }

    .detail-title {
        font-size: 1.75rem;
        font-weight: 700;
        line-height: 1.2;
        margin: 0;
    }

    .detail-description {
        color: var(--mud-palette-text-secondary);
        line-height: 1.6;
    }

    .action-card {
        background: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-lines-default);
        border-radius: 16px;
        padding: 16px;
    }

    .action-title {
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 4px;
    }

    .action-desc {
        font-size: 0.85rem;
        color: var(--mud-palette-text-secondary);
        margin-bottom: 0;
    }
</style>

@code {
    [Parameter] public Guid Id { get; set; }

    private GlobalRecipeDto? _recipe;
    private bool _isLoading = true;
    private bool _isProcessing = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    private async Task LoadData()
    {
        _isLoading = true;
        try
        {
            // Now we ALWAYS use the Global endpoint, which handles both HelloFresh and Community recipes
            _recipe = await ApiClient.GetGlobalRecipeAsync(Id);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Snackbar.Add("Feil ved lasting av oppskrift", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private string? GetImageUrl()
    {
        if (_recipe == null) return null;
        if (!string.IsNullOrEmpty(_recipe.ImageUrl)) return _recipe.ImageUrl;
        return _recipe.ImageUrls?.FirstOrDefault();
    }

    // Logic for "Option A: Reference"
    private async Task AddToMyListAsLink()
    {
        if (!HouseholdState.HasHousehold)
        {
            Snackbar.Add("Du må være medlem av en husstand", Severity.Warning);
            return;
        }

        _isProcessing = true;
        try
        {
            var dto = new CreateHouseholdRecipeDto { GlobalRecipeId = Id, Fork = false };
            await ApiClient.CreateRecipeAsync(dto);
            Snackbar.Add("Oppskrift lagret!", Severity.Success);
            Navigation.NavigateTo("");
        }
        catch
        {
            Snackbar.Add("Kunne ikke lagre oppskrift", Severity.Error);
        }
        _isProcessing = false;
    }

    // Logic for "Option B: Customize/Copy"
    private void CustomizeAndAdd()
    {
        if (_recipe == null) return;

        // Populate the draft in the service
        FoodService.DraftRecipe = new StorhaugenWebsite.Models.FoodItem
        {
            Name = _recipe.Name,
            Description = _recipe.Description,
            ImageUrls = _recipe.ImageUrls ?? new List<string>(),
            GlobalRecipeId = _recipe.Id
        };

        // Navigate to Add page
        Navigation.NavigateTo("add");
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\BrowseDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\CookBook.razor
================================================================================
@page "/cookbook"
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IUserRecipeService RecipeService
@inject IHouseholdStateService HouseholdState
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject IDeviceStateService DeviceState
@inject IApiClient ApiClient
@attribute [Authorize]
@implements IDisposable

<div class="cookbook-top">

    <!-- Row 1: Search + View toggle -->
    <div class="cookbook-top-row">
        <MudTextField @bind-Value="_searchQuery"
                      Placeholder="Søk i oppskrifter…"
                      Variant="Variant.Outlined"
                      Margin="Margin.Dense"
                      Immediate="true"
                      DebounceInterval="300"
                      OnDebounceIntervalElapsed="OnSearchChanged"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Rounded.Search"
                      Class="cookbook-search" />

        <div class="view-toggle">
            <button class="view-toggle-btn @(_viewMode == "card" ? "active" : "")"
                    @onclick="@(() => SetViewMode("card"))">
                <MudIcon Icon="@Icons.Material.Rounded.GridView" Size="Size.Small" />
            </button>
            <button class="view-toggle-btn @(_viewMode == "list" ? "active" : "")"
                    @onclick="@(() => SetViewMode("list"))">
                <MudIcon Icon="@Icons.Material.Rounded.ViewList" Size="Size.Small" />
            </button>
        </div>
    </div>

    <!-- Row 2: Filters (Groups / Source / Sort) -->
    <div class="cookbook-filters">

        <!-- Groups -->
        <MudSelect T="Guid"
                   Dense="true"
                   Variant="Variant.Outlined"
                   MultiSelection="true"
                   Label="Grupper"
                   Disabled="@(!_hasMultipleGroups || _sourceMode != CookbookSource.All)"
                   SelectedValues="@_selectedGroupIds"
                   SelectedValuesChanged="OnSelectedGroupsChanged"
                   MultiSelectionTextFunc="GroupsMultiText"
                   Class="cookbook-select">
            @foreach (var g in HouseholdState.UserHouseholds)
            {
                <MudSelectItem Value="@g.Id">@g.Name</MudSelectItem>
            }
        </MudSelect>

        <!-- Source -->
        <MudSelect T="CookbookSource"
                   Dense="true"
                   Variant="Variant.Outlined"
                   Label="Vis"
                   Value="@_sourceMode"
                   ValueChanged="OnSourceChanged"
                   Class="cookbook-select">
            <MudSelectItem Value="@CookbookSource.All">Alle</MudSelectItem>
            <MudSelectItem Value="@CookbookSource.Mine">Mine</MudSelectItem>
            <MudSelectItem Value="@CookbookSource.Friends">Venner</MudSelectItem>
        </MudSelect>

        <!-- Sort -->
        <MudSelect T="CookbookSort"
                   Dense="true"
                   Variant="Variant.Outlined"
                   Label="Sorter"
                   Value="@_sortMode"
                   ValueChanged="OnSortChanged"
                   Class="cookbook-select">
            <MudSelectItem Value="@CookbookSort.Date">Dato</MudSelectItem>
            <MudSelectItem Value="@CookbookSort.Name">Navn</MudSelectItem>
            <MudSelectItem Value="@CookbookSort.AvgRating">Snitt</MudSelectItem>
            <MudSelectItem Value="@CookbookSort.MyRating">Min rating</MudSelectItem>
            <MudSelectItem Value="@CookbookSort.MemberRating">Person</MudSelectItem>
        </MudSelect>

        <MudIconButton Icon="@(_sortDescending ? Icons.Material.Rounded.South : Icons.Material.Rounded.North)"
                       Title="Bytt rekkefølge"
                       Variant="Variant.Outlined"
                       Size="Size.Small"
                       OnClick="ToggleSortDirection"
                       Class="cookbook-sortdir" />
    </div>

    <!-- Row 3: Member picker (only when sorting by member rating) -->
    @if (_sortMode == CookbookSort.MemberRating)
    {
        <MudAutocomplete T="HouseholdMemberDto"
                         Dense="true"
                         Variant="Variant.Outlined"
                         Label="Sorter etter person"
                         Clearable="true"
                         ResetValueOnEmptyText="true"
                         Value="@_selectedMember"
                         ValueChanged="OnSelectedMemberChanged"
                         SearchFunc="SearchMembers"
                         ToStringFunc="@(m => m?.DisplayName ?? "")"
                         Class="cookbook-member-autocomplete" />
    }

    <!-- Tags (only relevant for Mine) -->
    @if (_sourceMode == CookbookSource.Mine && _tags.Any())
    {
        <MudSelect T="Guid"
                   Dense="true"
                   Variant="Variant.Outlined"
                   MultiSelection="true"
                   Label="Kategorier"
                   SelectedValues="@_activeTagIds"
                   SelectedValuesChanged="OnSelectedTagsChanged"
                   MultiSelectionTextFunc="TagsMultiText"
                   Class="cookbook-tags">
            @foreach (var t in _tags)
            {
                <MudSelectItem Value="@t.Id">@t.Name</MudSelectItem>
            }
        </MudSelect>
    }
</div>

@if (_isLoading)
{
    <div class="d-flex flex-column gap-3">
        @for (int i = 0; i < 4; i++)
        {
            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100px" Class="rounded-lg" />
        }
    </div>
}
else if (!_recipes.Any())
{
    <div class="empty-state pa-8 text-center">
        <MudIcon Icon="@Icons.Material.Rounded.MenuBook" Size="Size.Large" Color="Color.Default" />
        <MudText Typo="Typo.h6" Class="mt-3">Ingen oppskrifter funnet</MudText>
        <MudButton Variant="Variant.Text" Color="Color.Primary" Href="add">Legg til ny oppskrift</MudButton>
    </div>
}
else
{
    <div class="@(_viewMode == "card" ? "d-flex flex-column gap-4" : "d-flex flex-column gap-2")">
        @foreach (var recipe in _recipes)
        {
            <div class="@(_viewMode == "card" ? "food-card" : "food-list-item") animate-in"
                 @onclick="() => OpenRecipe(recipe.UserRecipeId)">

                @* Image *@
                @if (recipe.ImageUrls?.Any() == true)
                {
                    <img src="@recipe.ImageUrls.First()" class="@(_viewMode == "card" ? "food-card-image" : "food-list-image")" />
                }
                else
                {
                    <div class="@(_viewMode == "card" ? "food-card-placeholder" : "food-list-placeholder")">
                        <MudIcon Icon="@Icons.Material.Rounded.Restaurant" />
                    </div>
                }

                @* Content *@
                <div class="@(_viewMode == "card" ? "food-card-content" : "food-list-content")">

                    <div class="d-flex justify-space-between align-start">
                        <div style="min-width:0;">
                            <h3 class="@(_viewMode == "card" ? "food-card-title" : "food-list-title")">@recipe.Name</h3>

                            <div class="d-flex align-center gap-1 mt-1">
                                <MudIcon Icon="@Icons.Material.Rounded.Person" Size="Size.Small" Style="font-size: 12px; opacity: 0.7;" />
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="text-truncate">
                                    @(recipe.OwnerDisplayName == AuthService.CurrentUserName ? "Deg" : recipe.OwnerDisplayName)
                                </MudText>
                            </div>
                        </div>

                        @* Avg badge *@
                        @{
                            var avg = GetAverage(recipe);
                        }
                        @if (avg > 0)
                        {
                            <span class="rating-badge @GetRatingClass(avg)">
                                <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" Style="font-size: 12px;" />
                                @avg.ToString("0.0")
                            </span>
                        }
                    </div>

                    @* Ratings strip *@
                    <div class="rating-strip">
                        @{
                            var my = GetMyRating(recipe);
                        }

                        @* My rating (MemberRatingDto.Rating is int, so null == "no entry") *@
                        @if (my is not null)
                        {
                            <MudChip Size="Size.Small" T="string"
                                     Variant="Variant.Outlined"
                                     Icon="@Icons.Material.Rounded.Star"
                                     Class="my-rating-chip">
                                @my.Rating
                            </MudChip>
                        }
                        else
                        {
                            <MudChip Size="Size.Small" T="string" Variant="Variant.Outlined" Class="my-rating-chip muted">
                                Min: –
                            </MudChip>
                        }

                        @* Other member ratings (max 5) *@
                        @{
                            var others = GetOtherRatings(recipe).ToList();
                            var take = others.Take(5).ToList();
                            var remaining = others.Count - take.Count;
                        }

                        <div class="other-ratings">
                            @foreach (var r in take)
                            {
                                <MudTooltip Text="@($"{r.DisplayName}: {r.Rating}")" Placement="Placement.Top">
                                    <MudBadge Content="@r.Rating.ToString()"
                                              Overlap="true"
                                              Origin="Origin.BottomRight"
                                              Class="rating-avatar-badge">
                                        <MudAvatar Size="Size.Small" Image="@r.AvatarUrl" Class="rating-avatar">
                                            @GetInitials(r.DisplayName)
                                        </MudAvatar>
                                    </MudBadge>
                                </MudTooltip>
                            }

                            @if (remaining > 0)
                            {
                                <MudChip Size="Size.Small" T="string" Variant="Variant.Outlined" Class="more-chip">
                                    +@remaining
                                </MudChip>
                            }
                        </div>
                    </div>

                </div>
            </div>
        }
    </div>
}

@code {
    private List<AggregatedRecipeDto> _recipes = new();
    private bool _isLoading = true;

    private string _searchQuery = "";
    private string _viewMode = "card";

    private CookbookSource _sourceMode = CookbookSource.All;
    private CookbookSort _sortMode = CookbookSort.Date;
    private bool _sortDescending = true;

    private HashSet<Guid> _selectedGroupIds = new();
    private bool _suppressGroupSync;
    private bool _hasMultipleGroups => HouseholdState.UserHouseholds?.Count > 1;

    private Guid? _currentUserId;
    private HouseholdMemberDto? _selectedMember;
    private List<HouseholdMemberDto> _availableMembers = new();

    private List<TagDto> _tags = new();
    private HashSet<Guid> _activeTagIds = new();

    protected override async Task OnInitializedAsync()
    {
        HouseholdState.OnActiveGroupsChanged += OnGroupsChanged;

        await HouseholdState.InitializeAsync();
        _viewMode = DeviceState.Settings.ViewMode ?? "card";

        try
        {
            var me = await ApiClient.GetMyProfileAsync();
            _currentUserId = me?.Id;
        }
        catch { }

        await LoadTags();

        if (HouseholdState.UserHouseholds.Any())
        {
            if (!HouseholdState.ActiveGroupFilters.Any())
            {
                _suppressGroupSync = true;
                HouseholdState.SelectAllGroups();
                _suppressGroupSync = false;
            }

            _selectedGroupIds = HouseholdState.ActiveGroupFilters.ToHashSet();
        }

        RefreshAvailableMembers();
        await LoadRecipes();
    }

    private async Task LoadTags()
    {
        try { _tags = await ApiClient.GetMyTagsAsync(); }
        catch { _tags = new(); }
    }

    private async Task OnSelectedTagsChanged(IEnumerable<Guid> selected)
    {
        _activeTagIds = selected.ToHashSet();
        await LoadRecipes();
    }

    private string TagsMultiText(List<string> selectedIds)
        => selectedIds.Count == 0 ? "Alle" : $"{selectedIds.Count} valgt";

    private async Task OnSelectedGroupsChanged(IEnumerable<Guid> selected)
    {
        _selectedGroupIds = selected.ToHashSet();

        await SyncGroupsToHouseholdState();
        RefreshAvailableMembers();

        if (_selectedMember != null && !_availableMembers.Any(m => m.UserId == _selectedMember.UserId))
            _selectedMember = null;

        await LoadRecipes();
    }

    private async Task SyncGroupsToHouseholdState()
    {
        if (!_hasMultipleGroups)
            return;

        _suppressGroupSync = true;
        try
        {
            var current = HouseholdState.ActiveGroupFilters.ToHashSet();

            foreach (var id in current.Except(_selectedGroupIds))
                HouseholdState.ToggleGroupFilter(id);

            foreach (var id in _selectedGroupIds.Except(current))
                HouseholdState.ToggleGroupFilter(id);
        }
        finally
        {
            _suppressGroupSync = false;
        }

        await Task.CompletedTask;
    }

    private string GroupsMultiText(List<string> selectedIds)
    {
        if (!_hasMultipleGroups) return "1 gruppe";
        if (selectedIds.Count == 0) return "Ingen";
        if (selectedIds.Count == HouseholdState.UserHouseholds.Count) return "Alle";
        return $"{selectedIds.Count} valgt";
    }

    private async void OnGroupsChanged()
    {
        if (_suppressGroupSync) return;

        await InvokeAsync(async () =>
        {
            _selectedGroupIds = HouseholdState.ActiveGroupFilters.ToHashSet();
            RefreshAvailableMembers();

            if (_selectedMember != null && !_availableMembers.Any(m => m.UserId == _selectedMember.UserId))
                _selectedMember = null;

            await LoadRecipes();
            StateHasChanged();
        });
    }

    private void RefreshAvailableMembers()
    {
        var groups = HouseholdState.UserHouseholds
            .Where(h => _selectedGroupIds.Contains(h.Id))
            .ToList();

        _availableMembers = groups
            .SelectMany(g => g.Members ?? new List<HouseholdMemberDto>())
            .GroupBy(m => m.UserId)
            .Select(g => g.First())
            .OrderBy(m => m.DisplayName)
            .ToList();
    }

    private Task<IEnumerable<HouseholdMemberDto>> SearchMembers(string value, CancellationToken token)
    {
        if (string.IsNullOrWhiteSpace(value))
            return Task.FromResult(_availableMembers.Take(25).AsEnumerable());

        value = value.Trim();
        return Task.FromResult(_availableMembers
            .Where(m => (m.DisplayName ?? "").Contains(value, StringComparison.OrdinalIgnoreCase))
            .Take(25)
            .AsEnumerable());
    }

    private async Task OnSelectedMemberChanged(HouseholdMemberDto? member)
    {
        _selectedMember = member;
        await LoadRecipes();
    }

    private async Task OnSourceChanged(CookbookSource source)
    {
        _sourceMode = source;

        if (_sourceMode != CookbookSource.Mine && _activeTagIds.Any())
            _activeTagIds.Clear();

        await LoadRecipes();
    }

    private async Task OnSortChanged(CookbookSort sort)
    {
        _sortMode = sort;
        await LoadRecipes();
    }

    private async Task ToggleSortDirection()
    {
        _sortDescending = !_sortDescending;
        await LoadRecipes();
    }

    private async Task OnSearchChanged(string value)
    {
        await LoadRecipes();
    }

    private async Task LoadRecipes()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            if (_sourceMode == CookbookSource.Mine || _activeTagIds.Any())
            {
                var query = new GetUserRecipesQuery
                {
                    Search = _searchQuery,
                    PageSize = 50,
                    SortDescending = _sortDescending,
                    SortBy = SortByForUserQuery(_sortMode),
                    TagIds = _activeTagIds.Any() ? _activeTagIds.ToList() : null
                };

                var result = await RecipeService.GetMyRecipesAsync(query);

                _recipes = result.Recipes.Select(r => new AggregatedRecipeDto
                {
                    UserRecipeId = r.Id,
                    OwnerUserId = r.UserId,
                    OwnerDisplayName = "Deg",
                    OwnerAvatarUrl = r.UserAvatarUrl,
                    Name = r.Name,
                    ImageUrls = r.ImageUrls,
                    HouseholdAverageRating = r.AverageRating,
                    HouseholdRatingCount = r.RatingCount,
                    CreatedAt = r.CreatedAt,
                    MemberRatings = r.MemberRatings ?? new List<MemberRatingDto>()
                }).ToList();
            }
            else if (_sourceMode == CookbookSource.Friends)
            {
                var query = new GetUserRecipesQuery
                {
                    Search = _searchQuery,
                    PageSize = 50,
                    SortDescending = _sortDescending,
                    SortBy = SortByForUserQuery(_sortMode)
                };

                var result = await RecipeService.GetFriendsRecipesAsync(query);

                _recipes = result.Recipes.Select(r => new AggregatedRecipeDto
                {
                    UserRecipeId = r.Id,
                    OwnerUserId = r.UserId,
                    OwnerDisplayName = r.UserDisplayName ?? "Ukjent",
                    OwnerAvatarUrl = r.UserAvatarUrl,
                    Name = r.Name,
                    ImageUrls = r.ImageUrls,
                    HouseholdAverageRating = r.AverageRating,
                    HouseholdRatingCount = r.RatingCount,
                    CreatedAt = r.CreatedAt,
                    MemberRatings = r.MemberRatings ?? new List<MemberRatingDto>()
                }).ToList();
            }
            else if (HouseholdState.HasHousehold && _selectedGroupIds.Any())
            {
                var query = new GetCombinedRecipesQuery
                {
                    Search = _searchQuery,
                    PageSize = 50,
                    SortDescending = _sortDescending,
                    SortBy = SortByForCombinedQuery(_sortMode)
                };

                var result = await RecipeService.GetGroupsCombinedRecipesAsync(_selectedGroupIds.ToList(), query);
                _recipes = result.Recipes;
            }
            else
            {
                var query = new GetUserRecipesQuery
                {
                    Search = _searchQuery,
                    PageSize = 50,
                    SortDescending = _sortDescending,
                    SortBy = SortByForUserQuery(_sortMode)
                };

                var result = await RecipeService.GetMyRecipesAsync(query);
                _recipes = result.Recipes.Select(r => new AggregatedRecipeDto
                {
                    UserRecipeId = r.Id,
                    OwnerUserId = r.UserId,
                    OwnerDisplayName = "Deg",
                    OwnerAvatarUrl = r.UserAvatarUrl,
                    Name = r.Name,
                    ImageUrls = r.ImageUrls,
                    HouseholdAverageRating = r.AverageRating,
                    HouseholdRatingCount = r.RatingCount,
                    CreatedAt = r.CreatedAt,
                    MemberRatings = r.MemberRatings ?? new List<MemberRatingDto>()
                }).ToList();
            }

            ApplyClientSortIfNeeded();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading recipes: {ex.Message}");
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private void ApplyClientSortIfNeeded()
    {
        Func<AggregatedRecipeDto, int?> my = r => GetMyRating(r)?.Rating;
        Func<AggregatedRecipeDto, int?> member = r => GetMemberRating(r, _selectedMember?.UserId);

        IOrderedEnumerable<AggregatedRecipeDto> ordered = _sortMode switch
        {
            CookbookSort.Name => _sortDescending
                ? _recipes.OrderByDescending(r => r.Name, StringComparer.OrdinalIgnoreCase)
                : _recipes.OrderBy(r => r.Name, StringComparer.OrdinalIgnoreCase),

            CookbookSort.AvgRating => _sortDescending
                ? _recipes.OrderByDescending(r => GetAverage(r))
                : _recipes.OrderBy(r => GetAverage(r)),

            CookbookSort.MyRating => _sortDescending
                ? _recipes.OrderByDescending(r => my(r) ?? -1)
                : _recipes.OrderBy(r => my(r) ?? -1),

            CookbookSort.MemberRating => _sortDescending
                ? _recipes.OrderByDescending(r => member(r) ?? -1)
                : _recipes.OrderBy(r => member(r) ?? -1),

            _ => _sortDescending
                ? _recipes.OrderByDescending(r => r.CreatedAt)
                : _recipes.OrderBy(r => r.CreatedAt)
        };

        _recipes = ordered
            .ThenBy(r => r.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static string SortByForUserQuery(CookbookSort sort)
        => sort switch
        {
            CookbookSort.Name => "name",
            CookbookSort.AvgRating => "rating",
            _ => "date"
        };

    private static string SortByForCombinedQuery(CookbookSort sort)
        => sort switch
        {
            CookbookSort.Name => "name",
            CookbookSort.AvgRating => "rating",
            _ => "date"
        };

    private void OpenRecipe(Guid id) => Navigation.NavigateTo($"food/{id}");

    private double GetAverage(AggregatedRecipeDto r)
    {
        if (r.HouseholdAverageRating > 0) return r.HouseholdAverageRating;
        if (r.MemberRatings is { Count: > 0 }) return r.MemberRatings.Average(x => x.Rating);
        return 0;
    }

    private MemberRatingDto? GetMyRating(AggregatedRecipeDto r)
    {
        if (r.MemberRatings is not { Count: > 0 }) return null;

        if (_currentUserId.HasValue)
            return r.MemberRatings.FirstOrDefault(x => x.UserId == _currentUserId.Value);

        var myName = AuthService.CurrentUserName;
        if (!string.IsNullOrWhiteSpace(myName))
            return r.MemberRatings.FirstOrDefault(x => string.Equals(x.DisplayName, myName, StringComparison.OrdinalIgnoreCase));

        return null;
    }

    private int? GetMemberRating(AggregatedRecipeDto r, Guid? userId)
    {
        if (userId == null || r.MemberRatings == null) return null;
        return r.MemberRatings.FirstOrDefault(x => x.UserId == userId.Value)?.Rating;
    }

    private IEnumerable<MemberRatingDto> GetOtherRatings(AggregatedRecipeDto r)
    {
        if (r.MemberRatings == null) yield break;

        var myId = _currentUserId;

        var items = r.MemberRatings
            .Where(x => !myId.HasValue || x.UserId != myId.Value)
            .ToList();

        if (_sortMode == CookbookSort.MemberRating && _selectedMember != null)
        {
            var pinnedId = _selectedMember.UserId;
            items = items
                .OrderByDescending(x => x.UserId == pinnedId)
                .ThenByDescending(x => x.Rating)
                .ThenBy(x => x.DisplayName)
                .ToList();
        }
        else
        {
            items = items
                .OrderByDescending(x => x.Rating)
                .ThenBy(x => x.DisplayName)
                .ToList();
        }

        foreach (var x in items)
            yield return x;
    }

    private string GetInitials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return "?";
        var parts = name.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 1) return parts[0].Substring(0, 1).ToUpperInvariant();
        return $"{parts[0][0]}{parts[^1][0]}".ToUpperInvariant();
    }

    private string GetRatingClass(double rating)
        => rating switch
        {
            >= 8 => "rating-high",
            >= 5 => "rating-medium",
            _ => "rating-low"
        };

    private async Task SetViewMode(string mode)
    {
        _viewMode = mode;
        await DeviceState.SetViewModeAsync(mode);
    }

    public void Dispose()
    {
        HouseholdState.OnActiveGroupsChanged -= OnGroupsChanged;
    }

    private enum CookbookSource { All, Mine, Friends }
    private enum CookbookSort { Date, Name, AvgRating, MyRating, MemberRating }
}

<style>
    .cookbook-top { display:flex; flex-direction:column; gap:10px; margin-bottom:14px; }

    .cookbook-top-row { display:flex; gap:10px; align-items:center; }
    .cookbook-search { flex:1; min-width: 220px; }

    .cookbook-filters { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .cookbook-select { min-width: 180px; }
    .cookbook-sortdir { height: 40px; }

    .cookbook-member-autocomplete { max-width: 420px; }
    .cookbook-tags { max-width: 520px; }

    .rating-strip {
        margin-top: 10px;
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
    }

    .my-rating-chip { height: 26px; }
    .my-rating-chip.muted { opacity: .7; }

    .other-ratings { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }

    .rating-avatar { width: 26px; height: 26px; font-size: 12px; }
    .rating-avatar-badge .mud-badge { font-size: 10px; min-width: 16px; height: 16px; }
    .more-chip { height: 26px; }
</style>


================================================================================
FILE END: \StorhaugenWebsite\Pages\CookBook.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\FoodDetails.razor
================================================================================
@page "/food/{Id:guid}"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Components
@inject IUserRecipeService RecipeService
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject IApiClient ApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<div class="detail-header">
    <button class="detail-back-btn" @onclick="@(() => Navigation.NavigateTo(""))">
        <MudIcon Icon="@Icons.Material.Rounded.ArrowBack" Size="Size.Small" />
        Tilbake
    </button>
</div>

@if (_isLoading)
{
    <div class="d-flex justify-center mt-8">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
    </div>
}
else if (_recipe == null)
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Fant ikke oppskriften</h2>
        <p class="empty-state-text">
            Denne oppskriften er enten slettet, eller du har mistet tilgangen til den.
        </p>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="/">
            Tilbake til start
        </MudButton>
    </div>
}
else
{
    @* --- IMAGE CAROUSEL --- *@
    @if (_recipe.ImageUrls.Any())
    {
        <div class="detail-image-carousel">
            <MudCarousel Class="mud-width-full"
                         Style="height: 240px; border-radius: 20px;"
                         ShowArrows="@(_recipe.ImageUrls.Count > 1)"
                         ShowBullets="@(_recipe.ImageUrls.Count > 1)"
                         EnableSwipeGesture="true"
                         AutoCycle="false"
                         TData="object">
                @foreach (var imageUrl in _recipe.ImageUrls)
                {
                    <MudCarouselItem Transition="Transition.Slide" Color="@Color.Transparent">
                        <div class="d-flex" style="height:100%">
                            <MudImage Src="@imageUrl" Alt="@_recipe.Name" ObjectFit="ObjectFit.Cover" Style="width: 100%; height: 100%; border-radius: 20px;" />
                        </div>
                    </MudCarouselItem>
                }
            </MudCarousel>
        </div>
    }
    else
    {
        <div class="food-card-placeholder" style="border-radius: 20px; margin-bottom: 20px; aspect-ratio: 16/9; display:flex; align-items:center; justify-content:center; background-color: var(--mud-palette-background-grey);">
            <MudIcon Icon="@Icons.Material.Rounded.Restaurant" Size="Size.Large" Color="Color.Default" />
        </div>
    }

    @* --- INFO CARD --- *@
    <div class="detail-info-card">
        <div class="d-flex justify-space-between align-start gap-3">
            <div>
                <h1 class="detail-title">@_recipe.Name</h1>
                <div class="d-flex align-center gap-2 mt-1">
                    @if (IsOwner)
                    {
                        <MudChip T="string" Color="Color.Primary" Size="Size.Small" Variant="Variant.Text">Min oppskrift</MudChip>
                    }
                    else
                    {
                        <MudChip T="string" Color="Color.Secondary" Size="Size.Small" Icon="@Icons.Material.Rounded.Person">
                            Eies av: @_recipe.UserDisplayName
                        </MudChip>
                    }
                    <MudText Typo="Typo.caption" Color="Color.Secondary"> @_recipe.CreatedAt.ToString("dd. MMM")</MudText>
                </div>
            </div>

            @if (_recipe.AverageRating > 0)
            {
                <span class="rating-badge @GetRatingClass(_recipe.AverageRating)" style="font-size: 1rem; padding: 8px 14px;">
                    <MudIcon Icon="@Icons.Material.Rounded.Star" Size="Size.Small" />
                    @_recipe.AverageRating.ToString("0.0")
                </span>
            }
        </div>

        @if (!string.IsNullOrWhiteSpace(_recipe.Description))
        {
            <p class="detail-description mt-4">@_recipe.Description</p>
        }

        @* Link Status *@
        @if (_recipe.IsLinkedToGlobal)
        {
            <div class="recipe-source-info mt-3">
                <div class="d-flex align-center gap-2">
                    <MudIcon Icon="@Icons.Material.Rounded.Link" Color="Color.Info" Size="Size.Small" />
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Dette er en <b>Global Oppskrift</b> (@(_recipe.GlobalRecipeName)).
                        @if (!IsOwner)
                        {
                            <span>Du ser @_recipe.UserDisplayName sin versjon.</span>
                        }
                    </MudText>
                </div>
            </div>
        }
    </div>

    @* --- ACTIONS SECTION --- *@
    <div class="form-section">
        <p class="form-section-title">Handlinger</p>

        @if (IsOwner)
        {
            <div class="d-flex flex-column gap-3">

                @* --- NEW: PUBLISH LOGIC --- *@
                @if (!_recipe.IsPublished)
                {
                    @* Not Published: Show Publish Button *@
                    <div class="visibility-card">
                        <div class="d-flex align-center justify-space-between">
                            <div class="d-flex align-center gap-3">
                                <MudIcon Icon="@Icons.Material.Rounded.Public" Color="Color.Primary" />
                                <div>
                                    <MudText Typo="Typo.subtitle2">Publisering</MudText>
                                    <MudText Typo="Typo.caption">Del oppskriften med hele fellesskapet</MudText>
                                </div>
                            </div>
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="PublishRecipe" Disabled="_isProcessing">
                                Publiser
                            </MudButton>
                        </div>
                    </div>
                }
                else
                {
                    @* Published: Show Status and Unpublish Option *@
                    <div class="visibility-card" style="border: 1px solid var(--mud-palette-success); background: rgba(var(--mud-palette-success-rgb), 0.05);">
                        <div class="d-flex align-center justify-space-between">
                            <div class="d-flex align-center gap-3">
                                <MudIcon Icon="@Icons.Material.Rounded.CheckCircle" Color="Color.Success" />
                                <div>
                                    <MudText Typo="Typo.subtitle2">Publisert</MudText>
                                    <MudText Typo="Typo.caption">Tilgjengelig for alle</MudText>
                                </div>
                            </div>
                            <MudMenu Icon="@Icons.Material.Rounded.MoreVert" Size="Size.Small" AnchorOrigin="Origin.BottomRight">
                                <MudMenuItem Icon="@Icons.Material.Rounded.Delete" IconColor="Color.Error" OnClick="DeletePublishedRecipe">Slett publisert versjon</MudMenuItem>
                            </MudMenu>
                        </div>
                    </div>
                }

                @* Visibility Settings *@
                <div class="visibility-card">
                    <div class="d-flex align-center justify-space-between">
                        <div class="d-flex align-center gap-3">
                            <MudIcon Icon="@GetVisibilityIcon(_recipe.Visibility)" Color="Color.Primary" />
                            <div>
                                <MudText Typo="Typo.subtitle2">Synlighet</MudText>
                                <MudText Typo="Typo.caption">@GetVisibilityText(_recipe.Visibility)</MudText>
                            </div>
                        </div>
                        <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="ToggleVisibility">
                            Endre
                        </MudButton>
                    </div>
                </div>

                @* Edit / Archive Buttons *@
                <div class="d-flex gap-2">
                    <MudButton Variant="Variant.Outlined" Color="Color.Primary" FullWidth="true" StartIcon="@Icons.Material.Rounded.Edit" OnClick="EditRecipe">
                        Rediger
                    </MudButton>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" FullWidth="true" StartIcon="@Icons.Material.Rounded.Archive" OnClick="ArchiveRecipe">
                        Arkiver
                    </MudButton>
                </div>
            </div>
        }
        else
        {
            @* Visitor View *@
            <div class="alert-box pa-3 mb-3" style="background-color: rgba(var(--mud-palette-warning-rgb), 0.1); border-radius: 12px;">
                <div class="d-flex gap-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Info" Color="Color.Warning" />
                    <div>
                        <MudText Typo="Typo.subtitle2">Du er i lesemodus</MudText>
                        <MudText Typo="Typo.caption">
                            Dette er @_recipe.UserDisplayName sin oppskrift.
                        </MudText>
                    </div>
                </div>
            </div>

            <MudButton Variant="Variant.Filled" Color="Color.Success" FullWidth="true" Size="Size.Large" StartIcon="@Icons.Material.Rounded.SaveAlt" OnClick="SaveCopyToMyCollection" Disabled="_isProcessing">
                @if (_isProcessing)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Lagrer...</span>
         }
        else
        {
                    <span>Lagre min egen kopi</span>
                }
            </MudButton>
        }
    </div>

    @* --- NOTES & RATING --- *@
    @if (IsOwner)
    {
        <div class="form-section">
            <div class="d-flex justify-space-between align-center mb-2">
                <p class="form-section-title mb-0">Personlige Notater</p>
                <MudIconButton Icon="@Icons.Material.Rounded.Save" Size="Size.Small" Color="Color.Primary" OnClick="SaveNotes" Disabled="_isSavingNotes" />
            </div>
            <MudTextField @bind-Value="_notes" Variant="Variant.Outlined" Lines="3" Placeholder="Notater er kun synlige for deg..." Class="mb-2" />
        </div>
    }

    <div class="form-section">
        <p class="form-section-title">Vurdering</p>
        <div class="d-flex align-center gap-4">
            <MudRating SelectedValue="@(_myRating)" SelectedValueChanged="OnRatingChanged" MaxValue="10" />
            <span style="font-weight:bold; font-size: 1.2em;">@(_myRating > 0 ? _myRating.ToString() : "-")</span>
        </div>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-2">
            Din vurdering er personlig og lagres p din bruker.
        </MudText>
    </div>
}

<style>
    .detail-info-card {
        background: var(--mud-palette-surface);
        border-radius: 20px;
        padding: 20px;
        margin-bottom: 20px;
        border: 1px solid var(--mud-palette-divider);
    }

    .detail-title {
        font-family: 'Fraunces', serif;
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 4px;
    }

    .visibility-card {
        background: var(--mud-palette-background-grey);
        border-radius: 12px;
        padding: 12px;
    }
</style>

@code {
    [Parameter] public Guid Id { get; set; }

    private UserRecipeDto? _recipe;
    private bool _isLoading = true;
    private bool _isProcessing = false;
    private bool _isSavingNotes = false;
    private string _notes = "";
    private int _myRating = 0;
    private Guid _currentUserId;

    private bool IsOwner => _recipe?.UserId == _currentUserId;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var user = await ApiClient.GetMyProfileAsync();
            if (user != null) _currentUserId = user.Id;
        }
        catch { }
        await LoadRecipe();
    }

    private async Task LoadRecipe()
    {
        _isLoading = true;
        try
        {
            _recipe = await RecipeService.GetRecipeAsync(Id);
            if (_recipe != null)
            {
                _notes = _recipe.PersonalNotes ?? "";
                _myRating = _recipe.MyRating ?? 0;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add("Kunne ikke laste oppskrift", Severity.Error);
            Console.WriteLine(ex);
        }
        finally { _isLoading = false; }
    }

    // --- NEW: PUBLISH LOGIC ---
    private async Task PublishRecipe()
    {
        if (_recipe == null) return;

        // Use the existing component PublishRecipeDialog
        var parameters = new DialogParameters<PublishRecipeDialog> { { x => x.Recipe, _recipe } };
        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small, FullWidth = true };

        var dialog = await DialogService.ShowAsync<PublishRecipeDialog>("Publiser", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            await LoadRecipe(); // Reload to update UI (IsPublished will be true)
        }
    }

    private async Task DeletePublishedRecipe()
    {
        if (_recipe == null || !_recipe.GlobalRecipeId.HasValue) return;

        var confirm = await DialogService.ShowMessageBox(
            "Slett publisert versjon?",
            "Dette fjerner oppskriften fra fellesskapet. Din lokale kopi beholdes, men koblingen brytes.",
            yesText: "Slett", cancelText: "Avbryt");

        if (confirm == true)
        {
            _isProcessing = true;
            try
            {
                // 1. Detach locally first to break link
                await RecipeService.DetachRecipeAsync(_recipe.Id);

                // 2. Delete the global version using new ApiClient method
                await ApiClient.DeleteGlobalRecipeAsync(_recipe.GlobalRecipeId.Value);

                Snackbar.Add("Publisert versjon slettet.", Severity.Success);
                await LoadRecipe();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
                await LoadRecipe();
            }
            finally { _isProcessing = false; }
        }
    }
    // --------------------------

    private async Task SaveCopyToMyCollection()
    {
        if (_recipe == null) return;
        _isProcessing = true;
        try
        {
            var copyDto = new CreateUserRecipeDto
            {
                Name = $"{_recipe.Name} (Kopi)",
                Description = _recipe.Description,
                Ingredients = _recipe.Ingredients,
                ImageUrls = _recipe.ImageUrls,
                GlobalRecipeId = _recipe.GlobalRecipeId,
                Visibility = "private"
            };
            var newRecipe = await RecipeService.CreateRecipeAsync(copyDto); // [cite: 1201]
            Snackbar.Add("Kopiert!", Severity.Success);
            Navigation.NavigateTo($"food/{newRecipe.Id}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
        finally { _isProcessing = false; }
    }

    private async Task SaveNotes()
    {
        if (_recipe == null) return;
        _isSavingNotes = true;
        try
        {
            await RecipeService.UpdateRecipeAsync(_recipe.Id, new UpdateUserRecipeDto { PersonalNotes = _notes });
            Snackbar.Add("Notater lagret", Severity.Success);
        }
        catch { Snackbar.Add("Kunne ikke lagre notater", Severity.Error); }
        _isSavingNotes = false;
    }

    private async Task OnRatingChanged(int rating)
    {
        if (_recipe == null) return;
        _myRating = rating;
        try
        {
            await RecipeService.RateRecipeAsync(_recipe.Id, rating);
            Snackbar.Add("Vurdering lagret", Severity.Success);
        }
        catch { Snackbar.Add("Kunne ikke lagre vurdering", Severity.Error); }
    }

    private async Task ToggleVisibility()
    {
        if (_recipe == null) return;
        var newVisibility = _recipe.Visibility == "private" ? "household" : "private";
        try
        {
            await RecipeService.UpdateRecipeAsync(_recipe.Id, new UpdateUserRecipeDto { Visibility = newVisibility });
            _recipe.Visibility = newVisibility;
            Snackbar.Add($"Endret til {GetVisibilityText(newVisibility)}", Severity.Info);
        }
        catch { Snackbar.Add("Feil ved endring", Severity.Error); }
    }

    private async Task ArchiveRecipe()
    {
        if (_recipe == null) return;
        var confirm = await DialogService.ShowMessageBox("Arkiver", "Er du sikker?", yesText: "Arkiver", cancelText: "Avbryt");
        if (confirm == true)
        {
            await RecipeService.ArchiveRecipeAsync(_recipe.Id);
            Navigation.NavigateTo("");
        }
    }

    private void EditRecipe() => Snackbar.Add("Redigering kommer snart", Severity.Info);

    private string GetRatingClass(double r) => r >= 8 ? "rating-high" : r >= 5 ? "rating-medium" : "rating-low";
    private string GetVisibilityText(string v) => v switch { "private" => "Privat (Kun deg)", "household" => "Husstand", "public" => "Offentlig", _ => v };
    private string GetVisibilityIcon(string v) => v switch { "household" => Icons.Material.Rounded.Home, "public" => Icons.Material.Rounded.Public, _ => Icons.Material.Rounded.Lock };
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\FoodDetails.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\FriendRatings.razor
================================================================================
@page "/friends/{FriendUserId:guid}/ratings"
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.Shared.DTOs
@inject IApiClient ApiClient
@inject IUserFriendshipService FriendshipService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@attribute [Authorize]

<MudPaper Class="pa-4" Elevation="0">
    <MudButton Variant="Variant.Text" StartIcon="@Icons.Material.Rounded.ArrowBack"
               OnClick="@(() => Navigation.NavigateTo("friends"))">
        Tilbake
    </MudButton>

    @if (!_loaded)
    {
        <div class="d-flex justify-center my-6">
            <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
        </div>
    }
    else if (_friend == null)
    {
        <MudText>Fant ikke venn.</MudText>
    }
    else
    {
        <div class="d-flex align-center gap-3 my-4">
            <MudAvatar Size="Size.Large" Color="Color.Primary" Variant="Variant.Filled">
                @(_friend.DisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
            </MudAvatar>

            <div>
                <MudText Typo="Typo.h5">@_friend.DisplayName</MudText>
                <MudText Typo="Typo.caption">Vurderinger</MudText>
            </div>
        </div>

        @if (_ratings.Count == 0)
        {
            <MudText>Ingen vurderinger enn.</MudText>
        }
        else
        {
            <div class="d-flex flex-column gap-2">
                @foreach (var r in _ratings)
                {
                    string linkUrl = r.UserRecipeId.HasValue
                    ? $"food/{r.UserRecipeId}"
                    : $"browse/{r.GlobalRecipeId}";

                    <MudPaper Class="pa-3" Elevation="0" Style="cursor:pointer;"
                              @onclick="@(() => Navigation.NavigateTo(linkUrl))">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Size="Size.Medium">
                                @if (!string.IsNullOrWhiteSpace(r.ImageUrl))
                                {
                                    <img src="@r.ImageUrl" />
                                }
                                else
                                {
                                    <MudIcon Icon="@Icons.Material.Rounded.Restaurant" />
                                }
                            </MudAvatar>

                            <div class="flex-grow-1">
                                <MudText Typo="Typo.subtitle2">@r.RecipeTitle</MudText>

                                @if (!string.IsNullOrWhiteSpace(r.Comment))
                                {
                                    <MudText Typo="Typo.caption">@r.Comment</MudText>
                                }

                                <MudText Typo="Typo.caption">@r.RatedAt.ToLocalTime().ToString("dd.MM.yyyy")</MudText>
                            </div>

                            <MudChip Color="Color.Primary" T=string Variant="Variant.Filled">
                                @($"{r.Score}/10")
                            </MudChip>
                        </div>
                    </MudPaper>
                }
            </div>
        }
    }
</MudPaper>

@code {
    [Parameter] public Guid FriendUserId { get; set; }

    private FriendProfileDto? _friend;
    private List<UserRatingDto> _ratings = new();
    private bool _loaded;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            _friend = await FriendshipService.GetUserProfileAsync(FriendUserId);
            _ratings = await ApiClient.GetUserRatingsAsync(FriendUserId, skip: 0, take: 100);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste vurderinger: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loaded = true;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Pages\FriendRatings.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Friends.razor
================================================================================
@page "/friends"
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@using StorhaugenWebsite.ApiClient
@inject IUserFriendshipService FriendshipService
@inject IHouseholdStateService HouseholdState
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<div class="friends-container animate-in">
    @* --- HEADER --- *@
    <div class="d-flex justify-space-between align-center mb-4">
        <MudText Typo="Typo.h4" Style="font-family: 'Fraunces', serif;">Venner</MudText>
        @if (_friends.Any())
        {
            <MudText Typo="Typo.caption" Color="Color.Secondary">@_friends.Count venner</MudText>
        }
    </div>

    @* --- SEARCH BAR --- *@
    <MudTextField @bind-Value="_searchQuery"
                  Placeholder="Søk etter navn eller ID..."
                  Variant="Variant.Outlined"
                  Adornment="Adornment.Start"
                  AdornmentIcon="@Icons.Material.Rounded.Search"
                  OnKeyUp="OnSearchKeyUp"
                  Immediate="true"
                  DebounceInterval="500"
                  OnDebounceIntervalElapsed="PerformSearch"
                  Class="search-field mb-4"
                  Clearable="true"
                  OnClearButtonClick="@(() => _searchQuery = string.Empty)" />

    @* --- LOADING STATE --- *@
    @if (_isLoading)
    {
        <div class="d-flex flex-column gap-3">
            @for (int i = 0; i < 4; i++)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="72px" Class="rounded-lg" />
            }
        </div>
    }
    @* --- SEARCH RESULTS MODE --- *@
    else if (!string.IsNullOrWhiteSpace(_searchQuery))
    {
        <MudText Typo="Typo.subtitle2" Class="mb-2 ml-1" Color="Color.Secondary">Resultater</MudText>

        @if (_searchResults.Any())
        {
            <div class="d-flex flex-column gap-3">
                @foreach (var user in _searchResults)
                {
                    <MudPaper Class="pa-3 friend-card" Elevation="0" Outlined="true">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Color="Color.Info" Size="Size.Medium">
                                @(user.DisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body1" Style="font-weight: 600;">@user.DisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">ID: @user.ShareId</MudText>
                            </div>

                            @if (user.FriendshipStatus == "friends")
                            {
                                <MudChip T="string" Color="Color.Success" Size="Size.Small" Variant="Variant.Text" Icon="@Icons.Material.Rounded.Check">Venn</MudChip>
                            }
                            else if (user.FriendshipStatus == "pending_sent")
                            {
                                <MudChip T="string" Color="Color.Warning" Size="Size.Small" Variant="Variant.Text">Venter</MudChip>
                            }
                            else if (user.FriendshipStatus == "pending_received")
                            {
                                <MudChip T="string" Color="Color.Info" Size="Size.Small" Variant="Variant.Text">Har sendt deg</MudChip>
                            }
                            else
                            {
                                <MudIconButton Icon="@Icons.Material.Rounded.PersonAdd"
                                               Color="Color.Primary"
                                               Variant="Variant.Filled"
                                               Size="Size.Small"
                                               OnClick="@(() => SendFriendRequest(user))" />
                            }
                        </div>
                    </MudPaper>
                }
            </div>
        }
        else if (!_isSearching)
        {
            <div class="empty-state">
                <MudIcon Icon="@Icons.Material.Rounded.SearchOff" Size="Size.Large" Color="Color.Default" />
                <MudText Typo="Typo.body1" Class="mt-2">Ingen brukere funnet</MudText>
            </div>
        }
    }
    else
    {
        @* --- STANDARD LIST MODE --- *@

        @* 1. INCOMING REQUESTS *@
        @if (_pendingReceived.Any())
        {
            <div class="section-header">
                <MudIcon Icon="@Icons.Material.Rounded.MarkEmailUnread" Size="Size.Small" Color="Color.Primary" />
                <MudText Typo="Typo.subtitle2" Color="Color.Primary">Forespørsler</MudText>
            </div>

            <div class="d-flex flex-column gap-2 mb-6">
                @foreach (var request in _pendingReceived)
                {
                    <MudPaper Class="pa-3 friend-card request-card" Elevation="0">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Color="Color.Secondary" Size="Size.Medium">
                                @(request.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body2" Style="font-weight: 600;">@request.FriendDisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">Vil bli venn med deg</MudText>
                            </div>
                        </div>
                        <div class="d-flex gap-2 mt-3">
                            <MudButton Variant="Variant.Filled" Color="Color.Success" Size="Size.Small" FullWidth="true" OnClick="@(() => AcceptRequest(request))">Godta</MudButton>
                            <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" FullWidth="true" OnClick="@(() => RejectRequest(request))">Avslå</MudButton>
                        </div>
                    </MudPaper>
                }
            </div>
        }

        @* 2. FRIENDS LIST *@
        @if (_friends.Any())
        {
            <div class="d-flex flex-column gap-2">
                @foreach (var friend in _friends)
                {
                    <MudPaper Class="pa-3 friend-card" Elevation="0" @onclick="@(() => OpenFriendProfile(friend))">
                        <div class="d-flex align-center gap-3">
                            <MudAvatar Color="Color.Primary" Size="Size.Medium" Variant="Variant.Filled">
                                @(friend.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                            </MudAvatar>
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.body1" Style="font-weight: 600;">@friend.FriendDisplayName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @friend.RecipeCount oppskrifter
                                </MudText>
                            </div>

                            @* --- FRIEND MENU --- *@
                            <MudMenu Icon="@Icons.Material.Rounded.MoreVert" Size="Size.Small" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight" @onclick:stopPropagation="true">
                                <MudMenuItem Icon="@Icons.Material.Rounded.Person" OnClick="@(() => OpenFriendProfile(friend))">Se profil</MudMenuItem>

                                @* --- INVITE TO HOUSEHOLD ACTION --- *@
                                <MudMenuItem Icon="@Icons.Material.Rounded.GroupAdd" IconColor="Color.Success" OnClick="@(() => InviteFriendToMyHousehold(friend))">
                                    Inviter til min husstand
                                </MudMenuItem>

                                <MudDivider />
                                <MudMenuItem Icon="@Icons.Material.Rounded.PersonRemove" IconColor="Color.Error" OnClick="@(() => RemoveFriend(friend))">Fjern venn</MudMenuItem>
                            </MudMenu>
                        </div>
                    </MudPaper>
                }
            </div>
        }
        else if (!_pendingReceived.Any() && !_pendingSent.Any())
        {
            <div class="empty-state mt-8">
                <MudIcon Icon="@Icons.Material.Rounded.PersonSearch" Size="Size.Large" Color="Color.Default" />
                <MudText Typo="Typo.h6" Class="mt-2">Ingen venner ennå</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Style="max-width: 250px;">
                    Søk etter brukernavn eller ID i feltet over for å legge til venner.
                </MudText>
            </div>
        }

        @* 3. OUTGOING REQUESTS (Collapsed) *@
        @if (_pendingSent.Any())
        {
            <MudExpansionPanel Text="@($"Sendte forespørsler ({_pendingSent.Count})")" Class="mt-6 shadow-none bg-transparent" DisableGutters="true">
                <div class="d-flex flex-column gap-2 mt-2">
                    @foreach (var request in _pendingSent)
                    {
                        <MudPaper Class="pa-3 friend-card" Elevation="0" Outlined="true" Style="opacity: 0.8;">
                            <div class="d-flex align-center gap-3">
                                <MudAvatar Color="Color.Default" Size="Size.Small">
                                    @(request.FriendDisplayName?.FirstOrDefault().ToString().ToUpper() ?? "?")
                                </MudAvatar>
                                <div class="flex-grow-1">
                                    <MudText Typo="Typo.body2">@request.FriendDisplayName</MudText>
                                    <MudText Typo="Typo.caption" Color="Color.Secondary">Venter...</MudText>
                                </div>
                                <MudIconButton Icon="@Icons.Material.Rounded.Close" Size="Size.Small" OnClick="@(() => CancelRequest(request))" />
                            </div>
                        </MudPaper>
                    }
                </div>
            </MudExpansionPanel>
        }
    }
</div>

<style>
    .friend-card {
        background: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-divider);
        border-radius: 16px;
        transition: transform 0.2s, background-color 0.2s;
        cursor: pointer;
    }

        .friend-card:hover {
            background-color: var(--mud-palette-background-grey);
        }

        .friend-card:active {
            transform: scale(0.98);
        }

    .request-card {
        background: rgba(var(--mud-palette-primary-rgb), 0.05);
        border-color: rgba(var(--mud-palette-primary-rgb), 0.2);
    }

    .section-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        padding-left: 4px;
    }

    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        opacity: 0.7;
        padding: 40px 20px;
    }
</style>

@code {
    private List<UserFriendshipDto> _friends = new();
    private List<UserFriendshipDto> _pendingReceived = new();
    private List<UserFriendshipDto> _pendingSent = new();
    private List<UserSearchResultDto> _searchResults = new();

    private string _searchQuery = "";
    private bool _isLoading = true;
    private bool _isSearching = false;

    protected override async Task OnInitializedAsync()
    {
        await HouseholdState.InitializeAsync();
        await LoadFriendships();
    }

    private async Task LoadFriendships()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var friendships = await FriendshipService.GetFriendshipsAsync();
            _friends = friendships.Friends ?? new();
            _pendingReceived = friendships.PendingReceived ?? new();
            _pendingSent = friendships.PendingSent ?? new();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke laste venner: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery))
        {
            _searchResults.Clear();
            StateHasChanged();
            return;
        }

        _isSearching = true;
        StateHasChanged();

        try
        {
            _searchResults = await FriendshipService.SearchUsersAsync(_searchQuery);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Søk feilet: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSearching = false;
            StateHasChanged();
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs args)
    {
        if (args.Key == "Enter") await PerformSearch();
    }

    private async Task SendFriendRequest(UserSearchResultDto user)
    {
        try
        {
            await FriendshipService.SendFriendRequestAsync(user.Id);
            user.FriendshipStatus = "pending_sent"; // Optimistic update
            Snackbar.Add($"Forespørsel sendt til {user.DisplayName}", Severity.Success);

            // Reload in background to sync state properly
            _ = LoadFriendships();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunne ikke sende forespørsel: {ex.Message}", Severity.Error);
        }
    }

    private async Task AcceptRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.AcceptFriendRequestAsync(request.Id);
            Snackbar.Add($"Du er nå venn med {request.FriendDisplayName}!", Severity.Success);
            await LoadFriendships();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Feil: {ex.Message}", Severity.Error);
        }
    }

    private async Task RejectRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.RejectFriendRequestAsync(request.Id);
            _pendingReceived.Remove(request);
            StateHasChanged();
        }
        catch
        {
            Snackbar.Add("Kunne ikke avslå", Severity.Error);
        }
    }

    private async Task CancelRequest(UserFriendshipDto request)
    {
        try
        {
            await FriendshipService.RemoveFriendAsync(request.Id);
            _pendingSent.Remove(request);
            StateHasChanged();
            Snackbar.Add("Forespørsel kansellert", Severity.Info);
        }
        catch
        {
            Snackbar.Add("Kunne ikke kansellere", Severity.Error);
        }
    }

    private async Task RemoveFriend(UserFriendshipDto friend)
    {
        var confirm = await DialogService.ShowMessageBox(
            "Fjern venn",
            $"Er du sikker på at du vil fjerne {friend.FriendDisplayName}?",
            yesText: "Fjern", cancelText: "Avbryt");

        if (confirm == true)
        {
            try
            {
                await FriendshipService.RemoveFriendAsync(friend.Id);
                _friends.Remove(friend);
                StateHasChanged();
                Snackbar.Add($"{friend.FriendDisplayName} fjernet", Severity.Info);
            }
            catch
            {
                Snackbar.Add("Kunne ikke fjerne venn", Severity.Error);
            }
        }
    }

    private void OpenFriendProfile(UserFriendshipDto friend)
    {
        Navigation.NavigateTo($"friends/{friend.FriendUserId}/ratings");
    }

    // --- NEW: Invite Friend to Household Logic ---
    private async Task InviteFriendToMyHousehold(UserFriendshipDto friend)
    {
        // 1. Check if user has a household
        if (!HouseholdState.HasHousehold || HouseholdState.CurrentHousehold == null)
        {
            Snackbar.Add("Du må være medlem av en husstand for å invitere.", Severity.Warning);
            return;
        }

        var householdName = HouseholdState.CurrentHousehold.Name;

        // 2. Confirm action
        var confirm = await DialogService.ShowMessageBox(
            "Inviter til husstand",
            $"Vil du invitere {friend.FriendDisplayName} til å bli medlem av {householdName}?",
            yesText: "Inviter", cancelText: "Avbryt");

        if (confirm == true)
        {
            try
            {
                var inviteDto = new InviteToHouseholdDto
                {
                    UniqueShareId = friend.FriendShareId // Using ShareID to lookup user
                };

                await ApiClient.InviteToHouseholdAsync(HouseholdState.CurrentHousehold.Id, inviteDto);

                Snackbar.Add($"Invitasjon sendt til {friend.FriendDisplayName}!", Severity.Success);
            }
            catch (Exception ex)
            {
                if (ex.Message.Contains("already a member"))
                    Snackbar.Add($"{friend.FriendDisplayName} er allerede medlem.", Severity.Info);
                else if (ex.Message.Contains("already pending"))
                    Snackbar.Add("Invitasjon er allerede sendt.", Severity.Warning);
                else
                    Snackbar.Add($"Kunne ikke sende invitasjon: {ex.Message}", Severity.Error);
            }
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Friends.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Home.razor
================================================================================
@page "/"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.Components
@using StorhaugenWebsite.Services
@inject IAuthService AuthService
@inject NavigationManager Navigation
@attribute [Authorize]

<div class="home-container">
    @* --- ACTION GRID --- *@
    <div class="action-grid mb-8">
        <div class="action-card variant-primary" @onclick="@(() => Navigation.NavigateTo("add"))">
            <div class="card-content">
                <div class="action-icon-circle mb-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Add" />
                </div>
                <div class="action-text">
                    <MudText Typo="Typo.h6" Class="font-weight-bold" Style="line-height: 1.2;">Logg middag</MudText>
                    <MudText Typo="Typo.body2" Style="opacity: 0.9;">Hva spiste dere?</MudText>
                </div>
            </div>
            <div class="watermark-container">
                <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Class="watermark-icon" />
            </div>
        </div>

        <div class="action-card variant-surface" @onclick="@(() => Navigation.NavigateTo("browse"))">
            <div class="card-content">
                <div class="action-icon-circle surface-icon mb-3">
                    <MudIcon Icon="@Icons.Material.Rounded.Public" />
                </div>
                <div class="action-text">
                    <MudText Typo="Typo.h6" Class="font-weight-bold" Style="line-height: 1.2;">Utforsk</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Finn nye oppskrifter</MudText>
                </div>
            </div>
            <div class="watermark-container surface-watermark-container">
                <MudIcon Icon="@Icons.Material.Rounded.TravelExplore" Class="watermark-icon" />
            </div>
        </div>
    </div>

    @* --- ACTIVITY FEED --- *@
    <div class="feed-section">
        <div class="d-flex align-center gap-2 mb-3">
            <MudIcon Icon="@Icons.Material.Rounded.History" Color="Color.Secondary" Size="Size.Small" />
            <MudText Typo="Typo.subtitle2" Color="Color.Secondary" Style="text-transform: uppercase; letter-spacing: 1px; font-weight: 700;">
                Siste Nytt
            </MudText>
        </div>

        <ActivityFeed PageSize="10" />
    </div>
</div>

<style>
    .home-container {
        padding-bottom: 80px;
    }

    .action-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
    }

    /* --- Base Card Styles --- */
    .action-card {
        position: relative;
        border-radius: 24px;
        padding: 20px;
        height: 160px;
        display: flex;
        cursor: pointer;
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
        overflow: hidden;
        border: 1px solid transparent;
    }

        .action-card:active {
            transform: scale(0.96);
        }

    .card-content {
        position: relative;
        z-index: 2;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: flex-start; /* Align content to the top */
        align-items: flex-start;
    }

    /* --- Variant: Primary (Orange Gradient) --- */
    .action-card.variant-primary {
        background: linear-gradient(135deg, #E07A2E 0%, #C56820 100%);
        color: white;
        box-shadow: 0 8px 20px rgba(224, 122, 46, 0.3);
    }

        .action-card.variant-primary .action-icon-circle {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .action-card.variant-primary .watermark-icon {
            color: white;
            opacity: 0.3;
        }

    /* --- Variant: Surface (Standard) --- */
    .action-card.variant-surface {
        background: var(--mud-palette-surface);
        border-color: var(--mud-palette-divider);
        box-shadow: 0 4px 12px rgba(0,0,0,0.03);
    }

        .action-card.variant-surface .action-icon-circle {
            background: rgba(var(--mud-palette-info-rgb), 0.1);
            color: var(--mud-palette-info);
        }

        .action-card.variant-surface .watermark-icon {
            color: var(--mud-palette-text-secondary);
            opacity: 0.15;
        }

    /* --- Icon Styles --- */
    .action-icon-circle {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
    }

    /* --- Watermark & Gradient Flow --- */
    .watermark-container {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 60%;
        overflow: hidden;
        z-index: 1;
        /* Creates the transparent gradient mask effect */
        -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0.1) 80%, rgba(0,0,0,0) 100%);
        mask-image: linear-gradient(to left, rgba(0,0,0,1) 20%, rgba(0,0,0,0.1) 80%, rgba(0,0,0,0) 100%);
        border-radius: 0 24px 24px 0;
    }

    .surface-watermark-container {
        /* Slightly different mask for lighter background */
        -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,1) 10%, rgba(0,0,0,0.05) 70%, rgba(0,0,0,0) 100%);
        mask-image: linear-gradient(to left, rgba(0,0,0,1) 10%, rgba(0,0,0,0.05) 70%, rgba(0,0,0,0) 100%);
    }

    .watermark-icon {
        position: absolute;
        top: 50%;
        right: -20px;
        transform: translateY(-50%) rotate(-10deg) scale(1.2);
        font-size: 140px !important;
        pointer-events: none;
        transition: transform 0.3s ease-out, right 0.3s ease-out;
    }

    .action-card:hover .watermark-icon {
        transform: translateY(-50%) rotate(0deg) scale(1.3);
        right: -10px;
    }
</style>

@code {
    protected override async Task OnInitializedAsync()
    {
        if (!AuthService.IsAuthenticated) return;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Home.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Household.razor
================================================================================
@page "/households"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Shared.DTOs
@using StorhaugenWebsite.Services
@inject IApiClient ApiClient
@inject IHouseholdStateService HouseholdState
@inject IAuthService AuthService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<div class="d-flex justify-space-between align-center mb-6">
    <div>
        <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Mine Grupper</h1>
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Du er medlem av @HouseholdState.UserHouseholds.Count grupper
        </MudText>
    </div>
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Rounded.Add"
               OnClick="CreateHousehold">
        Ny Gruppe
    </MudButton>
</div>

@* --- PENDING INVITES SECTION --- *@
@if (_pendingInvites.Any())
{
    <div class="mb-6 animate-in">
        <MudText Typo="Typo.subtitle2" Class="mb-2" Color="Color.Warning">Invitasjoner</MudText>
        <div class="d-flex flex-column gap-2">
            @foreach (var invite in _pendingInvites)
            {
                <MudPaper Class="pa-4" Elevation="0" Style="background: rgba(var(--mud-palette-warning-rgb), 0.05); border: 1px solid rgba(var(--mud-palette-warning-rgb), 0.2); border-radius: 12px;">
                    <div class="d-flex align-center justify-space-between">
                        <div>
                            <MudText Typo="Typo.subtitle2" Style="font-weight: 600;">@invite.HouseholdName</MudText>
                            <MudText Typo="Typo.caption">Invitert av @invite.InvitedByName</MudText>
                        </div>
                        <div class="d-flex gap-2">
                            <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Success" OnClick="@(() => AcceptInvite(invite))">Godta</MudButton>
                            <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Error" OnClick="@(() => RejectInvite(invite))">Avsl</MudButton>
                        </div>
                    </div>
                </MudPaper>
            }
        </div>
    </div>
}

@* --- GROUPS LIST --- *@
@if (!HouseholdState.UserHouseholds.Any())
{
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.GroupOff" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Ingen grupper enn</h2>
        <p class="empty-state-text">Opprett en gruppe for  dele oppskrifter med familien eller kollektivet.</p>
    </div>
}
else
{
    <div class="d-flex flex-column gap-4">
        @foreach (var household in HouseholdState.UserHouseholds)
        {
            <MudPaper Class="pa-4 group-card" Elevation="0">
                <div class="d-flex align-start justify-space-between mb-3">
                    <div class="d-flex align-center gap-3">
                        <MudAvatar Color="Color.Primary" Variant="Variant.Filled" Size="Size.Medium">
                            @(household.Name.FirstOrDefault().ToString().ToUpper())
                        </MudAvatar>
                        <div>
                            <MudText Typo="Typo.h6" Style="font-size: 1.1rem; font-weight: 600;">@household.Name</MudText>
                            <div class="d-flex align-center gap-2">
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    @household.Members.Count medlemmer
                                </MudText>
                                @if (household.CreatedById == _currentUserId)
                                {
                                    <MudChip T="string" Size="Size.Small" Color="Color.Tertiary" Variant="Variant.Text" Class="ml-2">Admin</MudChip>
                                }
                            </div>
                        </div>
                    </div>

                    @if (household.CreatedById == _currentUserId)
                    {
                        <MudMenu Icon="@Icons.Material.Rounded.Settings" Size="Size.Small" AnchorOrigin="Origin.BottomRight">
                            <MudMenuItem Icon="@Icons.Material.Rounded.Edit" OnClick="@(() => EditHouseholdName(household))">Endre navn</MudMenuItem>
                            <MudMenuItem Icon="@Icons.Material.Rounded.ContentCopy" OnClick="@(() => CopyShareId(household.UniqueShareId))">Kopier ID</MudMenuItem>
                            <MudMenuItem Icon="@Icons.Material.Rounded.Refresh" OnClick="@(() => RegenerateShareId(household.Id))">Ny ID</MudMenuItem>
                        </MudMenu>
                    }
                </div>

                <div class="d-flex gap-2 mt-4">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               Size="Size.Small"
                               StartIcon="@Icons.Material.Rounded.PersonAdd"
                               OnClick="@(() => InviteMember(household))"
                               FullWidth="true"
                               Style="border-radius: 8px;">
                        Inviter
                    </MudButton>

                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Default"
                               Size="Size.Small"
                               OnClick="@(() => ViewMembers(household))"
                               FullWidth="true"
                               Style="border-radius: 8px;">
                        Medlemmer
                    </MudButton>
                </div>
            </MudPaper>
        }
    </div>
}

@* --- EDIT NAME DIALOG (Simple inline replacement) --- *@
<MudDialog @bind-IsVisible="_showEditDialog" Options="new DialogOptions { MaxWidth = MaxWidth.ExtraSmall, FullWidth = true }">
    <TitleContent>Endre navn</TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_editingName" Label="Gruppenavn" Variant="Variant.Outlined" AutoFocus="true" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@(() => _showEditDialog = false)">Avbryt</MudButton>
        <MudButton Color="Color.Primary" OnClick="SaveHouseholdName">Lagre</MudButton>
    </DialogActions>
</MudDialog>

<style>
    .group-card {
        background: var(--mud-palette-surface);
        border: 1px solid var(--mud-palette-divider);
        border-radius: 16px;
        transition: transform 0.2s;
    }

    .empty-state {
        text-align: center;
        padding: 40px 20px;
        opacity: 0.8;
    }

    .empty-state-icon {
        background: var(--mud-palette-background-grey);
        width: 80px;
        height: 80px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        color: var(--mud-palette-text-secondary);
    }
</style>

@code {
    private Guid _currentUserId;
    private List<HouseholdInviteDto> _pendingInvites = new();

    // Edit State
    private bool _showEditDialog;
    private string _editingName = "";
    private Guid _editingHouseholdId;

    protected override async Task OnInitializedAsync()
    {
        // 1. Ensure Auth
        var user = await ApiClient.GetMyProfileAsync();
        if (user != null) _currentUserId = user.Id;

        // 2. Refresh State
        await HouseholdState.InitializeAsync(force: true);

        // 3. Load Invites
        await LoadInvites();
    }

    private async Task LoadInvites()
    {
        try
        {
            _pendingInvites = await ApiClient.GetPendingInvitesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    private async Task CreateHousehold()
    {
        var dialog = await DialogService.ShowAsync<StorhaugenWebsite.Components.HouseholdSelector>("Opprett gruppe", new DialogParameters(), new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true });
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await HouseholdState.RefreshHouseholdsAsync(); // [cite: 3154]
            Snackbar.Add("Ny gruppe opprettet!", Severity.Success);
        }
    }

    private async Task InviteMember(HouseholdDto household)
    {
        var parameters = new DialogParameters
        {
            { "HouseholdId", household.Id },
            { "HouseholdName", household.Name }
        };
        await DialogService.ShowAsync<StorhaugenWebsite.Components.InviteMemberDialog>("Inviter", parameters);
    }

    private async Task ViewMembers(HouseholdDto household)
    {
        var parameters = new DialogParameters { { "Household", household } };
        await DialogService.ShowAsync<StorhaugenWebsite.Components.HouseholdMembersDialog>("Medlemmer", parameters);
    }

    // --- Actions ---

    private void EditHouseholdName(HouseholdDto household)
    {
        _editingHouseholdId = household.Id;
        _editingName = household.Name;
        _showEditDialog = true;
    }

    private async Task SaveHouseholdName()
    {
        if (string.IsNullOrWhiteSpace(_editingName)) return;

        try
        {
            await ApiClient.UpdateHouseholdNameAsync(_editingHouseholdId, new UpdateHouseholdDto { Name = _editingName });
            await HouseholdState.RefreshHouseholdsAsync();
            _showEditDialog = false;
            Snackbar.Add("Navn oppdatert", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Kunne ikke endre navn", Severity.Error);
        }
    }

    private async Task CopyShareId(string? shareId)
    {
        if (string.IsNullOrEmpty(shareId)) return;
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareId);
        Snackbar.Add("ID kopiert til utklippstavlen", Severity.Success);
    }

    private async Task RegenerateShareId(Guid householdId)
    {
        var confirm = await DialogService.ShowMessageBox("Ny ID?", "Den gamle ID-en vil slutte  virke.", yesText: "Lag ny", cancelText: "Avbryt");
        if (confirm == true)
        {
            await ApiClient.RegenerateHouseholdShareIdAsync(householdId);
            await HouseholdState.RefreshHouseholdsAsync();
            Snackbar.Add("Ny ID generert", Severity.Success);
        }
    }

    // --- Invites ---

    private async Task AcceptInvite(HouseholdInviteDto invite)
    {
        try
        {
            await ApiClient.AcceptInviteAsync(invite.Id); //
            await HouseholdState.RefreshHouseholdsAsync();
            _pendingInvites.Remove(invite);
            Snackbar.Add($"Du ble med i {invite.HouseholdName}!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Feil ved godkjenning", Severity.Error);
        }
    }

    private async Task RejectInvite(HouseholdInviteDto invite)
    {
        try
        {
            await ApiClient.RejectInviteAsync(invite.Id); //
            _pendingInvites.Remove(invite);
        }
        catch
        {
            Snackbar.Add("Feil ved avvisning", Severity.Error);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Household.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Login.razor
================================================================================
@page "/login"
@using StorhaugenWebsite.Services
@using System.ComponentModel.DataAnnotations
@using System.Text.Json
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<div class="login-container">
    <div class="login-card animate-in">
        <div class="login-logo">
            <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Size="Size.Large" />
        </div>

        <h1 class="login-title">Storhaugen Eats</h1>
        <p class="login-subtitle">Sporing av familiemiddager gjort enkelt</p>

        @* --- ALERTS --- *@
        @if (!string.IsNullOrEmpty(_errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mb-4" Dense="true" ShowCloseIcon="true" CloseIconClicked="() => _errorMessage = null">
                @_errorMessage
            </MudAlert>
        }

        @if (!string.IsNullOrEmpty(_successMessage))
        {
            <MudAlert Severity="Severity.Success" Class="mb-4" Variant="Variant.Filled" Dense="true">
                <MudText Typo="Typo.body2">@_successMessage</MudText>
            </MudAlert>
        }

        @* --- FORM AREA --- *@
        <div class="form-content">
            @if (_isLoginMode)
            {
                // *** LOGIN FORM ***
                <MudForm @ref="_loginForm" @bind-IsValid="_loginValid" @onkeydown="@(e => HandleEnterKey(e))">
                    <MudTextField @bind-Value="_email"
                                  Label="E-post"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Email"
                                  Required="true"
                                  RequiredError="E-post er pkrevd"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_password"
                                  Label="Passord"
                                  Variant="Variant.Outlined"
                                  InputType="@_passwordInputType"
                                  Adornment="Adornment.End"
                                  AdornmentIcon="@_passwordInputIcon"
                                  OnAdornmentClick="TogglePasswordVisibility"
                                  Required="true"
                                  RequiredError="Passord er pkrevd"
                                  Immediate="true"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="DoEmailLogin"
                               Disabled="@(_isLoading || !_loginValid)"
                               Class="login-action-btn">
                        @if (_isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Logger inn...</span>
                        }
                        else
                        {
                            <span>Logg inn</span>
                        }
                    </MudButton>
                </MudForm>

                <div class="toggle-mode-text mt-4">
                    Har du ikke bruker? <a href="#" @onclick:preventDefault @onclick="ToggleMode" class="text-link">Opprett konto</a>
                </div>
            }
            else
            {
                // *** REGISTER FORM ***
                <MudForm @ref="_registerForm" @bind-IsValid="_registerValid" @onkeydown="@(e => HandleEnterKey(e))">
                    <MudTextField @bind-Value="_regDisplayName"
                                  Label="Navn"
                                  Variant="Variant.Outlined"
                                  Required="true"
                                  RequiredError="Navn er pkrevd"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_regEmail"
                                  Label="E-post"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Email"
                                  Required="true"
                                  RequiredError="E-post er pkrevd"
                                  Validation="@(new EmailAddressAttribute() { ErrorMessage = "Ugyldig e-post" })"
                                  Immediate="true"
                                  Class="mb-3" />

                    <MudTextField @bind-Value="_regPassword"
                                  Label="Passord"
                                  Variant="Variant.Outlined"
                                  InputType="@_passwordInputType"
                                  Adornment="Adornment.End"
                                  AdornmentIcon="@_passwordInputIcon"
                                  OnAdornmentClick="TogglePasswordVisibility"
                                  Required="true"
                                  RequiredError="Passord er pkrevd"
                                  HelperText="Minst 6 tegn"
                                  Immediate="true"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Secondary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="DoEmailRegister"
                               Disabled="@(_isLoading || !_registerValid)"
                               Class="login-action-btn">
                        @if (_isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Registrerer...</span>
                        }
                        else
                        {
                            <span>Opprett konto</span>
                        }
                    </MudButton>
                </MudForm>

                <div class="toggle-mode-text mt-4">
                    Har du allerede bruker? <a href="#" @onclick:preventDefault @onclick="ToggleMode" class="text-link">Logg inn</a>
                </div>
            }
        </div>

        <div class="divider-text mt-6 mb-4">ELLER</div>

        <button class="google-btn" @onclick="DoGoogleLogin" disabled="@_isLoading">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4" />
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853" />
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05" />
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335" />
            </svg>
            <span>Fortsett med Google</span>
        </button>
    </div>
</div>

<style>
    .login-action-btn {
        border-radius: 12px;
        height: 48px;
        text-transform: none;
        font-weight: 600;
        font-family: 'DM Sans', sans-serif;
    }

    .text-link {
        color: var(--mud-palette-primary);
        font-weight: 600;
        text-decoration: none;
    }

        .text-link:hover {
            text-decoration: underline;
        }

    .toggle-mode-text {
        font-size: 0.9rem;
        color: var(--mud-palette-text-secondary);
    }

    .google-btn {
        width: 100%;
        padding: 12px 24px;
        border-radius: 12px;
        border: 1px solid var(--mud-palette-divider);
        background: var(--mud-palette-surface);
        color: var(--mud-palette-text-primary);
        font-weight: 500;
        font-size: 0.95rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        transition: background-color 0.2s;
        font-family: 'DM Sans', system-ui, sans-serif;
    }

        .google-btn:hover {
            background-color: var(--mud-palette-background-grey);
        }

    .divider-text {
        display: flex;
        align-items: center;
        color: var(--mud-palette-text-secondary);
        font-size: 0.8rem;
        font-weight: 600;
    }

        .divider-text::before, .divider-text::after {
            content: "";
            flex: 1;
            height: 1px;
            background: var(--mud-palette-divider);
        }

        .divider-text::before {
            margin-right: 10px;
        }

        .divider-text::after {
            margin-left: 10px;
        }
</style>

@code {
    private bool _isLoading = false;
    private string? _errorMessage;
    private string? _successMessage;

    // Toggle state: true = Login, false = Register
    private bool _isLoginMode = true;

    // Login Fields
    private MudForm? _loginForm;
    private bool _loginValid;
    private string _email = "";
    private string _password = "";

    // Register Fields
    private MudForm? _registerForm;
    private bool _registerValid;
    private string _regEmail = "";
    private string _regPassword = "";
    private string _regDisplayName = "";

    // Password Visibility
    private bool _passwordVisible;
    private InputType _passwordInputType = InputType.Password;
    private string _passwordInputIcon = Icons.Material.Filled.VisibilityOff;

    protected override async Task OnInitializedAsync()
    {
        await AuthService.InitializeAsync();
        if (AuthService.IsAuthorized)
        {
            Navigation.NavigateTo("");
        }
    }

    private void ToggleMode()
    {
        _isLoginMode = !_isLoginMode;
        _errorMessage = null;
        _successMessage = null;
    }

    private void TogglePasswordVisibility()
    {
        if (_passwordVisible)
        {
            _passwordVisible = false;
            _passwordInputIcon = Icons.Material.Filled.VisibilityOff;
            _passwordInputType = InputType.Password;
        }
        else
        {
            _passwordVisible = true;
            _passwordInputIcon = Icons.Material.Filled.Visibility;
            _passwordInputType = InputType.Text;
        }
    }

    private async Task DoEmailLogin()
    {
        await _loginForm!.Validate();
        if (!_loginValid) return;

        _isLoading = true;
        _errorMessage = null;
        _successMessage = null;

        var (success, error) = await AuthService.SignInWithEmailAsync(_email, _password);

        _isLoading = false;

        if (success)
        {
            Navigation.NavigateTo("");
        }
        else
        {
            _errorMessage = CleanErrorMessage(error);
        }
    }

    private async Task DoEmailRegister()
    {
        await _registerForm!.Validate();
        if (!_registerValid) return;

        _isLoading = true;
        _errorMessage = null;
        _successMessage = null;

        var (success, error) = await AuthService.SignUpWithEmailAsync(_regEmail, _regPassword, _regDisplayName);

        _isLoading = false;

        if (success)
        {
            // If explicit error message returned (like "Check your email"), treat it as success message
            if (!string.IsNullOrEmpty(error))
            {
                // Explicitly warn the user about email confirmation
                _successMessage = "Konto opprettet! Du m bekrefte e-postadressen din fr du kan logge inn. Sjekk innboksen din.";

                // Clear inputs and switch to login mode so they can login after confirming
                _regEmail = "";
                _regPassword = "";
                _regDisplayName = "";
                _isLoginMode = true;
            }
            else
            {
                // Immediate login success (Auto confirm enabled)
                Navigation.NavigateTo("");
            }
        }
        else
        {
            _errorMessage = CleanErrorMessage(error);
        }
    }

    private async Task DoGoogleLogin()
    {
        _isLoading = true;
        var (success, error) = await AuthService.LoginAsync();
        if (!success)
        {
            _errorMessage = CleanErrorMessage(error);
            _isLoading = false;
        }
    }

    private async Task HandleEnterKey(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (_isLoginMode) await DoEmailLogin();
            else await DoEmailRegister();
        }
    }

    // Helper to make Supabase JSON errors readable
    private string CleanErrorMessage(string? error)
    {
        if (string.IsNullOrEmpty(error)) return "En ukjent feil oppstod.";

        // Try to parse JSON if it looks like JSON
        if (error.Trim().StartsWith("{"))
        {
            try
            {
                using var doc = JsonDocument.Parse(error);
                var root = doc.RootElement;

                // Look for "error_code" or "msg"
                if (root.TryGetProperty("error_code", out var codeElement))
                {
                    var code = codeElement.GetString();
                    if (code == "email_not_confirmed") return "E-posten er ikke bekreftet. Sjekk innboksen din.";
                    if (code == "invalid_credentials") return "Feil e-post eller passord.";
                }

                if (root.TryGetProperty("msg", out var msgElement))
                {
                    return msgElement.GetString() ?? error;
                }
            }
            catch
            {
                // If parsing fails, just return original or a fallback
            }
        }

        // Common text fallbacks
        if (error.Contains("Invalid login credentials")) return "Feil e-post eller passord.";
        if (error.Contains("User already registered")) return "Denne e-posten er allerede i bruk.";

        return error;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Login.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\NotFound.razor
================================================================================
@page "/not-found"
@using StorhaugenWebsite.Shared
@layout MainLayout

<h3>Not Found</h3>
<p>Sorry, the content you are looking for does not exist.</p>


================================================================================
FILE END: \StorhaugenWebsite\Pages\NotFound.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Pages\Settings.razor
================================================================================
@page "/settings"
@using Microsoft.AspNetCore.Authorization
@using StorhaugenWebsite.ApiClient
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Shared.DTOs
@inject IAuthService AuthService
@inject IDeviceStateService DeviceState
@inject IHouseholdStateService HouseholdState
@inject IApiClient ApiClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject IThemeService ThemeService
@attribute [Authorize]


<div class="d-flex align-center gap-3 mb-6">
    <h1 class="page-title" style="margin-bottom: 0; font-size: 1.5rem;">Innstillinger</h1>
</div>

<div class="form-section">
    <p class="form-section-title">Konto</p>

    <div class="setting-row">
        <div class="d-flex align-center gap-3">
            <MudAvatar Size="Size.Medium" Style="@($"background: {GetMemberColor(AuthService.CurrentUserName ?? "")}")">
                @(string.IsNullOrEmpty(AuthService.CurrentUserName) ? '?' : AuthService.CurrentUserName[0])
            </MudAvatar>
            <div>
                <MudText Typo="Typo.body1" Style="font-weight: 500;">@AuthService.CurrentUserName</MudText>
                <MudText Typo="Typo.caption" Color="Color.Secondary">@AuthService.CurrentUserEmail</MudText>
            </div>
        </div>
    </div>

    <div class="mt-4">
        <MudTextField @bind-Value="_editDisplayName"
                      Label="Brukernavn"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Save"
                      OnAdornmentClick="UpdateDisplayName"
                      HelperText="Trykk p lagre-ikonet for  oppdatere navnet ditt" />
    </div>

    @if (!string.IsNullOrEmpty(_userProfile?.UniqueShareId))
    {
        <div class="setting-row" style="padding: 12px 0;">
            <div class="d-flex align-center justify-space-between" style="width: 100%;">
                <div>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Din personlige ID</MudText>
                    <MudText Typo="Typo.h6" Style="font-family: monospace; letter-spacing: 2px; font-weight: 600;">
                        @_userProfile.UniqueShareId
                    </MudText>
                </div>
                <MudIconButton Icon="@Icons.Material.Rounded.ContentCopy"
                               Size="Size.Small"
                               Color="Color.Primary"
                               OnClick="CopyShareId"
                               Title="Kopier ID" />
            </div>
        </div>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Style="margin-top: -8px;">
            Brukes for  bli invitert direkte til andres husstander
        </MudText>
    }
</div>

<div class="form-section">
    <p class="form-section-title">Utseende</p>
    <MudSelect T="string"
               Label="Fargetema"
               Value="@_currentTheme"
               ValueChanged="OnThemeChanged"
               Variant="Variant.Outlined"
               Class="theme-select"
               AnchorOrigin="Origin.BottomLeft"
               Style="margin-bottom: 16px;">
        @foreach (var themeName in ThemeService.GetAvailableThemes())
        {
            var colors = ThemeService.GetThemeColors(themeName);
            <MudSelectItem Value="@themeName">
                <div class="theme-preview-container">
                    <div class="mini-website" style="background: @colors.Background; border-color: @colors.Divider;">
                        <div class="mini-appbar" style="background: @colors.AppbarBackground;"></div>
                        <div class="mini-sidebar" style="background: @colors.BackgroundGrey;"></div>
                        <div class="mini-content" style="background: @colors.Surface;">
                            <div class="mini-primary" style="background: @colors.Primary;"></div>
                            <div class="mini-text" style="background: @colors.TextPrimary;"></div>
                            <div class="mini-text-sm" style="background: @colors.TextSecondary;"></div>
                        </div>
                    </div>
                    <span class="theme-name">@GetThemeDisplayName(themeName)</span>
                </div>
            </MudSelectItem>
        }
    </MudSelect>
</div>

@if (HouseholdState.UserHouseholds.Any())
{
    <div class="form-section">
        <div class="d-flex justify-space-between align-center mb-2">
            <p class="form-section-title" style="margin-bottom: 0;">Dine Grupper</p>
            <MudButton Variant="Variant.Text"
                       Color="Color.Primary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Rounded.Settings"
                       Href="/household">
                Administrer
            </MudButton>
        </div>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-3">
            Du er med i @HouseholdState.UserHouseholds.Count gruppe(r). Trykk p en gruppe for  velge/fravelge den i kokeboken.
        </MudText>
        <div class="d-flex flex-wrap gap-2">
            @foreach (var group in HouseholdState.UserHouseholds)
            {
                <MudChip T="string"
                         Variant="@(HouseholdState.IsGroupActive(group.Id) ? Variant.Filled : Variant.Outlined)"
                         Color="Color.Primary"
                         OnClick="@(() => ToggleGroupFilter(group.Id))"
                         Icon="@(HouseholdState.IsGroupActive(group.Id) ? Icons.Material.Rounded.CheckCircle : Icons.Material.Rounded.RadioButtonUnchecked)">
                    @group.Name
                    <MudText Typo="Typo.caption" Class="ml-1" Style="opacity: 0.7;">
                        (@(group.Members?.Count ?? 0))
                    </MudText>
                </MudChip>
            }
        </div>
    </div>
}

<div class="form-section">
    <MudButton Variant="Variant.Outlined"
               Color="Color.Error"
               FullWidth="true"
               StartIcon="@Icons.Material.Rounded.Logout"
               OnClick="Logout"
               Style="border-radius: 12px;">
        Logg ut
    </MudButton>
</div>

<div class="form-section mt-4">
    <div class="d-flex justify-center flex-column align-center gap-1">
        <MudText Typo="Typo.body2" Style="font-weight: 500;">Storhaugen Eats</MudText>
        <MudText Typo="Typo.caption" Color="Color.Secondary">Versjon 1.0.0</MudText>
    </div>
</div>

<style>
    .setting-row {
        display: flex;
        align-items: center;
        padding: 12px 0;
        gap: 16px;
    }

    .theme-select .mud-input-slot {
        min-height: 70px !important;
        padding: 8px 14px !important;
    }

    .theme-preview-container {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
    }

    .theme-name {
        font-weight: 500;
    }

    .mini-website {
        width: 100px;
        height: 56px;
        border-radius: 6px;
        border: 1px solid;
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
        flex-shrink: 0;
    }

    .mini-appbar {
        width: 100%;
        height: 10px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .mini-sidebar {
        width: 16px;
        height: calc(100% - 10px);
    }

    .mini-content {
        flex: 1;
        margin: 4px;
        border-radius: 3px;
        padding: 4px;
        display: flex;
        flex-direction: column;
        gap: 3px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    .mini-primary {
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }

    .mini-text {
        width: 60%;
        height: 4px;
        border-radius: 2px;
    }

    .mini-text-sm {
        width: 40%;
        height: 3px;
        border-radius: 2px;
    }
</style>

@code {
    private UserDto? _userProfile;
    private string? _editDisplayName;
    private string _currentTheme = "Light";
    private string _viewMode = "card";

    protected override async Task OnInitializedAsync()
    {
        await HouseholdState.InitializeAsync();

        try
        {
            _userProfile = await ApiClient.GetMyProfileAsync();
            if (_userProfile != null)
            {
                _editDisplayName = _userProfile.DisplayName;
                AuthService.UpdateCachedDisplayName(_userProfile.DisplayName);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading user profile: {ex.Message}");
        }

        _currentTheme = ThemeService.GetCurrentThemeName();
        _viewMode = DeviceState.Settings.ViewMode;
    }

    private async Task UpdateDisplayName()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(_editDisplayName)) _editDisplayName = null;

            var updatedProfile = await ApiClient.UpdateMyProfileAsync(new UpdateUserDto
            {
                DisplayName = _editDisplayName
            });

            _userProfile = updatedProfile;
            AuthService.UpdateCachedDisplayName(updatedProfile.DisplayName);
            Snackbar.Add("Brukernavn oppdatert", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Klarte ikke  oppdatere navn", Severity.Error);
        }
    }

    private async Task CopyShareId()
    {
        if (string.IsNullOrEmpty(_userProfile?.UniqueShareId)) return;
        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", _userProfile.UniqueShareId);
            Snackbar.Add("ID kopiert!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Feil ved kopiering", Severity.Error);
        }
    }

    private void ToggleGroupFilter(Guid groupId)
    {
        HouseholdState.ToggleGroupFilter(groupId);
        StateHasChanged();
        Snackbar.Add("Gruppefilter oppdatert", Severity.Info);
    }

    private async Task OnThemeChanged(string themeName)
    {
        _currentTheme = themeName;
        await ThemeService.SetThemeAsync(themeName);
    }



    private string GetThemeDisplayName(string themeName)
    {
        return themeName switch
        {
            "System" => "System Default",
            "Light" => "Light",
            "Dark" => "Dark",
            "Black" => "Midnight Black",
            "Material" => "Material Red",
            "Forest" => "Night Forest",
            _ => themeName
        };
    }

    private async Task Logout()
    {
        await AuthService.LogoutAsync();
        Navigation.NavigateTo("login");
    }

    private string GetMemberColor(string name)
    {
        var hash = name.GetHashCode();
        var hue = Math.Abs(hash % 360);
        return $"hsl({hue}, 45%, 45%)";
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Pages\Settings.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class ActivityFeedService : IActivityFeedService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<ActivityFeedItemDto> CachedFeedItems { get; private set; } = new();
        public ActivitySummaryDto? CachedSummary { get; private set; }

        public ActivityFeedService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthentication()
        {
            if (!_authService.IsAuthenticated)
            {
                throw new UnauthorizedAccessException("You must be logged in to access the activity feed.");
            }
        }

        public async Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery? query = null)
        {
            ValidateAuthentication();

            query ??= new ActivityFeedQuery();
            var result = await _apiClient.GetFeedAsync(query);

            // Cache first page of results
            if (query.Page == 1)
            {
                CachedFeedItems = result.Items;
            }

            return result;
        }

        public async Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20)
        {
            ValidateAuthentication();
            return await _apiClient.GetMyActivityAsync(page, pageSize);
        }

        public async Task<ActivitySummaryDto> GetActivitySummaryAsync()
        {
            ValidateAuthentication();

            var summary = await _apiClient.GetActivitySummaryAsync();
            CachedSummary = summary;
            return summary;
        }

        public void InvalidateCache()
        {
            CachedFeedItems = new List<ActivityFeedItemDto>();
            CachedSummary = null;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\ActivityFeed\ActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IActivityFeedService
    {
        // Feed queries
        Task<ActivityFeedPagedResult> GetFeedAsync(ActivityFeedQuery? query = null);
        Task<ActivityFeedPagedResult> GetMyActivityAsync(int page = 1, int pageSize = 20);
        Task<ActivitySummaryDto> GetActivitySummaryAsync();

        // Cache
        List<ActivityFeedItemDto> CachedFeedItems { get; }
        ActivitySummaryDto? CachedSummary { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\ActivityFeed\IActivityFeedService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\IAuthService.cs
================================================================================
namespace StorhaugenWebsite.Services
{
    public interface IAuthService
    {
        event Action? OnAuthStateChanged;
        bool IsAuthenticated { get; }
        bool IsAuthorized { get; }
        string? CurrentUserEmail { get; }
        string? CurrentUserName { get; }

        Task<(bool success, string? errorMessage)> LoginAsync(); // Keep for Google
        // --- ADD THESE ---
        Task<(bool success, string? errorMessage)> SignInWithEmailAsync(string email, string password);
        Task<(bool success, string? errorMessage)> SignUpWithEmailAsync(string email, string password, string displayName);
        // -----------------
        Task LogoutAsync();
        Task InitializeAsync();
        Task<string?> GetAccessTokenAsync();
        void UpdateCachedDisplayName(string? displayName);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\IAuthService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
================================================================================
using Microsoft.AspNetCore.Components;
using Microsoft.JSInterop;
using Supabase;
using Supabase.Gotrue;
using static Supabase.Gotrue.Constants;
using Client = Supabase.Client;

namespace StorhaugenWebsite.Services;

public class SupabaseAuthService : IAuthService, IAsyncDisposable
{
    private readonly Client _supabaseClient;
    private readonly IJSRuntime _jsRuntime;
    private readonly NavigationManager _navigationManager;
    private Session? _session;

    public event Action? OnAuthStateChanged;

    public bool IsAuthenticated => _session?.User != null;
    public bool IsAuthorized => IsAuthenticated; // Any authenticated user is authorized

    private string? _cachedDisplayName; 
    public string? CurrentUserEmail => _session?.User?.Email;
    public string? CurrentUserName => !string.IsNullOrEmpty(_cachedDisplayName)
        ? _cachedDisplayName
        : GetUserNameFromEmail(CurrentUserEmail);

    // Inject NavigationManager here
    public SupabaseAuthService(Client supabaseClient, IJSRuntime jsRuntime, NavigationManager navigationManager)
    {
        _supabaseClient = supabaseClient;
        _jsRuntime = jsRuntime;
        _navigationManager = navigationManager;

        _supabaseClient.Auth.AddStateChangedListener(OnAuthStateChange);
    }

    private void OnAuthStateChange(object? sender, Constants.AuthState state)
    {
        _session = _supabaseClient.Auth.CurrentSession;
        OnAuthStateChanged?.Invoke();
    }

    public void UpdateCachedDisplayName(string? displayName)
    {
        _cachedDisplayName = displayName;
        OnAuthStateChanged?.Invoke();
    }

    public async Task InitializeAsync()
    {
        try
        {
            // 1. Check if we are coming back from a login redirect (URL contains access_token)
            var uri = _navigationManager.Uri;
            if (uri.Contains("access_token") && uri.Contains("type=recovery") == false)
            {
                // Parse the session from the URL
                var session = await _supabaseClient.Auth.GetSessionFromUrl(new Uri(uri));

                if (session != null)
                {
                    _session = session;
                    OnAuthStateChanged?.Invoke();

                    // Optional: Clean the URL so the user doesn't see the ugly token
                    // _navigationManager.NavigateTo("/", replace: true); 
                    return;
                }
            }

            // 2. If no token in URL, check LocalStorage for existing session
            var storedSession = await _supabaseClient.Auth.RetrieveSessionAsync();
            if (storedSession != null)
            {
                _session = storedSession;
                OnAuthStateChanged?.Invoke();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Auth initialization error: {ex.Message}");
        }
    }

    public async Task<(bool success, string? errorMessage)> LoginAsync()
    {
        try
        {
            var redirectUrl = await GetRedirectUrlAsync();

            var options = new SignInOptions
            {
                RedirectTo = redirectUrl
            };

            var result = await _supabaseClient.Auth.SignIn(Provider.Google, options);

            if (result != null && result.Uri != null)
            {
                // 1. We are leaving the app. Using NavigationManager with forceLoad: true 
                // is cleaner than JS Interop for external links.
                _navigationManager.NavigateTo(result.Uri.ToString(), forceLoad: true);

                // 2. We return basic success here, but the code below 
                // technically won't matter because the browser is navigating away.
                return (true, null);
            }

            return (false, "Login was cancelled or failed.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Login error: {ex.Message}");
            return (false, $"Login error: {ex.Message}");
        }
    }

    public async Task<(bool success, string? errorMessage)> SignInWithEmailAsync(string email, string password)
    {
        try
        {
            var session = await _supabaseClient.Auth.SignIn(email, password);

            if (session != null && session.User != null)
            {
                _session = session;
                OnAuthStateChanged?.Invoke();
                return (true, null);
            }
            return (false, "Invalid credentials");
        }
        catch (Exception ex)
        {
            // Supabase throws specific exceptions for invalid login
            return (false, ex.Message);
        }
    }

    public async Task<(bool success, string? errorMessage)> SignUpWithEmailAsync(string email, string password, string displayName)
    {
        try
        {
            var options = new SignUpOptions
            {
                Data = new Dictionary<string, object>
                {
                    { "name", displayName }, // Pass display name to Supabase metadata
                    { "full_name", displayName } // Some providers look for full_name
                }
            };

            var session = await _supabaseClient.Auth.SignUp(email, password, options);

            // If Supabase is set to "Auto Confirm Emails", you get a session immediately.
            // If "Confirm Email" is on, session might be null, but User is not.
            if (session?.User != null)
            {
                if (session.AccessToken != null)
                {
                    _session = session;
                    OnAuthStateChanged?.Invoke();
                    return (true, null);
                }
                else
                {
                    return (true, "Registration successful! Please check your email to confirm your account.");
                }
            }

            return (false, "Registration failed.");
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }

    public async Task LogoutAsync()
    {
        try
        {
            await _supabaseClient.Auth.SignOut();
            _session = null;
            OnAuthStateChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Logout error: {ex.Message}");
        }
    }

    public Task<string?> GetAccessTokenAsync()
    {
        return Task.FromResult(_session?.AccessToken);
    }

    private Task<string> GetRedirectUrlAsync()
    {
        // Ensure we redirect specifically to the login page so the 
        // OnInitializedAsync method in Login.razor actually runs to parse the token.
        var baseUri = _navigationManager.BaseUri;

        // Handle trailing slash just in case
        var redirectUrl = baseUri.EndsWith("/")
            ? $"{baseUri}login"
            : $"{baseUri}/login";

        return Task.FromResult(redirectUrl);
    }

    public async ValueTask DisposeAsync()
    {
        _supabaseClient.Auth.RemoveStateChangedListener(OnAuthStateChange);
        await Task.CompletedTask;
    }

    private static string? GetUserNameFromEmail(string? email)
    {
        if (string.IsNullOrEmpty(email))
            return null;

        // Extract name from email (part before @)
        var atIndex = email.IndexOf('@');
        if (atIndex <= 0)
            return email;

        var namePart = email.Substring(0, atIndex);

        // Capitalize first letter
        if (namePart.Length > 0)
        {
            return char.ToUpper(namePart[0]) + namePart.Substring(1).ToLower();
        }

        return namePart;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\SupabaseAuthService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
================================================================================
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.JSInterop;
using Newtonsoft.Json;
using Supabase.Gotrue;
using System.Security.Claims;
using static Supabase.Gotrue.Constants;

namespace StorhaugenWebsite.Services;

public class SupabaseAuthStateProvider : AuthenticationStateProvider
{
    private readonly Supabase.Client _client;
    private readonly IJSRuntime _jsRuntime;
    private const string AuthCacheKey = "supa_auth_session";

    public SupabaseAuthStateProvider(Supabase.Client client, IJSRuntime jsRuntime)
    {
        _client = client;
        _jsRuntime = jsRuntime;
        _client.Auth.AddStateChangedListener(OnAuthStateChanged);
    }

    public override async Task<AuthenticationState> GetAuthenticationStateAsync()
    {
        try
        {
            // 1. Check if Supabase already has the session in memory
            var session = _client.Auth.CurrentSession;

            if (session != null)
            {
                // Ensure persistence if session exists in memory
                var json = JsonConvert.SerializeObject(session);
                await _jsRuntime.InvokeVoidAsync("localStorage.setItem", AuthCacheKey, json);
            }
            else
            {
                // 2. Try to load from LocalStorage
                var cachedJson = await _jsRuntime.InvokeAsync<string>("localStorage.getItem", AuthCacheKey);

                if (!string.IsNullOrEmpty(cachedJson))
                {
                    session = JsonConvert.DeserializeObject<Session>(cachedJson);
                    if (session?.AccessToken != null)
                    {
                        await _client.Auth.SetSession(session.AccessToken, session.RefreshToken);
                        session = _client.Auth.CurrentSession;
                    }
                }
            }

            // 3. Create Claims
            if (session?.User != null)
            {
                // --- FIX STARTS HERE ---
                // Try to get display name from metadata ("name" or "full_name"), fallback to email
                string? displayName = session.User.Email;

                if (session.User.UserMetadata != null)
                {
                    if (session.User.UserMetadata.TryGetValue("name", out var nameObj) && nameObj != null)
                    {
                        displayName = nameObj.ToString();
                    }
                    else if (session.User.UserMetadata.TryGetValue("full_name", out var fullNameObj) && fullNameObj != null)
                    {
                        displayName = fullNameObj.ToString();
                    }
                }

                var claims = new List<Claim>
                {
                    // Use the resolved displayName here instead of just email
                    new Claim(ClaimTypes.Name, displayName ?? ""),
                    new Claim(ClaimTypes.Email, session.User.Email ?? ""),
                    new Claim(ClaimTypes.NameIdentifier, session.User.Id ?? "")
                };
                // --- FIX ENDS HERE ---

                var identity = new ClaimsIdentity(claims, "Supabase");
                return new AuthenticationState(new ClaimsPrincipal(identity));
            }
        }
        catch
        {
            await _jsRuntime.InvokeVoidAsync("localStorage.removeItem", AuthCacheKey);
        }

        return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity()));
    }

    // ... rest of the file (OnAuthStateChanged, Dispose) remains the same
    private async void OnAuthStateChanged(object sender, AuthState state)
    {
        var session = _client.Auth.CurrentSession;

        if (state == AuthState.SignedIn || state == AuthState.TokenRefreshed)
        {
            if (session != null)
            {
                var json = JsonConvert.SerializeObject(session);
                await _jsRuntime.InvokeVoidAsync("localStorage.setItem", AuthCacheKey, json);
            }
        }
        else if (state == AuthState.SignedOut)
        {
            await _jsRuntime.InvokeVoidAsync("localStorage.removeItem", AuthCacheKey);
        }

        NotifyAuthenticationStateChanged(GetAuthenticationStateAsync());
    }

    public void Dispose()
    {
        _client.Auth.RemoveStateChangedListener(OnAuthStateChanged);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Authentication\SupabaseAuthStateProvider.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
================================================================================
using Microsoft.JSInterop;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public class DeviceStateService : IDeviceStateService
    {
        private readonly IJSRuntime _jsRuntime;
        private const string STORAGE_KEY = "storhaugen_settings";

        public DeviceSettings Settings { get; private set; } = new();
        public event Action? OnSettingsChanged;

        public DeviceStateService(IJSRuntime jsRuntime)
        {
            _jsRuntime = jsRuntime;
        }

        public async Task InitializeAsync()
        {
            try
            {
                var json = await _jsRuntime.InvokeAsync<string?>("deviceState.get", STORAGE_KEY);
                if (!string.IsNullOrEmpty(json))
                {
                    var settings = System.Text.Json.JsonSerializer.Deserialize<DeviceSettings>(json);
                    if (settings != null)
                    {
                        Settings = settings;
                    }
                }
            }
            catch
            {
                // Use defaults if localStorage fails
            }
        }

        public async Task SetSortAsync(string sortBy, bool descending)
        {
            Settings.SortBy = sortBy;
            Settings.SortDescending = descending;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task SetThemeAsync(string theme)
        {
            Settings.Theme = theme;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task SetViewModeAsync(string viewMode)
        {
            Settings.ViewMode = viewMode;
            await SaveSettingsAsync();
            OnSettingsChanged?.Invoke();
        }

        public async Task<string> GetSystemThemePreferenceAsync()
        {
            try
            {
                return await _jsRuntime.InvokeAsync<string>("deviceState.getPreferredTheme");
            }
            catch
            {
                return "dark";
            }
        }

        private async Task SaveSettingsAsync()
        {
            try
            {
                var json = System.Text.Json.JsonSerializer.Serialize(Settings);
                await _jsRuntime.InvokeVoidAsync("deviceState.set", STORAGE_KEY, json);
            }
            catch
            {
                // Silently fail if localStorage is not available
            }
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\DeviceState\DeviceStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
================================================================================
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IDeviceStateService
    {
        DeviceSettings Settings { get; }
        event Action? OnSettingsChanged;

        Task InitializeAsync();
        Task SetThemeAsync(string theme);
        Task SetViewModeAsync(string viewMode);
        Task<string> GetSystemThemePreferenceAsync();
        Task SetSortAsync(string sortBy, bool descending); // New method

    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\DeviceState\IDeviceStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Food\FoodService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Models;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    /// <summary>
    /// TRANSITIONING: This service currently uses household-recipes endpoints.
    /// It should be migrated to use IUserRecipeService endpoints instead.
    /// The FoodItem model will be replaced with UserRecipeDto.
    /// </summary>
    public class FoodService : IFoodService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;
        public FoodItem? DraftRecipe { get; set; } 
        public List<FoodItem> CachedFoods { get; private set; } = new();
        public FoodService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthorization()
        {
            if (!_authService.IsAuthorized)
            {
                throw new UnauthorizedAccessException("You are not authorized to perform this action.");
            }
        }

        public async Task<List<FoodItem>> GetAllFoodsAsync(bool includeArchived = false)
        {
            if (!_authService.IsAuthenticated) throw new UnauthorizedAccessException();

            var recipes = await _apiClient.GetRecipesAsync(includeArchived);
            var mappedRecipes = recipes.Select(MapToFoodItem).ToList();

            // Update the cache if we are fetching the standard active list
            if (!includeArchived)
            {
                CachedFoods = mappedRecipes;
            }

            return mappedRecipes;
        }

        public async Task<FoodItem?> GetFoodByIdAsync(string id)
        {
            if (!Guid.TryParse(id, out var recipeId))
                return null;

            var recipe = await _apiClient.GetRecipeAsync(recipeId);
            return recipe != null ? MapToFoodItem(recipe) : null;
        }

        public async Task<string> AddFoodAsync(FoodItem food)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(food.Name))
                throw new ArgumentException("Food name cannot be empty.");

            var dto = new CreateHouseholdRecipeDto
            {
                Name = food.Name,
                Description = food.Description,
                ImageUrls = food.ImageUrls,
                PersonalNotes = null,
                IsPublic = food.IsPublic
            };

            var created = await _apiClient.CreateRecipeAsync(dto);

            // Add the user's rating if provided
            foreach (var rating in food.Ratings.Where(r => r.Value.HasValue))
            {
                await _apiClient.RateRecipeAsync(created.Id, rating.Value!.Value);
            }

            return created.Id.ToString();
        }

        public async Task UpdateFoodAsync(FoodItem food)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(food.Id)) throw new ArgumentException("ID required.");
            if (string.IsNullOrWhiteSpace(food.Name)) throw new ArgumentException("Name required.");

            if (!Guid.TryParse(food.Id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            var dto = new UpdateHouseholdRecipeDto
            {
                Name = food.Name,
                Description = food.Description,
                ImageUrls = food.ImageUrls,
                PersonalNotes = food.PersonalNotes
            };

            await _apiClient.UpdateRecipeAsync(recipeId, dto);
        }

        public async Task ArchiveFoodAsync(string id, string archivedBy)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.ArchiveRecipeAsync(recipeId);
        }

        public async Task RestoreFoodAsync(string id)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.RestoreRecipeAsync(recipeId);
        }

        public async Task UpdateRatingAsync(string foodId, string personName, int rating)
        {
            ValidateAuthorization();

            if (rating < 0 || rating > 10) throw new ArgumentException("Invalid rating.");

            if (!Guid.TryParse(foodId, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.RateRecipeAsync(recipeId, rating);
        }

        public async Task<string> UploadImageAsync(byte[] imageData, string fileName)
        {
            ValidateAuthorization();

            if (imageData == null || imageData.Length == 0)
                throw new ArgumentException("Image data is required.");

            var result = await _apiClient.UploadImageAsync(imageData, fileName);
            return result.Url;
        }

        public async Task ForkRecipeAsync(string id)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            await _apiClient.ForkRecipeAsync(recipeId);
        }

        public async Task SetPublicStatusAsync(string id, bool isPublic)
        {
            ValidateAuthorization();

            if (!Guid.TryParse(id, out var recipeId))
                throw new ArgumentException("Invalid ID format.");

            var dto = new UpdateHouseholdRecipeDto
            {
                IsPublic = isPublic
            };

            await _apiClient.UpdateRecipeAsync(recipeId, dto);
        }

        // Map HouseholdRecipeDto to FoodItem for backward compatibility
        private FoodItem MapToFoodItem(HouseholdRecipeDto recipe)
        {
            return new FoodItem
            {
                Id = recipe.Id.ToString(),
                Name = recipe.Name,
                Description = recipe.Description,
                ImageUrls = recipe.ImageUrls,
                Ratings = recipe.Ratings,
                DateAdded = recipe.DateAdded,
                AddedBy = recipe.AddedByName ?? "Unknown",
                IsArchived = recipe.IsArchived,
                ArchivedDate = recipe.ArchivedDate,
                ArchivedBy = recipe.ArchivedByName,
                GlobalRecipeId = recipe.GlobalRecipeId,
                GlobalRecipeName = recipe.GlobalRecipeName,
                IsForked = recipe.IsForked,
                PersonalNotes = recipe.PersonalNotes,
                IsPublic = recipe.IsPublic,
                HouseholdName = recipe.HouseholdName
            };
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Food\FoodService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Food\IFoodService.cs
================================================================================
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IFoodService
    {
        Task<string> AddFoodAsync(FoodItem food);
        Task UpdateFoodAsync(FoodItem food);
        Task<List<FoodItem>> GetAllFoodsAsync(bool includeArchived = false);
        Task<FoodItem?> GetFoodByIdAsync(string id);
        Task ArchiveFoodAsync(string id, string archivedBy);
        Task RestoreFoodAsync(string id);
        Task UpdateRatingAsync(string foodId, string personName, int rating);
        Task<string> UploadImageAsync(byte[] imageData, string fileName);
        Task ForkRecipeAsync(string id);
        Task SetPublicStatusAsync(string id, bool isPublic);
        List<FoodItem> CachedFoods { get; }
        FoodItem? DraftRecipe { get; set; } 
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Food\IFoodService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Household\HouseholdStateService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services;

/// <summary>
/// Manages group (household) state for the current user.
/// Supports multi-group filtering - user can be in multiple groups and filter which ones to view.
/// </summary>
public class HouseholdStateService : IHouseholdStateService
{
    private readonly IApiClient _apiClient;
    private readonly IAuthService _authService;

    public event Action? OnHouseholdChanged;
    public event Action? OnActiveGroupsChanged;

    public List<HouseholdDto> UserHouseholds { get; private set; } = new();
    public List<Guid> ActiveGroupFilters { get; private set; } = new();

    public List<HouseholdDto> ActiveGroups =>
        UserHouseholds.Where(h => ActiveGroupFilters.Contains(h.Id)).ToList();

    public bool HasHousehold => UserHouseholds.Any();
    public bool NeedsHouseholdSetup => _authService.IsAuthenticated && !HasHousehold;

    // [DEPRECATED] For backwards compatibility - returns first active group or first household
    public HouseholdDto? CurrentHousehold =>
        ActiveGroups.FirstOrDefault() ?? UserHouseholds.FirstOrDefault();

    private bool _isInitialized = false;
    private Task? _currentLoadingTask;

    public HouseholdStateService(IApiClient apiClient, IAuthService authService)
    {
        _apiClient = apiClient;
        _authService = authService;
        _authService.OnAuthStateChanged += OnAuthChanged;
    }

    private async void OnAuthChanged()
    {
        if (_authService.IsAuthenticated)
        {
            if (!_isInitialized)
            {
                await InitializeAsync();
            }
        }
        else
        {
            // Reset state on logout
            UserHouseholds.Clear();
            ActiveGroupFilters.Clear();
            _isInitialized = false;
            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
        }
    }

    public async Task InitializeAsync(bool forceRefresh = false)
    {
        if (!_authService.IsAuthenticated) return;

        if (_currentLoadingTask != null && !_currentLoadingTask.IsCompleted)
        {
            await _currentLoadingTask;
            return;
        }

        // Only skip if initialized AND not forced
        if (!forceRefresh && _isInitialized && UserHouseholds.Any()) return;

        _currentLoadingTask = LoadDataInternal();
        await _currentLoadingTask;
    }

    private async Task LoadDataInternal()
    {
        try
        {
            // Get user's households
            await RefreshHouseholdsAsync();

            // By default, activate ALL groups so user sees everything
            if (!ActiveGroupFilters.Any() && UserHouseholds.Any())
            {
                ActiveGroupFilters = UserHouseholds.Select(h => h.Id).ToList();
            }

            _isInitialized = true;
            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing households: {ex.Message}");
        }
    }

    public async Task RefreshHouseholdsAsync()
    {
        if (!_authService.IsAuthenticated) return;

        try
        {
            UserHouseholds = await _apiClient.GetMyHouseholdsAsync();

            // Clean up ActiveGroupFilters - remove any groups user is no longer a member of
            ActiveGroupFilters = ActiveGroupFilters
                .Where(id => UserHouseholds.Any(h => h.Id == id))
                .ToList();

            // If no active filters and user has groups, activate all
            if (!ActiveGroupFilters.Any() && UserHouseholds.Any())
            {
                ActiveGroupFilters = UserHouseholds.Select(h => h.Id).ToList();
            }

            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing households: {ex.Message}");
        }
    }

    public void ToggleGroupFilter(Guid groupId)
    {
        if (!UserHouseholds.Any(h => h.Id == groupId)) return;

        if (ActiveGroupFilters.Contains(groupId))
        {
            // Don't allow removing the last active group
            if (ActiveGroupFilters.Count > 1)
            {
                ActiveGroupFilters.Remove(groupId);
            }
        }
        else
        {
            ActiveGroupFilters.Add(groupId);
        }

        OnActiveGroupsChanged?.Invoke();
    }

    public void SelectAllGroups()
    {
        ActiveGroupFilters = UserHouseholds.Select(h => h.Id).ToList();
        OnActiveGroupsChanged?.Invoke();
    }

    public void ClearAllGroups()
    {
        // Keep at least one group active if available
        if (UserHouseholds.Any())
        {
            ActiveGroupFilters = new List<Guid> { UserHouseholds.First().Id };
        }
        else
        {
            ActiveGroupFilters.Clear();
        }
        OnActiveGroupsChanged?.Invoke();
    }

    public bool IsGroupActive(Guid groupId)
    {
        return ActiveGroupFilters.Contains(groupId);
    }

    // [DEPRECATED] For backwards compatibility
    public async Task SetCurrentHouseholdAsync(Guid householdId)
    {
        if (!_authService.IsAuthenticated) throw new UnauthorizedAccessException("User is not authenticated");
        try
        {
            await _apiClient.SwitchHouseholdAsync(householdId);
            await _apiClient.UpdateMyProfileAsync(new UpdateUserDto { CurrentHouseholdId = householdId });

            // Set only this group as active (backwards compatible behavior)
            ActiveGroupFilters = new List<Guid> { householdId };

            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error switching household: {ex.Message}");
            throw;
        }
    }

    public async Task<HouseholdDto> CreateHouseholdAsync(string name)
    {
        if (!_authService.IsAuthenticated) throw new UnauthorizedAccessException("User is not authenticated");
        try
        {
            var household = await _apiClient.CreateHouseholdAsync(new CreateHouseholdDto { Name = name });
            await RefreshHouseholdsAsync();

            // Add the new group to active filters
            if (!ActiveGroupFilters.Contains(household.Id))
            {
                ActiveGroupFilters.Add(household.Id);
            }

            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
            return household;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating household: {ex.Message}");
            throw;
        }
    }

    public async Task<List<HouseholdInviteDto>> GetPendingInvitesAsync()
    {
        if (!_authService.IsAuthenticated) return new List<HouseholdInviteDto>();
        try { return await _apiClient.GetPendingInvitesAsync(); }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting pending invites: {ex.Message}");
            return new List<HouseholdInviteDto>();
        }
    }

    public async Task AcceptInviteAsync(Guid inviteId)
    {
        if (!_authService.IsAuthenticated) throw new UnauthorizedAccessException("User is not authenticated");
        try
        {
            await _apiClient.AcceptInviteAsync(inviteId);
            await RefreshHouseholdsAsync();
            OnHouseholdChanged?.Invoke();
            OnActiveGroupsChanged?.Invoke();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error accepting invite: {ex.Message}");
            throw;
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Household\HouseholdStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Household\IHouseholdStateService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services;

/// <summary>
/// Manages group (household) state for the current user.
/// Supports multi-group filtering - user can be in multiple groups and filter which ones to view.
/// </summary>
public interface IHouseholdStateService
{
    event Action? OnHouseholdChanged;
    event Action? OnActiveGroupsChanged;

    /// <summary>
    /// All groups (households) the user is a member of.
    /// </summary>
    List<HouseholdDto> UserHouseholds { get; }

    /// <summary>
    /// Currently active group filters - which groups to show recipes from.
    /// By default, all groups are active.
    /// </summary>
    List<Guid> ActiveGroupFilters { get; }

    /// <summary>
    /// The active groups as DTOs (for easy UI binding).
    /// </summary>
    List<HouseholdDto> ActiveGroups { get; }

    /// <summary>
    /// Whether the user is a member of at least one group.
    /// </summary>
    bool HasHousehold { get; }

    /// <summary>
    /// Whether the user needs to create or join a group.
    /// </summary>
    bool NeedsHouseholdSetup { get; }

    /// <summary>
    /// [DEPRECATED] For backwards compatibility - returns first active group or first household.
    /// New code should use ActiveGroupFilters instead.
    /// </summary>
    HouseholdDto? CurrentHousehold { get; }

    Task InitializeAsync(bool force = false);
    Task RefreshHouseholdsAsync();

    /// <summary>
    /// Toggle a group in the active filters.
    /// </summary>
    void ToggleGroupFilter(Guid groupId);

    /// <summary>
    /// Set all groups as active.
    /// </summary>
    void SelectAllGroups();

    /// <summary>
    /// Clear all group filters (select none).
    /// </summary>
    void ClearAllGroups();

    /// <summary>
    /// Check if a specific group is active in the filter.
    /// </summary>
    bool IsGroupActive(Guid groupId);

    /// <summary>
    /// [DEPRECATED] For backwards compatibility - switches to a single household context.
    /// New code should use ToggleGroupFilter instead.
    /// </summary>
    Task SetCurrentHouseholdAsync(Guid householdId);

    Task<HouseholdDto> CreateHouseholdAsync(string name);
    Task<List<HouseholdInviteDto>> GetPendingInvitesAsync();
    Task AcceptInviteAsync(Guid inviteId);
}


================================================================================
FILE END: \StorhaugenWebsite\Services\Household\IHouseholdStateService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Ocr\IOcrService.cs
================================================================================
namespace StorhaugenWebsite.Services // Adjust namespace if your folder structure is different
{
    public interface IOcrService
    {
        Task<string> RecognizeTextAsync(string imageBase64DataUrl);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Ocr\IOcrService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
================================================================================
using Microsoft.JSInterop;

namespace StorhaugenWebsite.Services
{
    // The ": IOcrService" part tells C# that this class fulfills the IOcrService contract
    public class TesseractOcrService : IOcrService
    {
        private readonly IJSRuntime _jsRuntime;

        // We inject the JS Runtime so we can talk to the JavaScript file you added
        public TesseractOcrService(IJSRuntime jsRuntime)
        {
            _jsRuntime = jsRuntime;
        }

        public async Task<string> RecognizeTextAsync(string imageSource)
        {
            // This line calls the 'window.ocrInterop.recognizeTextFromImage' function 
            // inside your wwwroot/js/ocrInterop.js file
            return await _jsRuntime.InvokeAsync<string>("ocrInterop.recognizeTextFromImage", imageSource);
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Ocr\TesseractOcrService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Theme\IThemeService.cs
================================================================================
using MudBlazor;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public interface IThemeService
    {
        bool IsDarkMode { get; }
        event Action? OnThemeChanged;

        Task InitializeAsync();
        MudTheme GetCurrentTheme();
        IEnumerable<string> GetAvailableThemes();
        string GetCurrentThemeName();
        Task SetThemeAsync(string themeName);
        ThemeColors GetThemeColors(string themeName);
        bool IsThemeDark(string themeName);
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Theme\IThemeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\Theme\ThemeService.cs
================================================================================
using MudBlazor;
using StorhaugenWebsite.Models;

namespace StorhaugenWebsite.Services
{
    public class ThemeService : IThemeService
    {
        private readonly IDeviceStateService _deviceState;
        private Dictionary<string, MudTheme> _themes = new();
        private string? _systemPreference;

        public bool IsDarkMode { get; private set; }
        public event Action? OnThemeChanged;

        public ThemeService(IDeviceStateService deviceState)
        {
            _deviceState = deviceState;
        }

        public async Task InitializeAsync()
        {
            _systemPreference = await _deviceState.GetSystemThemePreferenceAsync();

            _themes["System"] = _systemPreference == "dark" ? GenerateDarkTheme() : GenerateLightTheme();
            _themes["Light"] = GenerateLightTheme();
            _themes["Dark"] = GenerateDarkTheme();
            _themes["Black"] = GenerateBlackTheme();
            _themes["Material"] = GenerateMaterialTheme();
            _themes["Forest"] = GenerateForestTheme();

            UpdateDarkModeState();
        }

        public MudTheme GetCurrentTheme()
        {
            var themeName = _deviceState.Settings.Theme;
            if (_themes.TryGetValue(themeName, out var theme))
            {
                return theme;
            }
            return _themes["Light"];
        }

        public IEnumerable<string> GetAvailableThemes() => _themes.Keys;

        public string GetCurrentThemeName() => _deviceState.Settings.Theme;

        public async Task SetThemeAsync(string themeName)
        {
            if (!_themes.ContainsKey(themeName)) return;

            await _deviceState.SetThemeAsync(themeName);
            UpdateDarkModeState();
            OnThemeChanged?.Invoke();
        }

        public ThemeColors GetThemeColors(string themeName)
        {
            if (!_themes.TryGetValue(themeName, out var theme))
            {
                theme = _themes["Light"];
            }

            var isDark = IsThemeDark(themeName);

            Palette palette = isDark ? theme.PaletteDark : theme.PaletteLight;

            return new ThemeColors
            {
                Primary = palette.Primary.ToString(),
                Info = palette.Info.ToString(),
                AppbarBackground = palette.AppbarBackground.ToString(),
                Surface = palette.Surface.ToString(),
                Background = palette.Background.ToString(),
                BackgroundGrey = palette.BackgroundGray.ToString(), // Note: MudBlazor v7 uses 'BackgroundGray'
                Divider = palette.Divider.ToString(),
                TextPrimary = palette.TextPrimary.ToString(),
                TextSecondary = palette.TextSecondary.ToString()
            };
        }

        public bool IsThemeDark(string themeName)
        {
            if (themeName == "System")
            {
                return _systemPreference == "dark";
            }
            return themeName != "Light";
        }

        private void UpdateDarkModeState()
        {
            IsDarkMode = IsThemeDark(_deviceState.Settings.Theme);
        }

        // ========== LIGHT THEME (Warm Amber) ==========
        private MudTheme GenerateLightTheme()
        {
            return new MudTheme
            {
                PaletteLight = new PaletteLight
                {
                    Primary = "#E07A2E",
                    PrimaryDarken = "#C56820",
                    PrimaryLighten = "#F5A65B",
                    Secondary = "#2D5A45",
                    Tertiary = "#4A7C9B",
                    Info = "#4A7C9B",
                    Success = "#2D5A45",
                    Warning = "#D4A017",
                    Error = "#C44536",
                    Background = "#FBF8F4",
                    Surface = "#FFFFFF",
                    AppbarBackground = "#FFFFFF",
                    AppbarText = "#2C2416",
                    DrawerBackground = "#FFFFFF",
                    TextPrimary = "#2C2416",
                    TextSecondary = "#6B5D4D",
                    ActionDefault = "#6B5D4D",
                    Divider = "#E8E2D9",
                    DividerLight = "#F0EBE4",
                    BackgroundGray = "#F5F0E8"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== DARK THEME (Warm Dark) ==========
        private MudTheme GenerateDarkTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#F5A65B",
                    PrimaryDarken = "#E07A2E",
                    PrimaryLighten = "#FFCF9E",
                    Secondary = "#5DBE8A",
                    Tertiary = "#6BA3C7",
                    Info = "#6BA3C7",
                    Success = "#5DBE8A",
                    Warning = "#F5C842",
                    Error = "#E86B5B",
                    Background = "#1A1612",
                    Surface = "#2C2416",
                    AppbarBackground = "#2C2416",
                    AppbarText = "#F5F0E8",
                    DrawerBackground = "#2C2416",
                    TextPrimary = "#F5F0E8",
                    TextSecondary = "#A89B8A",
                    ActionDefault = "#A89B8A",
                    Divider = "#3D3428",
                    DividerLight = "#4A3F32",
                    BackgroundGray = "#241F19"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== BLACK THEME ==========
        private MudTheme GenerateBlackTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#5e48d4",
                    PrimaryDarken = "#4a38b0",
                    PrimaryLighten = "#7a66e8",
                    Secondary = "#8b5cf6",
                    Tertiary = "#a78bfa",
                    Info = "#5e48d4",
                    Success = "#22c55e",
                    Warning = "#eab308",
                    Error = "#ef4444",
                    Background = "#000000",
                    Surface = "#161515",
                    AppbarBackground = "#0e0e0e",
                    AppbarText = "#ffffff",
                    DrawerBackground = "#161515",
                    TextPrimary = "#ffffff",
                    TextSecondary = "#a1a1aa",
                    ActionDefault = "#a1a1aa",
                    Divider = "#27272a",
                    DividerLight = "#3f3f46",
                    BackgroundGray = "#201f1f"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== MATERIAL THEME ==========
        private MudTheme GenerateMaterialTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#ff6a6a",
                    PrimaryDarken = "#e05555",
                    PrimaryLighten = "#ff8a8a",
                    Secondary = "#64b5f6",
                    Tertiary = "#81c784",
                    Info = "#ff6a6a",
                    Success = "#81c784",
                    Warning = "#ffb74d",
                    Error = "#e57373",
                    Background = "#141414",
                    Surface = "#1e1d1d",
                    AppbarBackground = "#1e1d1d",
                    AppbarText = "#e1e1e1",
                    DrawerBackground = "#1e1d1d",
                    TextPrimary = "#e1e1e1",
                    TextSecondary = "#9e9e9e",
                    ActionDefault = "#9e9e9e",
                    Divider = "#424242",
                    DividerLight = "#616161",
                    BackgroundGray = "#2f2e2e"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        // ========== FOREST THEME (Nattskog) ==========
        private MudTheme GenerateForestTheme()
        {
            return new MudTheme
            {
                PaletteDark = new PaletteDark
                {
                    Primary = "#348202",
                    PrimaryDarken = "#286601",
                    PrimaryLighten = "#4ca812",
                    Secondary = "#238636",
                    Tertiary = "#58a6ff",
                    Info = "#348202",
                    Success = "#238636",
                    Warning = "#d29922",
                    Error = "#f85149",
                    Background = "#0d1117",
                    Surface = "#161b22",
                    AppbarBackground = "#161b22",
                    AppbarText = "#e6edf3",
                    DrawerBackground = "#161b22",
                    TextPrimary = "#e6edf3",
                    TextSecondary = "#8b949e",
                    ActionDefault = "#8b949e",
                    Divider = "#30363d",
                    DividerLight = "#484f58",
                    BackgroundGray = "#14151c"
                },
                Typography = GetTypography(),
                LayoutProperties = new LayoutProperties { DefaultBorderRadius = "16px" }
            };
        }

        private Typography GetTypography()
        {
            return new Typography
            {
                Default = new DefaultTypography
                {
                    FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }
                },
                H1 = new H1Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H2 = new H2Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H3 = new H3Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H4 = new H4Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H5 = new H5Typography { FontFamily = new[] { "Fraunces", "Georgia", "serif" }, FontWeight = "600" },
                H6 = new H6Typography { FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }, FontWeight = "600" },
                Button = new ButtonTypography { FontFamily = new[] { "DM Sans", "system-ui", "sans-serif" }, FontWeight = "600", TextTransform = "none" }
            };
        }
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Services\Theme\ThemeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\IUserFriendshipService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IUserFriendshipService
    {
        // Friendship queries
        Task<FriendshipListDto> GetFriendshipsAsync();
        Task<List<FriendProfileDto>> GetFriendsAsync();
        Task<UserFriendshipDto?> GetFriendshipAsync(Guid id);

        // Friend requests
        Task<UserFriendshipDto> SendFriendRequestAsync(Guid targetUserId);
        Task<UserFriendshipDto> SendFriendRequestByEmailAsync(string email);
        Task<UserFriendshipDto> AcceptFriendRequestAsync(Guid friendshipId);
        Task<UserFriendshipDto> RejectFriendRequestAsync(Guid friendshipId);
        Task RemoveFriendAsync(Guid friendshipId);

        // Search and profiles
        Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20);
        Task<FriendProfileDto?> GetUserProfileAsync(Guid userId);

        // Cache
        List<FriendProfileDto> CachedFriends { get; }
        int PendingRequestCount { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\IUserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\IUserRecipeService.cs
================================================================================
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public interface IUserRecipeService
    {
        // Recipe CRUD
        Task<UserRecipePagedResult> GetMyRecipesAsync(GetUserRecipesQuery? query = null);
        Task<UserRecipeDto?> GetRecipeAsync(Guid id);
        Task<UserRecipeDto> CreateRecipeAsync(CreateUserRecipeDto dto);
        Task<UserRecipeDto> UpdateRecipeAsync(Guid id, UpdateUserRecipeDto dto);
        Task DeleteRecipeAsync(Guid id);

        // Publishing
        Task<PublishRecipeResultDto> PublishRecipeAsync(Guid id);
        Task<UserRecipeDto> DetachRecipeAsync(Guid id);

        // Rating
        Task<UserRecipeDto> RateRecipeAsync(Guid id, int rating, string? comment = null);
        Task RemoveRatingAsync(Guid id);

        // Archiving
        Task<UserRecipeDto> ArchiveRecipeAsync(Guid id);
        Task<UserRecipeDto> RestoreRecipeAsync(Guid id);

        // Household Aggregation (single group - backwards compatible)
        Task<AggregatedRecipePagedResult> GetHouseholdCombinedRecipesAsync(Guid householdId, GetCombinedRecipesQuery? query = null);
        Task<List<CommonFavoriteDto>> GetHouseholdCommonFavoritesAsync(Guid householdId, int minimumMembers = 2, int limit = 10);

        // Multi-group Aggregation
        Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(List<Guid> groupIds, GetCombinedRecipesQuery? query = null);
        Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(List<Guid> groupIds, int minimumMembers = 2, int limit = 10);

        // Friends' Recipes
        Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery? query = null);

        // Cache
        List<UserRecipeDto> CachedRecipes { get; }
        void InvalidateCache();
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\IUserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\UserFriendshipService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class UserFriendshipService : IUserFriendshipService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<FriendProfileDto> CachedFriends { get; private set; } = new();
        public int PendingRequestCount { get; private set; } = 0;

        public UserFriendshipService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthentication()
        {
            if (!_authService.IsAuthenticated)
            {
                throw new UnauthorizedAccessException("You must be logged in to access friendships.");
            }
        }

        public async Task<FriendshipListDto> GetFriendshipsAsync()
        {
            ValidateAuthentication();

            var result = await _apiClient.GetFriendshipsAsync();
            PendingRequestCount = result.PendingReceived?.Count ?? 0;
            return result;
        }

        public async Task<List<FriendProfileDto>> GetFriendsAsync()
        {
            ValidateAuthentication();

            var friends = await _apiClient.GetFriendsAsync();
            CachedFriends = friends;
            return friends;
        }

        public async Task<UserFriendshipDto?> GetFriendshipAsync(Guid id)
        {
            ValidateAuthentication();
            return await _apiClient.GetFriendshipAsync(id);
        }

		public async Task<UserFriendshipDto> SendFriendRequestAsync(Guid targetUserId)
		{
			ValidateAuthentication();

			// FIX 1: Corrected class name from 'SendUserFriendRequestDto' to 'SendFriendRequestDto'
			var dto = new SendFriendRequestDto
			{
				TargetUserId = targetUserId
			};

			var result = await _apiClient.SendFriendRequestAsync(dto);
			InvalidateCache();
			return result;
		}

		public async Task<UserFriendshipDto> SendFriendRequestByEmailAsync(string email)
		{
			ValidateAuthentication();

			if (string.IsNullOrWhiteSpace(email))
				throw new ArgumentException("Email is required.");

			// WARNING: Your backend 'SendFriendRequestDto' does NOT have an Email property.
			// You must add 'public string? TargetEmail { get; set; }' to the DTO in the Shared project
			// and handle it in the Backend Controller for this to work.

			// Assuming you will add it, the code would look like this:
			/*
			var dto = new SendFriendRequestDto { TargetEmail = email };
			var result = await _apiClient.SendFriendRequestAsync(dto);
			InvalidateCache();
			return result;
			*/

			throw new NotImplementedException("The backend DTO is missing the 'TargetEmail' property.");
		}

		public async Task<UserFriendshipDto> AcceptFriendRequestAsync(Guid friendshipId)
		{
			ValidateAuthentication();

			// FIX 2: Create the expected DTO with the string action "accept"
			var dto = new RespondFriendRequestDto { Action = "accept" };

			// Update ApiClient call to pass the object, not an enum
			var result = await _apiClient.RespondToFriendRequestAsync(friendshipId, dto);

			InvalidateCache();
			return result;
		}

		public async Task<UserFriendshipDto> RejectFriendRequestAsync(Guid friendshipId)
		{
			ValidateAuthentication();

			// FIX 2: Create the expected DTO with the string action "reject"
			var dto = new RespondFriendRequestDto { Action = "reject" };

			// Update ApiClient call to pass the object, not an enum
			var result = await _apiClient.RespondToFriendRequestAsync(friendshipId, dto);

			InvalidateCache();
			return result;
		}

		public async Task RemoveFriendAsync(Guid friendshipId)
        {
            ValidateAuthentication();

            await _apiClient.RemoveFriendshipAsync(friendshipId);
            InvalidateCache();
        }

        public async Task<List<UserSearchResultDto>> SearchUsersAsync(string query, int limit = 20)
        {
            ValidateAuthentication();

            if (string.IsNullOrWhiteSpace(query))
                return new List<UserSearchResultDto>();

            return await _apiClient.SearchUsersAsync(query, limit);
        }

        public async Task<FriendProfileDto?> GetUserProfileAsync(Guid userId)
        {
            ValidateAuthentication();
            return await _apiClient.GetUserProfileAsync(userId);
        }

        public void InvalidateCache()
        {
            CachedFriends = new List<FriendProfileDto>();
            PendingRequestCount = 0;
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\UserFriendshipService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Services\User\UserRecipeService.cs
================================================================================
using StorhaugenWebsite.ApiClient;
using StorhaugenWebsite.Shared.DTOs;

namespace StorhaugenWebsite.Services
{
    public class UserRecipeService : IUserRecipeService
    {
        private readonly IApiClient _apiClient;
        private readonly IAuthService _authService;

        public List<UserRecipeDto> CachedRecipes { get; private set; } = new();

        public UserRecipeService(IApiClient apiClient, IAuthService authService)
        {
            _apiClient = apiClient;
            _authService = authService;
        }

        private void ValidateAuthorization()
        {
            if (!_authService.IsAuthorized)
            {
                throw new UnauthorizedAccessException("You are not authorized to perform this action.");
            }
        }

        public async Task<UserRecipePagedResult> GetMyRecipesAsync(GetUserRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            query ??= new GetUserRecipesQuery();
            var result = await _apiClient.GetMyUserRecipesAsync(query);

            // Update cache with first page results
            if (query.Page == 1 && !query.IncludeArchived)
            {
                CachedRecipes = result.Recipes;
            }

            return result;
        }

        public async Task<UserRecipeDto?> GetRecipeAsync(Guid id)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            return await _apiClient.GetUserRecipeAsync(id);
        }

        public async Task<UserRecipeDto> CreateRecipeAsync(CreateUserRecipeDto dto)
        {
            ValidateAuthorization();

            if (string.IsNullOrWhiteSpace(dto.Name) && !dto.GlobalRecipeId.HasValue)
                throw new ArgumentException("Recipe must have either a title or be linked to a global recipe.");

            var result = await _apiClient.CreateUserRecipeAsync(dto);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> UpdateRecipeAsync(Guid id, UpdateUserRecipeDto dto)
        {
            ValidateAuthorization();

            var result = await _apiClient.UpdateUserRecipeAsync(id, dto);
            InvalidateCache();
            return result;
        }

        public async Task DeleteRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            await _apiClient.DeleteUserRecipeAsync(id);
            InvalidateCache();
        }

        public async Task<PublishRecipeResultDto> PublishRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.PublishUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> DetachRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.DetachUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> RateRecipeAsync(Guid id, int rating, string? comment = null)
        {
            ValidateAuthorization();

            if (rating < 1 || rating > 10)
                throw new ArgumentException("Rating must be between 1 and 10.");

            var result = await _apiClient.RateUserRecipeAsync(id, rating, comment);
            InvalidateCache();
            return result;
        }

        public async Task RemoveRatingAsync(Guid id)
        {
            ValidateAuthorization();

            await _apiClient.RemoveUserRecipeRatingAsync(id);
            InvalidateCache();
        }

        public async Task<UserRecipeDto> ArchiveRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.ArchiveUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<UserRecipeDto> RestoreRecipeAsync(Guid id)
        {
            ValidateAuthorization();

            var result = await _apiClient.RestoreUserRecipeAsync(id);
            InvalidateCache();
            return result;
        }

        public async Task<AggregatedRecipePagedResult> GetHouseholdCombinedRecipesAsync(Guid householdId, GetCombinedRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            query ??= new GetCombinedRecipesQuery();
            return await _apiClient.GetHouseholdCombinedRecipesAsync(householdId, query);
        }

        public async Task<List<CommonFavoriteDto>> GetHouseholdCommonFavoritesAsync(Guid householdId, int minimumMembers = 2, int limit = 10)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            return await _apiClient.GetHouseholdCommonFavoritesAsync(householdId, minimumMembers, limit);
        }

        // Multi-group Aggregation
        public async Task<AggregatedRecipePagedResult> GetGroupsCombinedRecipesAsync(List<Guid> groupIds, GetCombinedRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            if (groupIds == null || !groupIds.Any())
                return new AggregatedRecipePagedResult();

            query ??= new GetCombinedRecipesQuery();
            var multiGroupQuery = new GetMultiGroupRecipesQuery
            {
                GroupIds = groupIds,
                FilterByMembers = query.FilterByMembers,
                MinRating = query.MinRating,
                Search = query.Search,
                SortBy = query.SortBy,
                SortDescending = query.SortDescending,
                Page = query.Page,
                PageSize = query.PageSize
            };

            return await _apiClient.GetGroupsCombinedRecipesAsync(multiGroupQuery);
        }

        public async Task<List<CommonFavoriteDto>> GetGroupsCommonFavoritesAsync(List<Guid> groupIds, int minimumMembers = 2, int limit = 10)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            if (groupIds == null || !groupIds.Any())
                return new List<CommonFavoriteDto>();

            var query = new GetMultiGroupFavoritesQuery
            {
                GroupIds = groupIds,
                MinMembers = minimumMembers,
                Limit = limit
            };

            return await _apiClient.GetGroupsCommonFavoritesAsync(query);
        }

        public async Task<UserRecipePagedResult> GetFriendsRecipesAsync(GetUserRecipesQuery? query = null)
        {
            if (!_authService.IsAuthenticated)
                throw new UnauthorizedAccessException();

            query ??= new GetUserRecipesQuery();
            return await _apiClient.GetFriendsRecipesAsync(query);
        }

        public void InvalidateCache()
        {
            CachedRecipes = new List<UserRecipeDto>();
        }
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Services\User\UserRecipeService.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\Authorization.razor
================================================================================
<div class="login-required-container">
    <div class="empty-state">
        <div class="empty-state-icon">
            <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Large" />
        </div>
        <h2 class="empty-state-title">Vennligst logg inn</h2>
        <p class="empty-state-text">@Text</p>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="login" Size="Size.Large">
            G til innlogging
        </MudButton>
    </div>
</div>

@code {
    [Parameter] public string Text { get; set; } = "Du m vre logget inn for  se denne siden";
}

================================================================================
FILE END: \StorhaugenWebsite\Shared\Authorization.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\Authorization.razor.css
================================================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Shared\Authorization.razor.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\MainLayout.razor
================================================================================
@inherits LayoutComponentBase
@inject IAuthService AuthService
@inject NavigationManager Navigation
@using StorhaugenWebsite.Shared
@using StorhaugenWebsite.Components

<MudLayout>
    <MudAppBar Elevation="0" Class="app-header">
        <div class="d-flex align-center gap-2">
            <div class="brand-icon">
                <MudIcon Icon="@Icons.Material.Rounded.DinnerDining" Size="Size.Small" />
            </div>
            <MudText Typo="Typo.h6" Class="brand-text">Storhaugen</MudText>
        </div>
        <MudSpacer />
        @if (AuthService.IsAuthorized)
        {
            <NotificationBell />
            <MudIconButton Icon="@Icons.Material.Rounded.Settings"
                           Color="Color.Inherit"
                           OnClick="@(() => Navigation.NavigateTo("settings"))"
                           Size="Size.Medium" />
        }
    </MudAppBar>

    <MudMainContent Class="main-content">
        <MudContainer MaxWidth="MaxWidth.Small" Class="page-container">
            @if (IsAccessAllowed())
            {
                @Body
            }
            else
            {
                <Authorization Text="Du m vre medlem av en husstand for  se denne siden." />
            }
        </MudContainer>
    </MudMainContent>

    @if (AuthService.IsAuthorized)
    {
        <div class="bottom-nav">
            <div class="bottom-nav-inner">
                <button class="nav-item @(IsActive("") ? "active" : "")" @onclick="@(() => Navigate(""))">
                    <MudIcon Icon="@(IsActive("") ? Icons.Material.Rounded.Home : Icons.Material.Outlined.Home)" Size="Size.Small" />
                    <span>Hjem</span>
                </button>

                <button class="nav-item @(IsActive("cookbook") ? "active" : "")" @onclick="@(() => Navigate("cookbook"))">
                    <MudIcon Icon="@(IsActive("cookbook") ? Icons.Material.Rounded.MenuBook : Icons.Material.Outlined.MenuBook)" Size="Size.Small" />
                    <span>Kokebok</span>
                </button>

                <button class="nav-item nav-item-add @(IsActive("add") ? "active" : "")" @onclick="@(() => Navigate("add"))">
                    <div class="add-button">
                        <MudIcon Icon="@Icons.Material.Rounded.Add" Size="Size.Medium" />
                    </div>
                    <span>Ny</span>
                </button>

                <button class="nav-item @(IsActive("friends") ? "active" : "")" @onclick="@(() => Navigate("friends"))">
                    <MudIcon Icon="@(IsActive("friends") ? Icons.Material.Rounded.People : Icons.Material.Outlined.People)" Size="Size.Small" />
                    <span>Venner</span>
                </button>

                <button class="nav-item @(IsActive("households") ? "active" : "")" @onclick="@(() => Navigate("households"))">
                    <MudIcon Icon="@(IsActive("households") ? Icons.Material.Rounded.HomeWork : Icons.Material.Outlined.HomeWork)" Size="Size.Small" />
                    <span>Husstand</span>
                </button>
            </div>
        </div>
    }
</MudLayout>

@code {
    protected override void OnInitialized()
    {
        AuthService.OnAuthStateChanged += StateHasChanged;
        Navigation.LocationChanged += OnLocationChanged;
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        StateHasChanged();
    }

    private bool IsAccessAllowed()
    {
        if (AuthService.IsAuthorized) return true;

        var currentPath = Navigation.ToBaseRelativePath(Navigation.Uri).ToLower();

        if (string.IsNullOrEmpty(currentPath) || currentPath.StartsWith("login"))
        {
            return true;
        }

        return false;
    }

    private bool IsActive(string path)
    {
        var currentPath = Navigation.ToBaseRelativePath(Navigation.Uri);

        // Exact match for Home ("")
        if (string.IsNullOrEmpty(path))
            return string.IsNullOrEmpty(currentPath);

        // Starts with match for others (e.g. "browse" matches "browse/123")
        return currentPath.StartsWith(path, StringComparison.OrdinalIgnoreCase);
    }

    private void Navigate(string path)
    {
        Navigation.NavigateTo(path);
    }

    public void Dispose()
    {
        AuthService.OnAuthStateChanged -= StateHasChanged;
        Navigation.LocationChanged -= OnLocationChanged;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\Shared\MainLayout.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Shared\MainLayout.razor.css
================================================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}


================================================================================
FILE END: \StorhaugenWebsite\Shared\MainLayout.razor.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\app.css
================================================================================
/* Fonts */
@import url('https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=Fraunces:ital,opsz,wght@0,9..144,400;0,9..144,500;0,9..144,600;0,9..144,700;1,9..144,400&display=swap');

/* CSS Variables */
:root {
    --app-bar-height: 56px;
    --bottom-nav-height: 56px;
    --page-padding: 20px;
    --card-radius: 20px;
    --transition-fast: 150ms ease;
    --transition-smooth: 300ms cubic-bezier(0.4, 0, 0.2, 1);
    /* Member Colors */
    --color-markus: #E07A2E;
    --color-siv: #2D5A45;
    --color-elias: #4A7C9B;
}

/* Base */
html {
    scroll-behavior: smooth;
    -webkit-tap-highlight-color: transparent;
}

body {
    font-family: 'DM Sans', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overscroll-behavior: none;
}

/* SHARED: Food Cards (Used in Home & Archive) */
.food-card {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius);
    overflow: hidden;
    transition: var(--transition-smooth);
    cursor: pointer;
    border: 1px solid var(--mud-palette-divider);
}

    .food-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 32px rgba(44, 36, 22, 0.12);
        border-color: transparent;
    }

    .food-card:active {
        transform: scale(0.98);
    }

.food-card-image {
    width: 100%;
    aspect-ratio: 16/10;
    object-fit: cover;
    background: var(--mud-palette-divider-light);
}

.food-card-placeholder {
    width: 100%;
    aspect-ratio: 16/10;
    background: linear-gradient(135deg, var(--mud-palette-divider-light), var(--mud-palette-divider));
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--mud-palette-text-secondary);
}

.food-card-content {
    padding: 16px;
}

.food-card-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--mud-palette-text-primary);
}

.food-card-meta {
    font-size: 0.8rem;
    color: var(--mud-palette-text-secondary);
    margin-top: 12px;
}

/* SHARED: List View Items */
.food-list-item {
    display: flex;
    gap: 14px;
    padding: 14px;
    background: var(--mud-palette-surface);
    border-radius: 16px;
    border: 1px solid var(--mud-palette-divider);
    cursor: pointer;
    transition: var(--transition-smooth);
}

    .food-list-item:hover {
        border-color: transparent;
        box-shadow: 0 8px 24px rgba(44, 36, 22, 0.1);
    }

    .food-list-item:active {
        transform: scale(0.99);
    }

.food-list-image {
    width: 72px;
    height: 72px;
    border-radius: 12px;
    object-fit: cover;
    flex-shrink: 0;
    background: var(--mud-palette-divider-light);
}

.food-list-placeholder {
    width: 72px;
    height: 72px;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--mud-palette-divider-light), var(--mud-palette-divider));
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: var(--mud-palette-text-secondary);
}

.food-list-content {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.food-list-title {
    font-weight: 600;
    font-size: 0.95rem;
    margin-bottom: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.food-list-date {
    font-size: 0.75rem;
    color: var(--mud-palette-text-secondary);
    margin-top: 6px;
}

.food-list-rating {
    flex-shrink: 0;
    display: flex;
    align-items: center;
}

/* SHARED: Rating Badges */
.rating-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.9rem;
}

    .rating-badge.rating-high {
        background: rgba(45, 90, 69, 0.12);
        color: var(--color-siv);
    }

    .rating-badge.rating-medium {
        background: rgba(212, 160, 23, 0.12);
        color: #B38600;
    }

    .rating-badge.rating-low {
        background: rgba(196, 69, 54, 0.12);
        color: #C44536;
    }

/* SHARED: Member Ratings (Avatars) */
.member-ratings {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.member-rating {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px 4px 4px;
    background: var(--mud-palette-divider-light);
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 500;
}

.member-rating-avatar {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 0.7rem;
    font-weight: 600;
}

.member-rating.markus .member-rating-avatar {
    background: var(--color-markus);
}

.member-rating.siv .member-rating-avatar {
    background: var(--color-siv);
}

.member-rating.elias .member-rating-avatar {
    background: var(--color-elias);
}

.member-rating-value {
    color: var(--mud-palette-text-primary);
}

.member-rating-empty {
    color: var(--mud-palette-text-secondary);
    opacity: 0.6;
}

/* SHARED: Animations */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(16px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.animate-in {
    animation: fadeInUp 0.4s ease forwards;
}

.animate-delay-1 {
    animation-delay: 0.05s;
}

.animate-delay-2 {
    animation-delay: 0.1s;
}

.animate-delay-3 {
    animation-delay: 0.15s;
}

.animate-delay-4 {
    animation-delay: 0.2s;
}

@keyframes shimmer {
    0% {
        background-position: -200% 0;
    }

    100% {
        background-position: 200% 0;
    }
}

/* MudBlazor Overrides */
.mud-input-outlined .mud-input-slot-input {
    font-size: 16px !important;
}

.mud-button {
    text-transform: none !important;
    font-weight: 600 !important;
}

.mud-chip {
    font-weight: 600 !important;
}

.mud-snackbar-location-bottom-center {
    bottom: calc(var(--bottom-nav-height) + 16px) !important;
}

/* Error UI */
#blazor-error-ui {
    background: var(--mud-palette-error);
    bottom: 0;
    box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.2);
    display: none;
    left: 0;
    padding: 0.6rem 1.25rem 0.7rem;
    position: fixed;
    width: 100%;
    z-index: 1000;
    color: white;
}

    #blazor-error-ui .dismiss {
        cursor: pointer;
        position: absolute;
        right: 0.75rem;
        top: 0.5rem;
    }


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\app.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Food.css
================================================================================
/* ==========================================================================
   1. LANDSCAPE BLOCKER & DEVICE ORIENTATION
   Unique logic to handle device rotation for camera features.
   ========================================================================== */

#landscape-blocker {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    height: 100dvh; /* Mobile viewport fix */
    background: #0f172a; /* Dark background */
    z-index: 999999; /* Above everything */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    padding: 20px;
}

/* Only show blocker when screen is actually in Landscape */
@media screen and (orientation: landscape) {
    #landscape-blocker {
        display: flex !important;
    }
    /* Hide content behind it to prevent scrolling */
    .app-content-container {
        display: none !important;
    }
}

/* ==========================================================================
   2. GLOBAL PAGE STYLES & HEADERS
   Merged: Prioritizing 'Fraunces' font and MudBlazor palette variables.
   ========================================================================== */

.page-header {
    margin-bottom: 24px;
}

.page-title {
    font-family: 'Fraunces', Georgia, serif; /* Kept fancy font from File 1 */
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--mud-palette-text-primary);
    margin-bottom: 4px;
    letter-spacing: -0.02em;
}

.page-subtitle {
    font-size: 0.9rem;
    color: var(--mud-palette-text-secondary);
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 60px 24px;
}

.empty-state-icon {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: var(--mud-palette-divider-light);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 20px;
    color: var(--mud-palette-text-secondary);
}

.empty-state-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 8px;
}

.empty-state-text {
    color: var(--mud-palette-text-secondary);
    margin-bottom: 24px;
}

/* ==========================================================================
   3. FORM STYLES & INPUTS
   Merged: Unified .form-section and image uploads.
   ========================================================================== */

.form-section {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 16px); /* Fallback to 16px if variable missing */
    padding: 20px;
    margin-bottom: 16px;
    border: 1px solid var(--mud-palette-divider);
    /* box-shadow removed to keep consistent with flat border design of File 1 */
}

.form-section-title {
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--mud-palette-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 16px;
}

/* Rating Slider Components */
.rating-member-card {
    background: var(--mud-palette-background);
    border-radius: 14px;
    padding: 14px;
    margin-bottom: 12px;
}

.rating-member-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.rating-member-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.rating-member-avatar {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 0.9rem;
}

.rating-slider-container {
    margin-top: 14px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.rating-value-display {
    min-width: 44px;
    height: 36px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1rem;
}

/* ==========================================================================
   4. IMAGE UPLOAD & PREVIEWS
   Merged: Used the interactive/hover styles from File 1.
   ========================================================================== */

.image-upload-area {
    border: 2px dashed var(--mud-palette-divider);
    border-radius: 14px;
    padding: 24px;
    text-align: center;
    transition: var(--transition-fast, 0.2s ease);
    cursor: pointer;
}

    .image-upload-area:hover {
        border-color: var(--mud-palette-primary);
        background: rgba(224, 122, 46, 0.04);
    }

.image-preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    margin-bottom: 14px;
}

.image-preview-item {
    position: relative;
    aspect-ratio: 1;
    border-radius: 12px;
    overflow: hidden;
}

    .image-preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

.image-preview-remove {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: var(--transition-fast, 0.2s ease);
}

    .image-preview-remove:hover {
        background: var(--mud-palette-error);
    }

/* ==========================================================================
   5. CAMERA OVERLAY & SCANNING LOGIC
   Taken entirely from File 2.
   ========================================================================== */

.camera-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
    background: #000;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.camera-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(1) !important;
}

/* Guide Box Container */
.camera-guide-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10002;
    transition: all 0.5s ease;
}

.camera-guide-box {
    border: 3px solid rgba(255, 255, 255, 0.9);
    border-radius: 16px;
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8);
    position: relative;
    overflow: hidden;
    background: transparent;
}

/* --- Camera Scanning Steps --- */

/* STEP 1: Landscape Mode (Visual "Landscape" box on Portrait screen) */
.camera-guide-container.step-landscape .camera-guide-box {
    width: 95vw; /* Wider */
    aspect-ratio: 3/4; /* Shorter (was 9/16) */
    max-height: 70vh;
}

/* Logo Hint Zone - MODIFIED: Removed CSS Lemon hack, optimized for SVG */
.step-landscape .logo-hint-zone {
    position: absolute;
    top: 20px;
    right: 20px;
    /* Removed fixed width/height to let SVG scale */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: rotate(90deg); /* Keep rotation for landscape card */
    opacity: 0.9;
}

    .step-landscape .logo-hint-zone::before {
        display: none;
    }

.step-landscape .logo-label {
    color: #ffffff;
    font-weight: 800;
    font-size: 11px;
    text-transform: uppercase;
    text-align: center;
    line-height: 1;
}

/* Text Hint Zone (Rotated 90 deg) */
.step-landscape .text-hint-zone {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(90deg);
    width: 60vh; /* Based on height since it's rotated */
    height: 60px;
    border: 2px dashed rgba(255,255,255,0.5);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.step-landscape .text-label {
    color: rgba(255,255,255,0.9);
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
    transform: rotate(90deg);
}

/* STEP 2: Ingredients (Portrait Tall) */
.camera-guide-container.step-portrait-tall .camera-guide-box {
    width: 65vw;
    height: 70vh;
}

/* STEP 3: Normal Portrait */
.camera-guide-container.step-portrait-normal .camera-guide-box {
    width: 85vw;
    aspect-ratio: 210/297;
    max-width: 450px;
}

/* --- Camera Animations & Controls --- */

.scan-line {
    width: 100%;
    height: 2px;
    background: #00E676;
    position: absolute;
    top: 0;
    box-shadow: 0 0 10px #00E676;
    animation: scanAnim 3s infinite;
}

@keyframes scanAnim {
    0% {
        top: 5%;
        opacity: 0;
    }

    20% {
        opacity: 1;
    }

    80% {
        opacity: 1;
    }

    100% {
        top: 95%;
        opacity: 0;
    }
}

.camera-instruction-pill {
    position: absolute;
    top: 24px;
    background: rgba(0,0,0,0.6);
    padding: 8px 16px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(4px);
    z-index: 10001;
}

.step-text {
    color: #00E676;
    font-weight: bold;
    font-size: 12px;
}

.camera-guide-text {
    position: absolute;
    bottom: 120px;
    color: white;
    text-align: center;
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    max-width: 80%;
    z-index: 10001;
}

.camera-controls {
    position: absolute;
    bottom: 30px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 32px;
    z-index: 10000;
    pointer-events: auto;
}

.step-counter {
    color: white;
    font-weight: bold;
    font-size: 14px;
    width: 48px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    padding: 4px 8px;
    border-radius: 8px;
}

.camera-shutter {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3); /* Semi-transparent outer ring */
    border: 4px solid #fff; /* Solid white border */
    position: relative;
    cursor: pointer;
    transition: transform 0.1s, background 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5); /* Drop shadow to separate from background */
}

    .camera-shutter::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 54px; /* Slightly smaller inner circle */
        height: 54px;
        border-radius: 50%;
        background: #ffffff; /* Solid white inner button */
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .camera-shutter:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.5);
    }

    .camera-shutter.processing {
        border-color: #999;
        pointer-events: none;
    }

        .camera-shutter.processing::after {
            width: 20px;
            height: 20px;
            background: #999;
            animation: spin 1s infinite linear;
        }

@keyframes spin {
    100% {
        transform: rotate(360deg);
    }
}

/* ==========================================================================
   6. FOOD LIST & UTILITIES (VIEW TOGGLE, SORTING, SKELETONS)
   ========================================================================== */

/* View Toggle */
.view-toggle-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    gap: 12px;
}

.view-toggle {
    display: flex;
    background: var(--mud-palette-surface);
    border-radius: 12px;
    padding: 4px;
    border: 1px solid var(--mud-palette-divider);
}

.view-toggle-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 36px;
    border: none;
    background: transparent;
    color: var(--mud-palette-text-secondary);
    cursor: pointer;
    border-radius: 8px;
    transition: var(--transition-fast, 0.2s);
}

    .view-toggle-btn:hover {
        background: var(--mud-palette-divider-light);
    }

    .view-toggle-btn.active {
        background: var(--mud-palette-primary);
        color: white;
    }

/* Sort Dropdown */
.sort-dropdown {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--mud-palette-surface);
    border: 1px solid var(--mud-palette-divider);
    border-radius: 12px;
    cursor: pointer;
    font-size: 0.875rem;
    color: var(--mud-palette-text-secondary);
    transition: var(--transition-fast, 0.2s);
}

    .sort-dropdown:hover {
        border-color: var(--mud-palette-primary);
    }

/* Skeleton Loading */
.skeleton-card {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 12px);
    overflow: hidden;
    border: 1px solid var(--mud-palette-divider);
}

.skeleton-image {
    aspect-ratio: 16/10;
    background: linear-gradient(90deg, var(--mud-palette-divider-light) 25%, var(--mud-palette-divider) 50%, var(--mud-palette-divider-light) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
}

.skeleton-content {
    padding: 16px;
}

.skeleton-text {
    height: 14px;
    border-radius: 6px;
    background: var(--mud-palette-divider-light);
    margin-bottom: 10px;
}

    .skeleton-text.title {
        height: 20px;
        width: 60%;
    }

    .skeleton-text.subtitle {
        width: 40%;
    }

/* ==========================================================================
   7. FOOD DETAILS PAGE
   ========================================================================== */

.detail-header {
    margin-bottom: 20px;
}

.detail-back-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    background: var(--mud-palette-surface);
    border: 1px solid var(--mud-palette-divider);
    border-radius: 10px;
    color: var(--mud-palette-text-secondary);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-fast, 0.2s);
    font-family: 'DM Sans', system-ui, sans-serif;
}

    .detail-back-btn:hover {
        border-color: var(--mud-palette-primary);
        color: var(--mud-palette-primary);
    }

.detail-image-carousel {
    border-radius: var(--card-radius, 12px);
    overflow: hidden;
    margin-bottom: 20px;
}

.detail-info-card {
    background: var(--mud-palette-surface);
    border-radius: var(--card-radius, 12px);
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid var(--mud-palette-divider);
}

.detail-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 8px;
}

.detail-meta {
    font-size: 0.85rem;
    color: var(--mud-palette-text-secondary);
    margin-bottom: 12px;
}

.detail-description {
    color: var(--mud-palette-text-secondary);
    line-height: 1.6;
}

/* Visibility Card */
.visibility-card {
    background: var(--mud-palette-background);
    border-radius: 14px;
    padding: 14px;
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Food.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Layout.css
================================================================================
/* App Header */
.app-header {
    background: var(--mud-palette-surface) !important;
    border-bottom: 1px solid var(--mud-palette-divider);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}

.brand-icon {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
}

.brand-text {
    font-family: 'Fraunces', Georgia, serif !important;
    font-weight: 600 !important;
    letter-spacing: -0.02em;
}

/* Main Content */
.main-content {
    background: var(--mud-palette-background);
    min-height: 100vh;
    padding-top: var(--app-bar-height);
    padding-bottom: calc(var(--bottom-nav-height) + 12px);
}

.page-container {
    padding: var(--page-padding) !important;
    max-width: 540px !important;
}

@media (max-width: 600px) {
    .page-container {
        padding: 16px !important;
    }
}

/* Bottom Navigation - Docked Style */
.bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1100;
    /* Remove padding to make it flush with edges */
    padding: 0;
    /* Background moves here to cover the whole bottom area */
    background: var(--mud-palette-surface);
    /* Add a subtle top border for separation */
    border-top: 1px solid var(--mud-palette-divider);
    /* Handle iPhone/Android Gesture bar area */
    padding-bottom: env(safe-area-inset-bottom);
    /* Ensure the bar blocks clicks behind it */
    pointer-events: auto;
}

.bottom-nav-inner {
    width: 100%;
    /* Max width prevents it from stretching too far on desktop */
    max-width: 600px;
    margin: 0 auto; /* Center on desktop */
    /* Remove pill styling */
    border-radius: 0;
    background: transparent;
    box-shadow: none;
    /* Adjust padding for the docked look */
    padding: 8px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: var(--bottom-nav-height);
}

.nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1; /* Distribute space evenly */
    gap: 4px;
    border: none;
    background: transparent;
    color: var(--mud-palette-text-secondary);
    cursor: pointer;
    transition: color 0.2s ease;
    height: 100%;
}

    .nav-item span {
        font-size: 11px;
        font-weight: 500;
        letter-spacing: 0.01em;
    }

    .nav-item:hover {
        color: var(--mud-palette-text-primary);
    }

    .nav-item.active {
        color: var(--mud-palette-primary);
    }

/* The Add Button Container - Pops out slightly */
.nav-item-add {
    position: relative;
    top: -10px; /* Changed from -20px. Sits lower in the bar. */
    height: auto;
    overflow: visible;
}

/* The Orange Button Itself */
.add-button {
    width: 48px; /* Changed from 56px. Smaller footprint. */
    height: 48px; /* Changed from 56px. */
    border-radius: 50%;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    /* Reduced border width slightly to match new size */
    border: 3px solid var(--mud-palette-surface);
    /* Reduced shadow opacity and spread for a softer look */
    box-shadow: 0 2px 8px rgba(224, 122, 46, 0.25);
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.nav-item-add:hover .add-button {
    transform: scale(1.05); /* Slightly smaller hover effect */
    box-shadow: 0 4px 12px rgba(224, 122, 46, 0.4);
}

.nav-item-add:active .add-button {
    transform: scale(0.95);
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Layout.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\css\Login.css
================================================================================
.login-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 80vh;
    text-align: center;
    padding: 24px;
}

.login-card {
    background: var(--mud-palette-surface);
    border-radius: 24px;
    padding: 40px 32px;
    width: 100%;
    max-width: 360px;
    border: 1px solid var(--mud-palette-divider);
}

.login-logo {
    width: 64px;
    height: 64px;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--mud-palette-primary), var(--mud-palette-primary-darken));
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    margin: 0 auto 24px;
}

.login-title {
    font-family: 'Fraunces', Georgia, serif;
    font-size: 1.75rem;
    font-weight: 600;
    margin-bottom: 8px;
}

    .login-title:focus,
    .login-title:focus-visible {
        outline: none;
    }

.login-subtitle {
    color: var(--mud-palette-text-secondary);
    margin-bottom: 32px;
}

.login-btn {
    width: 100%;
    padding: 14px 24px;
    border-radius: 14px;
    border: none;
    background: var(--mud-palette-text-primary);
    color: var(--mud-palette-surface);
    font-weight: 600;
    font-size: 0.95rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    transition: var(--transition-smooth);
    font-family: 'DM Sans', system-ui, sans-serif;
}

    .login-btn:hover {
        opacity: 0.9;
        transform: translateY(-1px);
    }

    .login-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

.login-footer {
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid var(--mud-palette-divider);
}

.login-avatars {
    display: flex;
    justify-content: center;
    gap: 8px;
}

.login-avatar {
    width: 32px;
    height: 32px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 0.8rem;
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\css\Login.css
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\js\deviceState.js
================================================================================
window.deviceState = {
    get: function (key) {
        return localStorage.getItem(key);
    },
    set: function (key, value) {
        localStorage.setItem(key, value);
    },
    remove: function (key) {
        localStorage.removeItem(key);
    },
    getPreferredTheme: function () {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        return 'light';
    }
};

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\js\deviceState.js
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\js\ocrInterop.js
================================================================================
// ==========================================
// 1. CAMERA INTEROP (Video Stream & Capture)
// ==========================================
window.cameraInterop = {
    stream: null,

    start: async (videoElement) => {
        if (window.cameraInterop.stream) {
            window.cameraInterop.stream.getTracks().forEach(track => track.stop());
            window.cameraInterop.stream = null;
        }

        try {
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    focusMode: 'continuous' // Try to force focus
                }
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = stream;
            window.cameraInterop.stream = stream;

            // Wait a moment for camera to adjust focus/exposure
            const track = stream.getVideoTracks()[0];
            if (track.getCapabilities && track.getCapabilities().focusMode) {
                try { await track.applyConstraints({ advanced: [{ focusMode: "continuous" }] }); } catch (e) { }
            }
        }
        catch (err) {
            console.error("Camera Error:", err);
        }
    },

    capture: async (videoElement) => {
        const canvas = document.createElement("canvas");
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        // Draw image
        canvas.getContext('2d').drawImage(videoElement, 0, 0);
        return canvas.toDataURL("image/jpeg", 0.95); // High quality for OCR
    },

    stop: (videoElement) => {
        if (window.cameraInterop.stream) {
            window.cameraInterop.stream.getTracks().forEach(track => track.stop());
            window.cameraInterop.stream = null;
        }
        if (videoElement) {
            videoElement.srcObject = null;
        }
    }
};

// ==========================================
// 2. IMAGE TOOLS
// ==========================================
window.imageTools = {
    processInputFile: async (inputId) => {
        const input = document.getElementById(inputId);
        if (!input || !input.files || input.files.length === 0) return [];

        const processedImages = [];
        for (let i = 0; i < input.files.length; i++) {
            const file = input.files[i];
            try {
                // Resize to max 2000px - bigger is often better for text detection
                const base64 = await resizeImage(file, 2000, 2000);
                processedImages.push({ name: file.name, data: base64 });
            } catch (err) {
                console.error("Error processing file:", err);
            }
        }
        input.value = '';
        return processedImages;
    }
};

function resizeImage(file, maxWidth, maxHeight) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
            const img = new Image();
            img.src = event.target.result;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width *= maxHeight / height;
                        height = maxHeight;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                resolve(canvas.toDataURL('image/jpeg', 0.9));
            };
        };
    });
}

// ==========================================
// 3. OCR INTEROP (Robust Rotation Logic)
// ==========================================
window.ocrInterop = {
    recognizeTextFromImage: async (base64Image) => {
        if (typeof Tesseract === 'undefined') {
            console.error("Tesseract.js not loaded.");
            return "Error: Tesseract missing";
        }

        try {
            console.log("OCR Start...");
            const img = new Image();
            img.src = base64Image;
            await new Promise(r => img.onload = r);

            // Create worker with better config
            const worker = await Tesseract.createWorker('nor');
            await worker.setParameters({
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                preserve_interword_spaces: '1',
            });

            // --- STRATEGY: Try 0 -> 90 -> 270 (270 is needed for your Title image) ---

            // 1. Try Normal (0 deg)
            let bestText = await tryRecognize(worker, img, 0);

            // 2. If result looks bad, try Landscape (90 deg)
            if (isTextGarbage(bestText)) {
                console.log("Text garbage at 0deg. Trying 90deg...");
                const text90 = await tryRecognize(worker, img, 90);
                if (countLetters(text90) > countLetters(bestText)) bestText = text90;
            }

            // 3. If result still looks bad, try Inverse Landscape (270 deg)
            // This is CRITICAL for the "Spr katsu" image you provided
            if (isTextGarbage(bestText)) {
                console.log("Text garbage. Trying 270deg (bottom-to-top text)...");
                const text270 = await tryRecognize(worker, img, 270);
                if (countLetters(text270) > countLetters(bestText)) bestText = text270;
            }

            await worker.terminate();
            return bestText;

        } catch (error) {
            console.error("OCR Error:", error);
            return null;
        }
    }
};

async function tryRecognize(worker, imgElement, rotation) {
    // Preprocess: Rotate -> Grayscale -> Contrast
    const processedBase64 = preprocessImageForOCR(imgElement, rotation);
    const result = await worker.recognize(processedBase64);
    console.log(`Result at ${rotation}deg:`, result.data.text.substring(0, 50) + "...");
    return result.data.text;
}

// REPLACE THESE FUNCTIONS IN ocrinterop.js

function countLetters(text) {
    if (!text) return 0;
    // Fix: Count Letters AND Numbers as valid content
    return text.replace(/[^a-zA-Z0-9]/g, '').length;
}

function isTextGarbage(text) {
    if (!text || text.length < 3) return true; // Lowered min length slightly
    const validCharCount = countLetters(text);

    // Ingredients often have many spaces/newlines, so we lower the threshold
    // If less than 30% of the content is alphanumeric, it's noise
    return (validCharCount / text.length) < 0.30;
}

// Advanced Preprocessing: High Contrast Grayscale (Better than hard threshold)
function preprocessImageForOCR(imgElement, rotateDegrees) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Swap dimensions for rotation
    if (rotateDegrees === 90 || rotateDegrees === 270) {
        canvas.width = imgElement.height;
        canvas.height = imgElement.width;
    } else {
        canvas.width = imgElement.width;
        canvas.height = imgElement.height;
    }

    // 1. ROTATE
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(rotateDegrees * Math.PI / 180);
    ctx.drawImage(imgElement, -imgElement.width / 2, -imgElement.height / 2);

    // 2. CONTRAST & GRAYSCALE
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const contrast = 1.5; // Increase contrast by 50%
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // Standard Grayscale
        let gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;

        // Apply High Contrast
        gray = (gray * contrast) + intercept;

        // Clamp 0-255
        gray = Math.max(0, Math.min(255, gray));

        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
    }
    ctx.putImageData(imageData, 0, 0);

    return canvas.toDataURL('image/jpeg', 1.0);
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\js\ocrInterop.js
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\appsettings.json
================================================================================
{
  "Supabase": {
    "Url": "https://ithuvxvsoozmvdicxedx.supabase.co",
    "AnonKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0"
  },
  "ApiBaseUrl": "https://storhaugen-eats-api-a7ckh4hwdvcagcb7.westeurope-01.azurewebsites.net"
}


================================================================================
FILE END: \StorhaugenWebsite\wwwroot\appsettings.json
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\index.html
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Storhaugen Eats</title>
    <script>
        // Sjekker om vi kjører på localhost eller 127.0.0.1
        var path = window.location.hostname.includes('localhost') || window.location.hostname.includes('127.0.0.1')
            ? '/'
            : '/StorhaugenWebsite/'; // Navnet på repoet/mappen din i production

        document.write('<base href="' + path + '" />');
    </script>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="apple-touch-icon" href="icon-192.png" />

    <!-- MudBlazor CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />

    <!-- Custom Styles -->
    <link href="css/app.css" rel="stylesheet" />
    <link href="css/Food.css" rel="stylesheet" />
    <link href="css/Layout.css" rel="stylesheet" />
    <link href="css/Login.css" rel="stylesheet" />


    <!-- PWA -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0f172a" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
</head>
<body>
    <div id="app">
        <div class="app-loading-container">
            <div class="app-loading-logo">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z" />
                </svg>
            </div>

            <h1 class="app-loading-title">Storhaugen Eats</h1>

            <div class="app-loading-bar-container">
                <div class="app-loading-bar"></div>
            </div>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>

    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
    <script src="js/deviceState.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@v5/dist/tesseract.min.js"></script>
    <script src="js/ocrInterop.js?v=2"></script>

    <script type="importmap"></script>
    <script src="_framework/blazor.webassembly#[.{fingerprint}].js"></script>
</body>
</html>

<style>
    /* Import fonts immediately so they are ready */
    @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Fraunces:wght@400;600&display=swap');

    :root {
        --loading-bg: #1e1e1e; /* Dark background to match app */
        --loading-text: #ffffff;
        --loading-primary: #E07A2E; /* Your Markus Orange color */
        --loading-primary-dark: #bf6322;
    }

    /* Light Mode Support - optional if you want strictly dark */
    @media (prefers-color-scheme: light) {
        :root {
            --loading-bg: #ffffff;
            --loading-text: #2d2d2d;
        }
    }

    body {
        margin: 0;
        background-color: var(--loading-bg); /* Prevents white flash */
    }

    .app-loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100vw;
        background-color: var(--loading-bg);
        font-family: 'DM Sans', sans-serif;
        color: var(--loading-text);
        position: fixed;
        top: 0;
        left: 0;
        z-index: 9999;
    }

    /* The Logo Box - Matches your Login Page Brand Icon */
    .app-loading-logo {
        width: 80px;
        height: 80px;
        border-radius: 20px;
        background: linear-gradient(135deg, var(--loading-primary), var(--loading-primary-dark));
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        margin-bottom: 24px;
        box-shadow: 0 10px 25px rgba(224, 122, 46, 0.4);
        animation: float 3s ease-in-out infinite;
    }

        .app-loading-logo svg {
            width: 40px;
            height: 40px;
        }

    /* Typography - Matches your Headers */
    .app-loading-title {
        font-family: 'Fraunces', serif;
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0 0 32px 0;
        opacity: 0;
        animation: fadeIn 0.8s ease-out 0.2s forwards;
    }

    /* Custom Loading Bar */
    .app-loading-bar-container {
        width: 140px;
        height: 4px;
        background: rgba(128, 128, 128, 0.2);
        border-radius: 2px;
        overflow: hidden;
        opacity: 0;
        animation: fadeIn 0.8s ease-out 0.4s forwards;
    }

    .app-loading-bar {
        width: 100%;
        height: 100%;
        background: var(--loading-primary);
        transform: translateX(-100%);
        animation: loading 1.5s infinite ease-in-out;
        border-radius: 2px;
    }

    /* Animations */
    @keyframes float {
        0%, 100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-6px);
        }
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes loading {
        0% {
            transform: translateX(-100%);
        }

        50% {
            transform: translateX(0);
        }

        100% {
            transform: translateX(100%);
        }
    }
</style>

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\index.html
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\wwwroot\manifest.json
================================================================================
{
  "name": "Storhaugen Eats",
  "short_name": "Storhaugen",
  "start_url": "./",
  "display": "standalone",
  "background_color": "#0f172a",
  "theme_color": "#0f172a",
  "scope": "/StorhaugenWebsite/",
  "orientation": "portrait",
  "icons": [
    {
      "src": "icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

================================================================================
FILE END: \StorhaugenWebsite\wwwroot\manifest.json
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\App.razor
================================================================================
@using Microsoft.AspNetCore.Components.Authorization
@using StorhaugenWebsite.Shared
@using StorhaugenWebsite.Services
@using MudBlazor

@inject AuthenticationStateProvider AuthStateProvider
@inject IThemeService ThemeService
@inject IDeviceStateService DeviceState
@inject IAuthService AuthService
@inject IHouseholdStateService HouseholdState

<MudThemeProvider @ref="_themeProvider" @bind-IsDarkMode="@_isDarkMode" Theme="_currentTheme" />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

@if (!_isAuthReady)
{
    <div class="d-flex justify-center align-center" style="height: 100vh; width: 100vw; background-color: var(--mud-palette-background);">
        <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
    </div>
}
else
{
    <CascadingAuthenticationState>
        <Router AppAssembly="@typeof(App).Assembly">
            <Found Context="routeData">
                <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
                    <NotAuthorized>
                        <LayoutView Layout="@typeof(MainLayout)">
                             <div class="login-required-container">
                                 <div class="empty-state">
                                     <MudIcon Icon="@Icons.Material.Rounded.Lock" Size="Size.Large" />
                                     <h3>Vennligst logg inn</h3>
                                     <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="login">G til innlogging</MudButton>
                                 </div>
                             </div>
                        </LayoutView>
                    </NotAuthorized>
                </AuthorizeRouteView>
                <FocusOnNavigate RouteData="@routeData" Selector="h1" />
            </Found>
            <NotFound>
                <PageTitle>Not found</PageTitle>
                <LayoutView Layout="@typeof(MainLayout)">
                    <MudContainer MaxWidth="MaxWidth.Small" Class="d-flex flex-column align-center justify-center" Style="height: 60vh;">
                        <MudText Typo="Typo.h4">Page Not Found</MudText>
                    </MudContainer>
                </LayoutView>
            </NotFound>
        </Router>
    </CascadingAuthenticationState>
}

@code {
    private MudThemeProvider? _themeProvider;
    private MudTheme _currentTheme = new();
    private bool _isDarkMode = false;
    
    // Flag to hold the UI until auth is ready
    private bool _isAuthReady = false;

    protected override async Task OnInitializedAsync()
    {
        // 1. Initialize synchronous/basic services
        await DeviceState.InitializeAsync();
        
        // 2. Wait for Auth to restore from LocalStorage
        // We capture the state here so we can check it immediately below
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        
        // 3. IF LOGGED IN: Initialize Household State immediately
        // This prevents the "No Household" flash because we wait for this 
        // to finish before setting _isAuthReady = true.
        if (authState.User.Identity?.IsAuthenticated == true)
        {
            await HouseholdState.InitializeAsync();
        }
        
        // 4. Mark as ready - UI will now render
        _isAuthReady = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ThemeService.InitializeAsync();
            ThemeService.OnThemeChanged += OnThemeChanged;
            
            _currentTheme = ThemeService.GetCurrentTheme();
            _isDarkMode = ThemeService.IsDarkMode;
            StateHasChanged();
        }
    }

    private void OnThemeChanged()
    {
        _currentTheme = ThemeService.GetCurrentTheme();
        _isDarkMode = ThemeService.IsDarkMode;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        ThemeService.OnThemeChanged -= OnThemeChanged;
    }
}

================================================================================
FILE END: \StorhaugenWebsite\App.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\Program.cs
================================================================================
using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using MudBlazor.Services;
using StorhaugenWebsite;
using StorhaugenWebsite.Services;
using StorhaugenWebsite.ApiClient;
using Supabase;
using Microsoft.AspNetCore.Components.Authorization;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");
builder.RootComponents.Add<HeadOutlet>("head::after");

// API HttpClient - Configure base URL for API calls
#if DEBUG
var apiBaseUrl = "https://localhost:64797"; // Local API for development
#else
var apiBaseUrl = "https://storhaugen-eats-api-a7ckh4hwdvcagcb7.westeurope-01.azurewebsites.net"; // Azure API for production
#endif

builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(apiBaseUrl) });

// MudBlazor
builder.Services.AddMudServices();

// Supabase Client
var supabaseUrl = "https://ithuvxvsoozmvdicxedx.supabase.co";
var supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml0aHV2eHZzb296bXZkaWN4ZWR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NjA1NzIsImV4cCI6MjA4MDUzNjU3Mn0._CnQGm26PbG_8HxoLy5m1lQIfFT6P1RNhLNnbQ4DDy0";

var options = new SupabaseOptions
{
    AutoConnectRealtime = false // We don't need realtime in the frontend
};

builder.Services.AddScoped(sp => new Supabase.Client(supabaseUrl, supabaseAnonKey, options));

// Authentication & API Services
builder.Services.AddScoped<IAuthService, SupabaseAuthService>();
builder.Services.AddScoped<IApiClient, ApiClient>();
builder.Services.AddScoped<IHouseholdStateService, HouseholdStateService>();
builder.Services.AddAuthorizationCore();
builder.Services.AddScoped<AuthenticationStateProvider, SupabaseAuthStateProvider>();
// Other Services
builder.Services.AddScoped<IDeviceStateService, DeviceStateService>();
builder.Services.AddScoped<IThemeService, ThemeService>();
builder.Services.AddScoped<IOcrService, TesseractOcrService>();

// Food Service - Uses ApiClient now for backward compatibility with existing pages
builder.Services.AddScoped<IFoodService, FoodService>();

// User-centric services (new architecture)
builder.Services.AddScoped<IUserRecipeService, UserRecipeService>();
builder.Services.AddScoped<IUserFriendshipService, UserFriendshipService>();
builder.Services.AddScoped<IActivityFeedService, ActivityFeedService>();

var host = builder.Build();
var authService = host.Services.GetRequiredService<IAuthService>();
await authService.InitializeAsync();

// Initialize household state (will auto-load after auth)
var householdStateService = host.Services.GetRequiredService<IHouseholdStateService>();
await householdStateService.InitializeAsync();

await host.RunAsync();


================================================================================
FILE END: \StorhaugenWebsite\Program.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\StorhaugenWebsite.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <OverrideHtmlAssetPlaceholders>true</OverrideHtmlAssetPlaceholders>
  </PropertyGroup>

	<Target Name="Make404" AfterTargets="Publish">
		<Copy SourceFiles="$(PublishDir)wwwroot\index.html" DestinationFiles="$(PublishDir)wwwroot\404.html" />
	</Target>

  <ItemGroup>
    <Content Remove="Components\AddFood.razor" />
    <Content Remove="Components\Archived.razor" />
    <Content Remove="Components\FoodDetail.razor" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Components.Authorization" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="10.0.0" PrivateAssets="all" />
    <PackageReference Include="MudBlazor" Version="8.15.0" />
	  
	<PackageReference Include="Supabase" Version="1.1.1" />
	<PackageReference Include="Supabase.Gotrue" Version="6.0.3" />
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Brokers\" />
    <Folder Include="Components\" />
    <Folder Include="wwwroot\images\" />
  </ItemGroup>

  <ItemGroup>
    <Content Update="wwwroot\.nojekyll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenWebsite\StorhaugenWebsite.csproj
================================================================================


================================================================================
FILE START: \StorhaugenWebsite\_Imports.razor
================================================================================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components.WebAssembly.Http
@using Microsoft.JSInterop
@using MudBlazor
@using StorhaugenWebsite
@using StorhaugenWebsite.Models
@using StorhaugenWebsite.Services


================================================================================
FILE END: \StorhaugenWebsite\_Imports.razor
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// ACTIVITY FEED DTOs
// ==========================================

/// <summary>
/// DTO for a single activity feed item.
/// </summary>
public class ActivityFeedItemDto
{
    public Guid Id { get; set; }

    // User who performed the action
    public Guid UserId { get; set; }
    public string UserDisplayName { get; set; } = string.Empty;
    public string? UserAvatarUrl { get; set; }

    /// <summary>
    /// Type of activity: "rated", "added", "published", "joined_household".
    /// </summary>
    public string ActivityType { get; set; } = string.Empty;

    /// <summary>
    /// Type of target: "user_recipe", "global_recipe", "household".
    /// </summary>
    public string TargetType { get; set; } = string.Empty;

    public Guid TargetId { get; set; }

    // Denormalized data for display
    public string? RecipeName { get; set; }
    public string? RecipeImageUrl { get; set; }
    public int? RatingScore { get; set; }
    public string? HouseholdName { get; set; }

    public DateTime CreatedAt { get; set; }

    /// <summary>
    /// Human-readable activity description.
    /// Example: "Sarah rated Spaghetti Carbonara 9/10"
    /// </summary>
    public string Description => GenerateDescription();

    private string GenerateDescription()
    {
        return ActivityType switch
        {
            "rated" => $"{UserDisplayName} rated {RecipeName ?? "a recipe"} {RatingScore}/10",
            "added" => $"{UserDisplayName} added {RecipeName ?? "a new recipe"}",
            "published" => $"{UserDisplayName} published {RecipeName ?? "a recipe"} to the community",
            "joined_household" => $"{UserDisplayName} joined {HouseholdName ?? "a household"}",
            _ => $"{UserDisplayName} did something"
        };
    }
}

/// <summary>
/// Query parameters for the activity feed.
/// </summary>
public class ActivityFeedQuery
{
    /// <summary>
    /// Filter by activity types. If empty, all types are included.
    /// </summary>
    public List<string>? Types { get; set; }

    /// <summary>
    /// Only show activities from specific users. If empty, shows all friends.
    /// </summary>
    public List<Guid>? UserIds { get; set; }

    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}

/// <summary>
/// Paged result for activity feed.
/// </summary>
public class ActivityFeedPagedResult
{
    public List<ActivityFeedItemDto> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasMore => Page < TotalPages;
}

/// <summary>
/// Summary of recent activity for a user.
/// </summary>
public class ActivitySummaryDto
{
    public int TotalActivities { get; set; }
    public int RecipesAdded { get; set; }
    public int RecipesRated { get; set; }
    public int RecipesPublished { get; set; }
    public DateTime? LastActivityDate { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\ActivityFeedDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// USER FRIENDSHIP DTOs
// ==========================================

/// <summary>
/// DTO for a single friendship.
/// </summary>
public class UserFriendshipDto
{
    public Guid Id { get; set; }
    public Guid FriendUserId { get; set; }
    public string FriendDisplayName { get; set; } = string.Empty;
    public string? FriendAvatarUrl { get; set; }
    public string FriendShareId { get; set; } = string.Empty;

    /// <summary>
    /// Status from the current user's perspective:
    /// - "accepted" - You are friends
    /// - "pending_sent" - You sent a request, waiting for response
    /// - "pending_received" - You received a request, needs your response
    /// </summary>
    public string Status { get; set; } = string.Empty;

    public string? Message { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? RespondedAt { get; set; }

    /// <summary>
    /// Number of recipes the friend has (visible to you).
    /// </summary>
    public int RecipeCount { get; set; }
}

/// <summary>
/// DTO containing all friendship lists for a user.
/// </summary>
public class FriendshipListDto
{
    public List<UserFriendshipDto> Friends { get; set; } = new();
    public List<UserFriendshipDto> PendingSent { get; set; } = new();
    public List<UserFriendshipDto> PendingReceived { get; set; } = new();

    public int TotalFriends => Friends.Count;
    public int PendingCount => PendingSent.Count + PendingReceived.Count;
}

/// <summary>
/// DTO for sending a friend request.
/// </summary>
public class SendFriendRequestDto
{
    /// <summary>
    /// Target user ID (if known).
    /// </summary>
    public Guid? TargetUserId { get; set; }

    /// <summary>
    /// Target user's share ID (alternative to UserId).
    /// </summary>
    public string? TargetShareId { get; set; }

    /// <summary>
    /// Optional message to include with the request.
    /// </summary>
    public string? Message { get; set; }
}

/// <summary>
/// DTO for responding to a friend request.
/// </summary>
public class RespondFriendRequestDto
{
    /// <summary>
    /// Action to take: "accept" or "reject".
    /// </summary>
    public string Action { get; set; } = string.Empty;
}

/// <summary>
/// DTO for a friend's basic profile info.
/// </summary>
public class FriendProfileDto
{
    public Guid Id { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public string ShareId { get; set; } = string.Empty;
    public string? Bio { get; set; }
    public bool IsProfilePublic { get; set; }
    public List<string> FavoriteCuisines { get; set; } = new();
    public int RecipeCount { get; set; }
    public DateTime JoinedAt { get; set; }
}

/// <summary>
/// Search result for finding users to friend.
/// </summary>
public class UserSearchResultDto
{
    public Guid Id { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public string ShareId { get; set; } = string.Empty;

    /// <summary>
    /// Current friendship status with this user:
    /// - "none" - No relationship
    /// - "friends" - Already friends
    /// - "pending_sent" - You sent them a request
    /// - "pending_received" - They sent you a request
    /// </summary>
    public string FriendshipStatus { get; set; } = "none";
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\FriendshipDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class GlobalRecipeDto
{
    public Guid Id { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public string? ImageUrl { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }
    public object? NutritionData { get; set; }
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? TotalTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public List<string> Tags { get; set; } = new();
    public string? Cuisine { get; set; }

    // HelloFresh specific
    public bool IsHellofresh { get; set; }
    public string? HellofreshUuid { get; set; }
    public string? HellofreshSlug { get; set; }

    // User-created
    public Guid? CreatedByUserId { get; set; }
    public string? CreatedByUserName { get; set; }

    // Aggregated ratings
    public double AverageRating { get; set; }
    public int TotalRatings { get; set; }
    public int TotalTimesAdded { get; set; }

    public DateTime CreatedAt { get; set; }
}

public class CreateGlobalRecipeDto
{
    public required string Name { get; set; }
    public string? Description { get; set; }
    public string? ImageUrl { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }
    public object? NutritionData { get; set; }
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public List<string> Tags { get; set; } = new();
    public string? Cuisine { get; set; }
}

public class BrowseGlobalRecipesQuery
{
    public string? Search { get; set; }
    public string? Cuisine { get; set; }
    public string? Difficulty { get; set; }
    public int? MaxPrepTime { get; set; }
    public List<string>? Tags { get; set; }
    public bool HellofreshOnly { get; set; } = false;
    public string SortBy { get; set; } = "popular"; // popular, newest, rating, name
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}

public class GlobalRecipePagedResult
{
    public List<GlobalRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\GlobalRecipeDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\HouseholdAggregationDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// HOUSEHOLD AGGREGATION DTOs
// ==========================================

/// <summary>
/// DTO for an aggregated recipe from household members.
/// This is used when viewing the "Family Cookbook" - an aggregation of all member recipes.
/// </summary>
public class AggregatedRecipeDto
{
    public Guid UserRecipeId { get; set; }

    // Owner info
    public Guid OwnerUserId { get; set; }
    public string OwnerDisplayName { get; set; } = string.Empty;
    public string? OwnerAvatarUrl { get; set; }

    // Recipe info
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List<string> ImageUrls { get; set; } = new();

    // Link status
    public Guid? GlobalRecipeId { get; set; }
    public bool IsLinkedToGlobal => GlobalRecipeId.HasValue;

    [Obsolete("Use MemberRatings instead.")]
    public Dictionary<string, int?> HouseholdRatings { get; set; } = new();

    // Ratings from household members
    public List<MemberRatingDto> MemberRatings { get; set; } = new();
    public double HouseholdAverageRating { get; set; }
    public int HouseholdRatingCount { get; set; }

    public DateTime CreatedAt { get; set; }
}

/// <summary>
/// DTO for a "common favorite" - a recipe that multiple household members have rated highly.
/// </summary>
public class CommonFavoriteDto
{
    /// <summary>
    /// The GlobalRecipeId that multiple members have in common.
    /// </summary>
    public Guid GlobalRecipeId { get; set; }

    public string Name { get; set; } = string.Empty;
    public string? ImageUrl { get; set; }
    public string? Description { get; set; }

    // Member ratings
    public List<MemberRatingDto> MemberRatings { get; set; } = new();
    public double AverageRating { get; set; }
    public int MembersWhoRated { get; set; }

    /// <summary>
    /// Whether this recipe is already in the current user's collection.
    /// </summary>
    public bool IsInMyCollection { get; set; }
}

/// <summary>
/// DTO for a single member's rating.
/// </summary>
public class MemberRatingDto
{
    public Guid UserId { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? AvatarUrl { get; set; }
    public int Rating { get; set; }
    public string? Comment { get; set; }
    public DateTime RatedAt { get; set; }
}

/// <summary>
/// Query parameters for getting combined household recipes.
/// </summary>
public class GetCombinedRecipesQuery
{
    /// <summary>
    /// Filter to only show recipes from specific members.
    /// </summary>
    public List<Guid>? FilterByMembers { get; set; }

    /// <summary>
    /// Minimum average rating (from household members).
    /// </summary>
    public double? MinRating { get; set; }

    /// <summary>
    /// Search term for recipe name.
    /// </summary>
    public string? Search { get; set; }

    public string SortBy { get; set; } = "date";
    public bool SortDescending { get; set; } = true;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
}

/// <summary>
/// Query parameters for getting recipes from multiple groups (households).
/// Used for the multi-group aggregation feature.
/// </summary>
public class GetMultiGroupRecipesQuery
{
    /// <summary>
    /// List of group (household) IDs to aggregate recipes from.
    /// </summary>
    public List<Guid> GroupIds { get; set; } = new();

    /// <summary>
    /// Filter to only show recipes from specific members.
    /// </summary>
    public List<Guid>? FilterByMembers { get; set; }

    /// <summary>
    /// Minimum average rating (from group members).
    /// </summary>
    public double? MinRating { get; set; }

    /// <summary>
    /// Search term for recipe name.
    /// </summary>
    public string? Search { get; set; }

    public string SortBy { get; set; } = "date";
    public bool SortDescending { get; set; } = true;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
}

/// <summary>
/// Query parameters for getting common favorites from multiple groups.
/// </summary>
public class GetMultiGroupFavoritesQuery
{
    /// <summary>
    /// List of group (household) IDs to aggregate favorites from.
    /// </summary>
    public List<Guid> GroupIds { get; set; } = new();

    /// <summary>
    /// Minimum number of members who must have rated the recipe.
    /// </summary>
    public int MinMembers { get; set; } = 2;

    /// <summary>
    /// Minimum average rating from those members.
    /// </summary>
    public double MinAverageRating { get; set; } = 4.0;

    public int Limit { get; set; } = 20;
}

/// <summary>
/// Query parameters for getting common favorites.
/// </summary>
public class GetCommonFavoritesQuery
{
    /// <summary>
    /// Minimum number of members who must have rated the recipe.
    /// </summary>
    public int MinMembers { get; set; } = 2;

    /// <summary>
    /// Minimum average rating from those members.
    /// </summary>
    public double MinAverageRating { get; set; } = 4.0;

    public int Limit { get; set; } = 20;
}

/// <summary>
/// Paged result for aggregated recipes.
/// </summary>
public class AggregatedRecipePagedResult
{
    public List<AggregatedRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\HouseholdAggregationDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\HouseholdDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class HouseholdDto
{
    public Guid Id { get; set; }
    public required string Name { get; set; }
    public Guid CreatedById { get; set; }
    public string? CreatedByName { get; set; }
    public DateTime CreatedAt { get; set; }
    public List<HouseholdMemberDto> Members { get; set; } = new();
    public string? UniqueShareId { get; set; }
    public bool IsPrivate { get; set; }
}

public class HouseholdMemberDto
{
    public Guid UserId { get; set; }
    public required string Email { get; set; }
    public required string DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
    public DateTime JoinedAt { get; set; }
}

public class CreateHouseholdDto
{
    public required string Name { get; set; }
}

public class UpdateHouseholdDto
{
    public required string Name { get; set; }
    public bool? IsPrivate { get; set; }
}

public class UpdateHouseholdSettingsDto
{
    public bool? IsPrivate { get; set; }
}

public class InviteToHouseholdDto
{
    public string? Email { get; set; }
    public string? UniqueShareId { get; set; }
}

public class HouseholdSearchResultDto
{
    public Guid Id { get; set; }
    public required string Name { get; set; }
    public string? UniqueShareId { get; set; }
    public int MemberCount { get; set; }
    public DateTime CreatedAt { get; set; }
    public bool IsPrivate { get; set; }
}

public class HouseholdInviteDto
{
    public Guid Id { get; set; }
    public Guid HouseholdId { get; set; }
    public required string HouseholdName { get; set; }
    public Guid InvitedById { get; set; }
    public required string InvitedByName { get; set; }
    public required string InvitedEmail { get; set; }
    public string Status { get; set; } = "pending";
    public DateTime CreatedAt { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\HouseholdDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\HouseholdFriendshipDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class HouseholdFriendshipDto
{
    public Guid Id { get; set; }
    public Guid RequesterHouseholdId { get; set; }
    public required string RequesterHouseholdName { get; set; }
    public Guid TargetHouseholdId { get; set; }
    public required string TargetHouseholdName { get; set; }
    public required string Status { get; set; }
    public string? Message { get; set; }
    public string? RequestedByUserName { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? RespondedAt { get; set; }
}

public class SendHouseholdFriendRequestDto
{
    public string? HouseholdShareId { get; set; }
    public Guid? HouseholdId { get; set; }
    public string? Message { get; set; }
}

public class RespondHouseholdFriendRequestDto
{
    public required string Action { get; set; } // accept or reject
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\HouseholdFriendshipDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\HouseholdRecipeDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class HouseholdRecipeDto
{
    public Guid Id { get; set; }
    public Guid HouseholdId { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public Dictionary<string, int?> Ratings { get; set; } = new();
    public double AverageRating { get; set; }
    public DateTime DateAdded { get; set; }
    public Guid AddedByUserId { get; set; }
    public string? AddedByName { get; set; }
    public bool IsArchived { get; set; }
    public DateTime? ArchivedDate { get; set; }
    public Guid? ArchivedByUserId { get; set; }
    public string? ArchivedByName { get; set; }

    // If linked to global recipe
    public Guid? GlobalRecipeId { get; set; }
    public string? GlobalRecipeName { get; set; }
    public bool IsForked { get; set; }
    public string? PersonalNotes { get; set; }

    // Public sharing
    public bool IsPublic { get; set; }
    public string? HouseholdName { get; set; }
}

public class CreateHouseholdRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public string? ImageUrl { get; set; }
    public string? PersonalNotes { get; set; }
    public bool IsPublic { get; set; } = false;

    // Optional: Link to global recipe
    public Guid? GlobalRecipeId { get; set; }
    public bool Fork { get; set; } = false; // If true, copy recipe; if false, link to it

    // Additional fields for forking
    public int? PrepTimeMinutes { get; set; }
    public int? Servings { get; set; }
    public string? Difficulty { get; set; }
    public string? Cuisine { get; set; }
    public List<string>? Tags { get; set; }
    public object? Ingredients { get; set; }
    public object? Instructions { get; set; }
}

public class UpdateHouseholdRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public string? PersonalNotes { get; set; }
    public bool? IsPublic { get; set; }
}

public class RateRecipeDto
{
    public int Rating { get; set; } // 0-10
}

// Public recipes (community)
public class PublicRecipeDto
{
    public Guid Id { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public double AverageRating { get; set; }
    public int RatingCount { get; set; }
    public DateTime DateAdded { get; set; }
    public string HouseholdName { get; set; } = string.Empty;
    public string? AddedByName { get; set; }
    public Guid HouseholdId { get; set; }
    public Guid? GlobalRecipeId { get; set; }
}

public class BrowsePublicRecipesQuery
{
    public string? Search { get; set; }
    public string SortBy { get; set; } = "newest";
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}

public class PublicRecipePagedResult
{
    public List<PublicRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\HouseholdRecipeDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UploadImageDto
{
    public required string FileName { get; set; }
    public required string Base64Data { get; set; }
    public string Bucket { get; set; } = "recipe-images";
}

public class UploadImageResultDto
{
    public required string Url { get; set; }
    public required string FileName { get; set; }
}

public class DeleteImageDto
{
    public required string FileName { get; set; }
    public string Bucket { get; set; } = "recipe-images";
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\StorageDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// TAG DTOs - Personal Recipe Organization
// ==========================================

/// <summary>
/// DTO representing a recipe tag/category.
/// </summary>
public class TagDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
    public string? Icon { get; set; }
    public int RecipeCount { get; set; }
    public DateTime CreatedAt { get; set; }
}

/// <summary>
/// DTO for creating a new tag.
/// </summary>
public class CreateTagDto
{
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
    public string? Icon { get; set; }
}

/// <summary>
/// DTO for updating a tag.
/// </summary>
public class UpdateTagDto
{
    public string? Name { get; set; }
    public string? Color { get; set; }
    public string? Icon { get; set; }
}

/// <summary>
/// DTO for adding/removing tags from a recipe.
/// </summary>
public class UpdateRecipeTagsDto
{
    /// <summary>
    /// List of tag IDs to set on the recipe (replaces existing tags).
    /// </summary>
    public List<Guid> TagIds { get; set; } = new();
}

/// <summary>
/// Simplified tag reference for use in recipe DTOs.
/// </summary>
public class TagReferenceDto
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Color { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\TagDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UserDto
{
    public Guid Id { get; set; }
    public required string Email { get; set; }
    public required string DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
    public Guid? CurrentHouseholdId { get; set; }
    public required string UniqueShareId { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class CreateUserDto
{
    public required string Email { get; set; }
    public required string DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
}

public class UpdateUserDto
{
    public string? DisplayName { get; set; }
    public string? AvatarUrl { get; set; }
    public Guid? CurrentHouseholdId { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

public class UserRatingDto
{
    public Guid? GlobalRecipeId { get; set; } 
    public Guid? UserRecipeId { get; set; }   
    public string RecipeTitle { get; set; } = "";
    public string? ImageUrl { get; set; }
    public int Score { get; set; }
    public string? Comment { get; set; }
    public DateTime RatedAt { get; set; }
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserRatingDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
================================================================================
namespace StorhaugenWebsite.Shared.DTOs;

// ==========================================
// USER RECIPE DTOs
// ==========================================

/// <summary>
/// DTO for returning user recipe data.
/// </summary>
public class UserRecipeDto
{
    public Guid Id { get; set; }
    public Guid UserId { get; set; }
    public string UserDisplayName { get; set; } = string.Empty;
    public string? UserAvatarUrl { get; set; }

    // Recipe data (resolved from local or global)
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List<string> ImageUrls { get; set; } = new();
    public object? Ingredients { get; set; }

    // Link status
    public Guid? GlobalRecipeId { get; set; }
    public string? GlobalRecipeName { get; set; }
    public bool IsLinkedToGlobal => GlobalRecipeId.HasValue;
    public bool IsPublished { get; set; }

    // Metadata
    public string Visibility { get; set; } = "private";
    public string? PersonalNotes { get; set; }
    public bool IsArchived { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    // Ratings
    public int? MyRating { get; set; }
    public double AverageRating { get; set; }
    public int RatingCount { get; set; }
    public Dictionary<string, int?> HouseholdRatings { get; set; } = new();
    public List<MemberRatingDto> MemberRatings { get; set; } = new();


    // Tags (personal organization)
    public List<TagReferenceDto> Tags { get; set; } = new();
}

/// <summary>
/// DTO for creating a new user recipe.
/// </summary>
public class CreateUserRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public object? Ingredients { get; set; }
    public string? PersonalNotes { get; set; }
    public Guid? GlobalRecipeId { get; set; }
    public string Visibility { get; set; } = "private";

    // Tags (personal organization)
    public List<Guid>? TagIds { get; set; }

    // --- NEW: Dictionary of UserID -> Score (1-10) ---
    public Dictionary<Guid, int>? MemberRatings { get; set; }
}

/// <summary>
/// DTO for updating a user recipe.
/// </summary>
public class UpdateUserRecipeDto
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public List<string>? ImageUrls { get; set; }
    public object? Ingredients { get; set; }
    public string? PersonalNotes { get; set; }
    public string? Visibility { get; set; }

    // Tags (personal organization)
    public List<Guid>? TagIds { get; set; }
}

/// <summary>
/// DTO for publishing a recipe result.
/// </summary>
public class PublishRecipeResultDto
{
    public UserRecipeDto UserRecipe { get; set; } = null!;
    public Guid GlobalRecipeId { get; set; }
    public string Message { get; set; } = string.Empty;
}

/// <summary>
/// Query parameters for getting user recipes.
/// </summary>
public class GetUserRecipesQuery
{
    public string? Visibility { get; set; }
    public bool IncludeArchived { get; set; } = false;
    public string SortBy { get; set; } = "date";
    public bool SortDescending { get; set; } = true;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;

    // Tag filtering
    public List<Guid>? TagIds { get; set; }
    public string? Search { get; set; }
}

/// <summary>
/// Paged result for user recipes.
/// </summary>
public class UserRecipePagedResult
{
    public List<UserRecipeDto> Recipes { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


================================================================================
FILE END: \StorhaugenWebsite.Shared\DTOs\UserRecipeDTOs.cs
================================================================================


================================================================================
FILE START: \StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj
================================================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.ComponentModel.Annotations" Version="5.0.0" />
  </ItemGroup>

</Project>


================================================================================
FILE END: \StorhaugenWebsite.Shared\StorhaugenWebsite.Shared.csproj
================================================================================

